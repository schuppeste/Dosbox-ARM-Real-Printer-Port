acinclude.m4:  typedef Bit32u Bitu;
acinclude.m4:  typedef Bit64u Bitu;
include/video.h:void GFX_SetPalette(Bitu start,Bitu count,GFX_PalEntry * entries);
include/video.h:Bitu GFX_GetBestMode(Bitu flags);
include/video.h:Bitu GFX_GetRGB(Bit8u red,Bit8u green,Bit8u blue);
include/video.h:Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t cb);
include/video.h:bool GFX_StartUpdate(Bit8u * & pixels,Bitu & pitch);
include/programs.h:	bool GetEnvNum(Bitu num,std::string & result);
include/programs.h:	Bitu GetEnvCount(void);
include/callback.h:typedef Bitu (*CallBack_Handler)(void);
include/callback.h:static INLINE RealPt CALLBACK_RealPointer(Bitu callback) {
include/callback.h:static INLINE PhysPt CALLBACK_PhysPointer(Bitu callback) {
include/callback.h:Bitu CALLBACK_Allocate();
include/callback.h:bool CALLBACK_Setup(Bitu callback,CallBack_Handler handler,Bitu type,const char* descr);
include/callback.h:Bitu CALLBACK_Setup(Bitu callback,CallBack_Handler handler,Bitu type,PhysPt addr,const char* descr);
include/callback.h:const char* CALLBACK_GetDescription(Bitu callback);
include/callback.h:bool CALLBACK_Free(Bitu callback);
include/callback.h:extern Bitu call_priv_io;
include/callback.h:	Bitu m_callback;
include/callback.h:	void Install(CallBack_Handler handler,Bitu type,const char* description);
include/callback.h:	void Install(CallBack_Handler handler,Bitu type,PhysPt addr,const char* description);
include/pic.h:typedef void (* PIC_EventHandler)(Bitu val);
include/pic.h:extern Bitu PIC_IRQCheck;
include/pic.h:extern Bitu PIC_Ticks;
include/pic.h:void PIC_ActivateIRQ(Bitu irq);
include/pic.h:void PIC_DeActivateIRQ(Bitu irq);
include/pic.h:void PIC_AddEvent(PIC_EventHandler handler,float delay,Bitu val=0);
include/pic.h:void PIC_RemoveSpecificEvents(PIC_EventHandler handler, Bitu val);
include/pic.h:void PIC_SetIRQMask(Bitu irq, bool masked);
include/dos_inc.h:bool DOS_LayoutKey(Bitu key, Bit8u flags1, Bit8u flags2, Bit8u flags3);
include/dos_inc.h:	Bitu GetIt(Bitu size,PhysPt addr) {
include/dos_inc.h:	void SaveIt(Bitu size,PhysPt addr,Bitu val) {
include/mapper.h:void MAPPER_AddHandler(MAPPER_Handler * handler,MapKeys key,Bitu mods,char const * const eventname,char const * const buttonname);
include/mixer.h:typedef void (*MIXER_Handler)(Bitu len);
include/mixer.h:	void SetFreq(Bitu _freq);
include/mixer.h:	void Mix(Bitu _needed);
include/mixer.h:	void AddSamples(Bitu len, const Type* data);
include/mixer.h:	void AddSamples_m8(Bitu len, const Bit8u * data);
include/mixer.h:	void AddSamples_s8(Bitu len, const Bit8u * data);
include/mixer.h:	void AddSamples_m8s(Bitu len, const Bit8s * data);
include/mixer.h:	void AddSamples_s8s(Bitu len, const Bit8s * data);
include/mixer.h:	void AddSamples_m16(Bitu len, const Bit16s * data);
include/mixer.h:	void AddSamples_s16(Bitu len, const Bit16s * data);
include/mixer.h:	void AddSamples_m16u(Bitu len, const Bit16u * data);
include/mixer.h:	void AddSamples_s16u(Bitu len, const Bit16u * data);
include/mixer.h:	void AddSamples_m32(Bitu len, const Bit32s * data);
include/mixer.h:	void AddSamples_s32(Bitu len, const Bit32s * data);
include/mixer.h:	void AddSamples_m16_nonnative(Bitu len, const Bit16s * data);
include/mixer.h:	void AddSamples_s16_nonnative(Bitu len, const Bit16s * data);
include/mixer.h:	void AddSamples_m16u_nonnative(Bitu len, const Bit16u * data);
include/mixer.h:	void AddSamples_s16u_nonnative(Bitu len, const Bit16u * data);
include/mixer.h:	void AddSamples_m32_nonnative(Bitu len, const Bit32s * data);
include/mixer.h:	void AddSamples_s32_nonnative(Bitu len, const Bit32s * data);
include/mixer.h:	void AddStretched(Bitu len,Bit16s * data);		//Strech block up into needed data
include/mixer.h:	Bitu freq_add,freq_index;
include/mixer.h:	Bitu done,needed;
include/mixer.h:MixerChannel * MIXER_AddChannel(MIXER_Handler handler,Bitu freq,const char * name);
include/mixer.h:	MixerChannel* Install(MIXER_Handler handler,Bitu freq,const char * name);
include/mixer.h:void PCSPEAKER_SetCounter(Bitu cntr,Bitu mode);
include/mixer.h:void PCSPEAKER_SetType(Bitu mode);
include/ipx.h:	Bitu buflen;		// by Interrupt
include/ipx.h:	Bitu SerialNumber;
include/dma.h:	Bitu Read(Bitu size, Bit8u * buffer);
include/dma.h:	Bitu Write(Bitu size, Bit8u * buffer);
include/dma.h:	void WriteControllerReg(Bitu reg,Bitu val,Bitu len);
include/dma.h:	Bitu ReadControllerReg(Bitu reg,Bitu len);
include/dma.h:void DMA_SetWrapping(Bitu wrap);
include/fpu.h:void FPU_ESC0_Normal(Bitu rm);
include/fpu.h:void FPU_ESC0_EA(Bitu func,PhysPt ea);
include/fpu.h:void FPU_ESC1_Normal(Bitu rm);
include/fpu.h:void FPU_ESC1_EA(Bitu func,PhysPt ea);
include/fpu.h:void FPU_ESC2_Normal(Bitu rm);
include/fpu.h:void FPU_ESC2_EA(Bitu func,PhysPt ea);
include/fpu.h:void FPU_ESC3_Normal(Bitu rm);
include/fpu.h:void FPU_ESC3_EA(Bitu func,PhysPt ea);
include/fpu.h:void FPU_ESC4_Normal(Bitu rm);
include/fpu.h:void FPU_ESC4_EA(Bitu func,PhysPt ea);
include/fpu.h:void FPU_ESC5_Normal(Bitu rm);
include/fpu.h:void FPU_ESC5_EA(Bitu func,PhysPt ea);
include/fpu.h:void FPU_ESC6_Normal(Bitu rm);
include/fpu.h:void FPU_ESC6_EA(Bitu func,PhysPt ea);
include/fpu.h:void FPU_ESC7_Normal(Bitu rm);
include/fpu.h:void FPU_ESC7_EA(Bitu func,PhysPt ea);
include/fpu.h:	for(Bitu i=0;i<8;i++)
include/fpu.h:static INLINE void FPU_SetCW(Bitu word){
include/fpu.h:static INLINE Bitu FPU_GET_TOP(void) {
include/fpu.h:static INLINE void FPU_SET_TOP(Bitu val){
include/fpu.h:static INLINE void FPU_SET_C0(Bitu C){
include/fpu.h:static INLINE void FPU_SET_C1(Bitu C){
include/fpu.h:static INLINE void FPU_SET_C2(Bitu C){
include/fpu.h:static INLINE void FPU_SET_C3(Bitu C){
include/midi.h:	virtual void PlaySysex(Bit8u * /*sysex*/,Bitu /*len*/) {};
include/midi.h:	Bitu status;
include/midi.h:	Bitu cmd_len;
include/midi.h:	Bitu cmd_pos;
include/midi.h:		Bitu used;
include/midi.h:		Bitu delay;
include/debug.h:Bitu DEBUG_EnableDebugger(void);
include/debug.h:extern Bitu cycle_count;
include/debug.h:extern Bitu debugCallback;
include/pci_bus.h:	Bitu num_subdevices;
include/pci_bus.h:	void SetPCIId(Bitu number, Bits subfct);
include/inout.h:typedef Bitu IO_ReadHandler(Bitu port,Bitu iolen);
include/inout.h:typedef void IO_WriteHandler(Bitu port,Bitu val,Bitu iolen);
include/inout.h:void IO_RegisterReadHandler(Bitu port,IO_ReadHandler * handler,Bitu mask,Bitu range=1);
include/inout.h:void IO_RegisterWriteHandler(Bitu port,IO_WriteHandler * handler,Bitu mask,Bitu range=1);
include/inout.h:void IO_FreeReadHandler(Bitu port,Bitu mask,Bitu range=1);
include/inout.h:void IO_FreeWriteHandler(Bitu port,Bitu mask,Bitu range=1);
include/inout.h:void IO_WriteB(Bitu port,Bitu val);
include/inout.h:void IO_WriteW(Bitu port,Bitu val);
include/inout.h:void IO_WriteD(Bitu port,Bitu val);
include/inout.h:Bitu IO_ReadB(Bitu port);
include/inout.h:Bitu IO_ReadW(Bitu port);
include/inout.h:Bitu IO_ReadD(Bitu port);
include/inout.h:	Bitu m_port, m_mask,m_range;
include/inout.h:	void Install(Bitu port,IO_ReadHandler * handler,Bitu mask,Bitu range=1);
include/inout.h:	void Install(Bitu port,IO_WriteHandler * handler,Bitu mask,Bitu range=1);
include/inout.h:static INLINE void IO_Write(Bitu port,Bit8u val) {
include/inout.h:static INLINE Bit8u IO_Read(Bitu port){
include/paging.h:	virtual Bitu readb(PhysPt addr);
include/paging.h:	virtual Bitu readw(PhysPt addr);
include/paging.h:	virtual Bitu readd(PhysPt addr);
include/paging.h:	virtual void writeb(PhysPt addr,Bitu val);
include/paging.h:	virtual void writew(PhysPt addr,Bitu val);
include/paging.h:	virtual void writed(PhysPt addr,Bitu val);
include/paging.h:	virtual HostPt GetHostReadPt(Bitu phys_page);
include/paging.h:	virtual HostPt GetHostWritePt(Bitu phys_page);
include/paging.h:	virtual bool writeb_checked(PhysPt addr,Bitu val);
include/paging.h:	virtual bool writew_checked(PhysPt addr,Bitu val);
include/paging.h:	virtual bool writed_checked(PhysPt addr,Bitu val);
include/paging.h:	Bitu flags;
include/paging.h:Bitu PAGING_GetDirBase(void);
include/paging.h:void PAGING_SetDirBase(Bitu cr3);
include/paging.h:void PAGING_LinkPage(Bitu lin_page,Bitu phys_page);
include/paging.h:void PAGING_LinkPage_ReadOnly(Bitu lin_page,Bitu phys_page);
include/paging.h:void PAGING_UnlinkPages(Bitu lin_page,Bitu pages);
include/paging.h:void PAGING_MapPage(Bitu lin_page,Bitu phys_page);
include/paging.h:bool PAGING_MakePhysPage(Bitu & page);
include/paging.h:bool PAGING_ForcePageInit(Bitu lin_addr);
include/paging.h:void MEM_SetLFB(Bitu page, Bitu pages, PageHandler *handler, PageHandler *mmiohandler);
include/paging.h:void MEM_SetPageHandler(Bitu phys_page, Bitu pages, PageHandler * handler);
include/paging.h:void MEM_ResetPageHandler(Bitu phys_page, Bitu pages);
include/paging.h:	Bitu			cr3;
include/paging.h:	Bitu			cr2;
include/paging.h:		Bitu page;
include/paging.h:		Bitu used;
include/paging.h:PageHandler * MEM_GetPageHandler(Bitu phys_page);
include/paging.h:	Bitu index=(address>>12);
include/paging.h:		Bitu bank=(address>>BANK_SHIFT) - 1;
include/hardware.h:extern Bitu CaptureState;
include/hardware.h:bool SB_Get_Address(Bitu& sbaddr, Bitu& sbirq, Bitu& sbdma);
include/hardware.h:bool TS_Get_Address(Bitu& tsaddr, Bitu& tsirq, Bitu& tsdma);
include/hardware.h:void CAPTURE_AddImage(Bitu width, Bitu height, Bitu bpp, Bitu pitch, Bitu flags, float fps, Bit8u * data, Bit8u * pal);
include/hardware.h:void CAPTURE_AddMidi(bool sysex, Bitu len, Bit8u * data);
include/mem.h:Bitu MEM_FreeTotal(void);			//Free 4 kb pages
include/mem.h:Bitu MEM_FreeLargest(void);			//Largest free 4 kb pages block
include/mem.h:Bitu MEM_TotalPages(void);			//Total amount of 4 kb pages
include/mem.h:Bitu MEM_AllocatedPages(MemHandle handle); // amount of allocated pages of handle
include/mem.h:MemHandle MEM_AllocatePages(Bitu pages,bool sequence);
include/mem.h:bool MEM_ReAllocatePages(MemHandle & handle,Bitu pages,bool sequence);
include/mem.h:MemHandle MEM_NextHandleAt(MemHandle handle,Bitu where);
include/mem.h:void MEM_BlockWrite(PhysPt pt,void const * const data,Bitu size);
include/mem.h:void MEM_BlockRead(PhysPt pt,void * data,Bitu size);
include/mem.h:void MEM_BlockCopy(PhysPt dest,PhysPt src,Bitu size);
include/mem.h:void MEM_StrCopy(PhysPt pt,char * data,Bitu size);
include/mem.h:void mem_memcpy(PhysPt dest,PhysPt src,Bitu size);
include/mem.h:Bitu mem_strlen(PhysPt pt);
include/joystick.h:void JOYSTICK_Enable(Bitu which,bool enabled);
include/joystick.h:void JOYSTICK_Button(Bitu which,Bitu num,bool pressed);
include/joystick.h:void JOYSTICK_Move_X(Bitu which,float x);
include/joystick.h:void JOYSTICK_Move_Y(Bitu which,float y);
include/joystick.h:bool JOYSTICK_IsEnabled(Bitu which);
include/joystick.h:bool JOYSTICK_GetButton(Bitu which, Bitu num);
include/joystick.h:float JOYSTICK_GetMove_X(Bitu which);
include/joystick.h:float JOYSTICK_GetMove_Y(Bitu which);
include/cpu.h:extern Bitu CPU_AutoDetermineMode;
include/cpu.h:extern Bitu CPU_ArchitectureType;
include/cpu.h:extern Bitu CPU_PrefetchQueueSize;
include/cpu.h:bool CPU_LLDT(Bitu selector);
include/cpu.h:bool CPU_LTR(Bitu selector);
include/cpu.h:void CPU_LIDT(Bitu limit,Bitu base);
include/cpu.h:void CPU_LGDT(Bitu limit,Bitu base);
include/cpu.h:Bitu CPU_STR(void);
include/cpu.h:Bitu CPU_SLDT(void);
include/cpu.h:Bitu CPU_SIDT_base(void);
include/cpu.h:Bitu CPU_SIDT_limit(void);
include/cpu.h:Bitu CPU_SGDT_base(void);
include/cpu.h:Bitu CPU_SGDT_limit(void);
include/cpu.h:void CPU_ARPL(Bitu & dest_sel,Bitu src_sel);
include/cpu.h:void CPU_LAR(Bitu selector,Bitu & ar);
include/cpu.h:void CPU_LSL(Bitu selector,Bitu & limit);
include/cpu.h:void CPU_SET_CRX(Bitu cr,Bitu value);
include/cpu.h:bool CPU_WRITE_CRX(Bitu cr,Bitu value);
include/cpu.h:Bitu CPU_GET_CRX(Bitu cr);
include/cpu.h:bool CPU_READ_CRX(Bitu cr,Bit32u & retvalue);
include/cpu.h:bool CPU_WRITE_DRX(Bitu dr,Bitu value);
include/cpu.h:bool CPU_READ_DRX(Bitu dr,Bit32u & retvalue);
include/cpu.h:bool CPU_WRITE_TRX(Bitu dr,Bitu value);
include/cpu.h:bool CPU_READ_TRX(Bitu dr,Bit32u & retvalue);
include/cpu.h:Bitu CPU_SMSW(void);
include/cpu.h:bool CPU_LMSW(Bitu word);
include/cpu.h:void CPU_VERR(Bitu selector);
include/cpu.h:void CPU_VERW(Bitu selector);
include/cpu.h:void CPU_JMP(bool use32,Bitu selector,Bitu offset,Bitu oldeip);
include/cpu.h:void CPU_CALL(bool use32,Bitu selector,Bitu offset,Bitu oldeip);
include/cpu.h:void CPU_RET(bool use32,Bitu bytes,Bitu oldeip);
include/cpu.h:void CPU_IRET(bool use32,Bitu oldeip);
include/cpu.h:void CPU_HLT(Bitu oldeip);
include/cpu.h:bool CPU_POPF(Bitu use32);
include/cpu.h:bool CPU_PUSHF(Bitu use32);
include/cpu.h:bool CPU_IO_Exception(Bitu port,Bitu size);
include/cpu.h:void CPU_ENTER(bool use32,Bitu bytes,Bitu level);
include/cpu.h:void CPU_Interrupt(Bitu num,Bitu type,Bitu oldeip);
include/cpu.h:static INLINE void CPU_HW_Interrupt(Bitu num) {
include/cpu.h:static INLINE void CPU_SW_Interrupt(Bitu num,Bitu oldeip) {
include/cpu.h:static INLINE void CPU_SW_Interrupt_NoIOPLCheck(Bitu num,Bitu oldeip) {
include/cpu.h:bool CPU_PrepareException(Bitu which,Bitu error);
include/cpu.h:void CPU_Exception(Bitu which,Bitu error=0);
include/cpu.h:bool CPU_SetSegGeneral(SegNames seg,Bitu value);
include/cpu.h:Bitu CPU_Pop16(void);
include/cpu.h:Bitu CPU_Pop32(void);
include/cpu.h:void CPU_Push16(Bitu value);
include/cpu.h:void CPU_Push32(Bitu value);
include/cpu.h:void CPU_SetFlags(Bitu word,Bitu mask);
include/cpu.h:	Bitu GetLimit (void) {
include/cpu.h:		Bitu limit = (saved.seg.limit_16_19<<16) | saved.seg.limit_0_15;
include/cpu.h:	Bitu GetOffset(void) {
include/cpu.h:	Bitu GetSelector(void) {
include/cpu.h:	Bitu Type(void) {
include/cpu.h:	Bitu Conforming(void) {
include/cpu.h:	Bitu DPL(void) {
include/cpu.h:	Bitu Big(void) {
include/cpu.h:	Bitu	GetLimit		(void)			{ return table_limit;	}
include/cpu.h:	void	SetLimit		(Bitu _limit)	{ table_limit= _limit;	}
include/cpu.h:	bool GetDescriptor	(Bitu selector, Descriptor& desc) {
include/cpu.h:	Bitu table_limit;
include/cpu.h:	bool GetDescriptor(Bitu selector, Descriptor& desc) {
include/cpu.h:		Bitu address=selector & ~7;
include/cpu.h:	bool SetDescriptor(Bitu selector, Descriptor& desc) {
include/cpu.h:		Bitu address=selector & ~7;
include/cpu.h:	Bitu SLDT(void)	{
include/cpu.h:	bool LLDT(Bitu value)	{
include/cpu.h:	Bitu ldt_limit;
include/cpu.h:	Bitu ldt_value;
include/cpu.h:	Bitu IsBusy(void) {
include/cpu.h:	Bitu Is386(void) {
include/cpu.h:	Bitu cpl;							/* Current Privilege */
include/cpu.h:	Bitu mpl;
include/cpu.h:	Bitu cr0;
include/cpu.h:		Bitu mask,notmask;
include/cpu.h:		Bitu cs,eip;
include/cpu.h:		Bitu which,error;
include/cpu.h:static INLINE void CPU_SetFlagsd(Bitu word) {
include/cpu.h:	Bitu mask=cpu.cpl ? FMASK_NORMAL : FMASK_ALL;
include/cpu.h:static INLINE void CPU_SetFlagsw(Bitu word) {
include/cpu.h:	Bitu mask=(cpu.cpl ? FMASK_NORMAL : FMASK_ALL) & 0xffff;
include/dos_system.h:	void SetDeviceNumber(Bitu num) { devnum=num;}
include/dos_system.h:	Bitu devnum;
include/dos_system.h:		Bitu		nextEntry;
include/dos_system.h:		Bitu		shortNr;
include/dos_system.h:	Bitu		CreateShortNameID	(CFileInfo* dir, const char* name);
include/dos_system.h:	bool		SetResult		(CFileInfo* dir, char * &result, Bitu entryNr);
include/serialport.h:	MyFifo(Bitu maxsize_) {
include/serialport.h:	INLINE Bitu getFree(void) {
include/serialport.h:	INLINE Bitu getUsage(void) {
include/serialport.h:	void setSize(Bitu newsize)
include/serialport.h:		Bitu where=pos+used;
include/serialport.h:		Bitu where=pos;
include/serialport.h:		Bitu where=pos+used;
include/serialport.h:	Bitu maxsize,size,pos,used;
include/serialport.h:	static bool getBituSubstring(const char* name,Bitu* data, CommandLine* cmd);
include/serialport.h:	CSerial(Bitu id, CommandLine* cmd);
include/serialport.h:	Bitu idnumber;
include/serialport.h:	Bitu irq;
include/serialport.h:	Bitu Read_RHR();
include/serialport.h:	Bitu Read_IER();
include/serialport.h:	Bitu Read_ISR();
include/serialport.h:	Bitu Read_LCR();
include/serialport.h:	Bitu Read_MCR();
include/serialport.h:	Bitu Read_LSR();
include/serialport.h:	Bitu Read_MSR();
include/serialport.h:	Bitu Read_SPR();
include/serialport.h:	bool Putchar(Bit8u data, bool wait_dtr, bool wait_rts, Bitu timeout);
include/serialport.h:	bool Getchar(Bit8u* data, Bit8u* lsr, bool wait_dsr, Bitu timeout);
include/serialport.h:	Bitu framingErrors;
include/serialport.h:	Bitu parityErrors;
include/serialport.h:	Bitu overrunErrors;
include/serialport.h:	Bitu txOverrunErrors;
include/serialport.h:	Bitu overrunIF0;
include/serialport.h:	Bitu breakErrors;
include/serialport.h:	Bitu errors_in_fifo;
include/serialport.h:	Bitu rx_interrupt_threshold;
include/serialport.h:	Bitu fifosize;
include/render.h:	Bitu first;
include/render.h:	Bitu last;
include/render.h:		Bitu width, start;
include/render.h:		Bitu height;
include/render.h:		Bitu bpp;
include/render.h:		Bitu count;
include/render.h:		Bitu max;
include/render.h:		Bitu index;
include/render.h:		Bitu size;
include/render.h:		Bitu blocks, lastBlock;
include/render.h:		Bitu outPitch;
include/render.h:		Bitu cachePitch;
include/render.h:		Bitu inHeight, inLine, outLine;
include/render.h:void RENDER_SetSize(Bitu width,Bitu height,Bitu bpp,float fps,double ratio,bool dblw,bool dblh);
include/parport.h:	CParallel(CommandLine* cmd, Bitu portnr, Bit8u initirq);
include/parport.h:	Bitu base;
include/parport.h:	Bitu irq;
include/parport.h:	virtual Bitu Read_PR()=0;
include/parport.h:	virtual Bitu Read_COM()=0;
include/parport.h:	virtual Bitu Read_SR()=0;
include/parport.h:	virtual void Write_PR(Bitu)=0;
include/parport.h:	virtual void Write_CON(Bitu)=0;
include/parport.h:	virtual void Write_IOSEL(Bitu)=0;
include/dosbox.h:typedef Bitu (LoopHandler)(void);
include/regs.h:	Bitu flags;
include/regs.h:static INLINE void SegSet16(Bitu index,Bit16u val) {
include/vga.h:	Bitu mh_mask;
include/vga.h:	Bitu display_start;
include/vga.h:	Bitu real_start;
include/vga.h:	Bitu scan_len;
include/vga.h:	Bitu cursor_start;
include/vga.h:	Bitu line_compare;
include/vga.h:	Bitu width;
include/vga.h:	Bitu height;
include/vga.h:	Bitu blocks;
include/vga.h:	Bitu address;
include/vga.h:	Bitu panning;
include/vga.h:	Bitu bytes_skip;
include/vga.h:	Bitu linear_mask;
include/vga.h:	Bitu address_add;
include/vga.h:	Bitu line_length;
include/vga.h:	Bitu address_line_total;
include/vga.h:	Bitu address_line;
include/vga.h:	Bitu lines_total;
include/vga.h:	Bitu vblank_skip;
include/vga.h:	Bitu lines_done;
include/vga.h:	Bitu lines_scaled;
include/vga.h:	Bitu split_line;
include/vga.h:	Bitu parts_total;
include/vga.h:	Bitu parts_lines;
include/vga.h:	Bitu parts_left;
include/vga.h:	Bitu byte_panning_shift;
include/vga.h:	Bitu bpp;
include/vga.h:	Bitu blinking;
include/vga.h:		Bitu address;
include/vga.h:	Bitu xga_screen_width;
include/vga.h:	Bitu addr_mask;
include/vga.h:	Bitu first_changed;
include/vga.h:	Bitu	readStart, writeStart;
include/vga.h:	Bitu	bankMask;
include/vga.h:	Bitu	bank_read_full;
include/vga.h:	Bitu	bank_write_full;
include/vga.h:	Bitu	bank_size;
include/vga.h:void VGA_StartResize(Bitu delay=50);
include/vga.h:void VGA_SetupDrawing(Bitu val);
include/vga.h:void VGA_DAC_SetEntry(Bitu entry,Bit8u red,Bit8u green,Bit8u blue);
include/vga.h:void VGA_SetClock(Bitu which,Bitu target);
include/vga.h:void VGA_SetBlinking(Bitu enabled);
include/vga.h:	Bitu offset;
include/vga.h:	Bitu modeNo;
include/vga.h:	Bitu htotal;
include/vga.h:	Bitu vtotal;
include/vga.h:typedef void (*tWritePort)(Bitu reg,Bitu val,Bitu iolen);
include/vga.h:typedef Bitu (*tReadPort)(Bitu reg,Bitu iolen);
include/vga.h:typedef void (*tFinishSetMode)(Bitu crtc_base, VGA_ModeExtraData* modeData);
include/vga.h:typedef void (*tSetClock)(Bitu which,Bitu target);
include/vga.h:typedef Bitu (*tGetClock)();
include/vga.h:typedef bool (*tAcceptsMode)(Bitu modeNo);
include/vga.h:Bitu VideoModeMemSize(Bitu mode);
include/shell.h:extern Bitu call_shellstop;
include/shell.h:	Bitu GetRedirection(char *s, char **ifn, char **ofn,bool * append);
config.h:  typedef Bit32u Bitu;
config.h:  typedef Bit64u Bitu;
config.h.in:  typedef Bit32u Bitu;
config.h.in:  typedef Bit64u Bitu;
autom4te.cache/traces.1:  typedef Bit32u Bitu;
autom4te.cache/traces.1:  typedef Bit64u Bitu;
src/platform/visualc/config.h.orig:typedef unsigned int		Bitu;
src/platform/visualc/config.h:typedef unsigned int		Bitu;
src/fpu/fpu_instructions_x86.h:static void FPU_FLD_F32(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions_x86.h:static void FPU_FLD_F64(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions_x86.h:static void FPU_FLD_I16(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions_x86.h:static void FPU_FLD_I32(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions_x86.h:static void FPU_FLD_I64(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions_x86.h:static void FPU_FBLD(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions_x86.h:static void FPU_FADD(Bitu op1, Bitu op2){
src/fpu/fpu_instructions_x86.h:static void FPU_FADD_EA(Bitu op1){
src/fpu/fpu_instructions_x86.h:static void FPU_FDIV(Bitu op1, Bitu op2){
src/fpu/fpu_instructions_x86.h:static void FPU_FDIV_EA(Bitu op1){
src/fpu/fpu_instructions_x86.h:static void FPU_FDIVR(Bitu op1, Bitu op2){
src/fpu/fpu_instructions_x86.h:static void FPU_FDIVR_EA(Bitu op1){
src/fpu/fpu_instructions_x86.h:static void FPU_FMUL(Bitu op1, Bitu op2){
src/fpu/fpu_instructions_x86.h:static void FPU_FMUL_EA(Bitu op1){
src/fpu/fpu_instructions_x86.h:static void FPU_FSUB(Bitu op1, Bitu op2){
src/fpu/fpu_instructions_x86.h:static void FPU_FSUB_EA(Bitu op1){
src/fpu/fpu_instructions_x86.h:static void FPU_FSUBR(Bitu op1, Bitu op2){
src/fpu/fpu_instructions_x86.h:static void FPU_FSUBR_EA(Bitu op1){
src/fpu/fpu_instructions_x86.h:static void FPU_FXCH(Bitu stv, Bitu other){
src/fpu/fpu_instructions_x86.h:static void FPU_FST(Bitu stv, Bitu other){
src/fpu/fpu_instructions_x86.h:static void FPU_FCOM(Bitu op1, Bitu op2){
src/fpu/fpu_instructions_x86.h:static void FPU_FCOM_EA(Bitu op1){
src/fpu/fpu_instructions_x86.h:static void FPU_FUCOM(Bitu op1, Bitu op2){
src/fpu/fpu_instructions_x86.h:	Bitu cw;
src/fpu/fpu_instructions_x86.h:	Bitu start=(cpu.code.big?28:14);
src/fpu/fpu_instructions_x86.h:	for(Bitu i=0;i<8;i++){
src/fpu/fpu_instructions_x86.h:	Bitu start=(cpu.code.big?28:14);
src/fpu/fpu_instructions_x86.h:	for(Bitu i=0;i<8;i++){
Binary file src/fpu/fpu.o matches
Binary file src/fpu/libfpu.a matches
src/fpu/fpu_instructions.h:static void FPU_ST80(PhysPt addr,Bitu reg) {
src/fpu/fpu_instructions.h:static void FPU_FLD_F32(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions.h:static void FPU_FLD_F64(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions.h:static void FPU_FLD_I16(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions.h:static void FPU_FLD_I32(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions.h:static void FPU_FLD_I64(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions.h:static void FPU_FBLD(PhysPt addr,Bitu store_to) {
src/fpu/fpu_instructions.h:	Bitu in = 0;
src/fpu/fpu_instructions.h:	for(Bitu i = 0;i < 9;i++){
src/fpu/fpu_instructions.h:	Bitu p;
src/fpu/fpu_instructions.h:	for(Bitu i=0;i<9;i++){
src/fpu/fpu_instructions.h:		p = static_cast<Bitu>(val.d - 10.0*temp);  
src/fpu/fpu_instructions.h:		p |= (static_cast<Bitu>(val.d - 10.0*temp)<<4);
src/fpu/fpu_instructions.h:	p = static_cast<Bitu>(val.d - 10.0*temp);
src/fpu/fpu_instructions.h:static void FPU_FADD(Bitu op1, Bitu op2){
src/fpu/fpu_instructions.h:static void FPU_FDIV(Bitu st, Bitu other){
src/fpu/fpu_instructions.h:static void FPU_FDIVR(Bitu st, Bitu other){
src/fpu/fpu_instructions.h:static void FPU_FMUL(Bitu st, Bitu other){
src/fpu/fpu_instructions.h:static void FPU_FSUB(Bitu st, Bitu other){
src/fpu/fpu_instructions.h:static void FPU_FSUBR(Bitu st, Bitu other){
src/fpu/fpu_instructions.h:static void FPU_FXCH(Bitu st, Bitu other){
src/fpu/fpu_instructions.h:static void FPU_FST(Bitu st, Bitu other){
src/fpu/fpu_instructions.h:static void FPU_FCOM(Bitu st, Bitu other){
src/fpu/fpu_instructions.h:static void FPU_FUCOM(Bitu st, Bitu other){
src/fpu/fpu_instructions.h:	FPU_SET_C0(static_cast<Bitu>(ressaved&4));
src/fpu/fpu_instructions.h:	FPU_SET_C3(static_cast<Bitu>(ressaved&2));
src/fpu/fpu_instructions.h:	FPU_SET_C1(static_cast<Bitu>(ressaved&1));
src/fpu/fpu_instructions.h:	FPU_SET_C0(static_cast<Bitu>(ressaved&4));
src/fpu/fpu_instructions.h:	FPU_SET_C3(static_cast<Bitu>(ressaved&2));
src/fpu/fpu_instructions.h:	FPU_SET_C1(static_cast<Bitu>(ressaved&1));
src/fpu/fpu_instructions.h:	Bitu cw;
src/fpu/fpu_instructions.h:	Bitu start = (cpu.code.big?28:14);
src/fpu/fpu_instructions.h:	for(Bitu i = 0;i < 8;i++){
src/fpu/fpu_instructions.h:	Bitu start = (cpu.code.big?28:14);
src/fpu/fpu_instructions.h:	for(Bitu i = 0;i < 8;i++){
src/fpu/fpu_instructions.h:static INLINE void FPU_FADD_EA(Bitu op1){
src/fpu/fpu_instructions.h:static INLINE void FPU_FMUL_EA(Bitu op1){
src/fpu/fpu_instructions.h:static INLINE void FPU_FSUB_EA(Bitu op1){
src/fpu/fpu_instructions.h:static INLINE void FPU_FSUBR_EA(Bitu op1){
src/fpu/fpu_instructions.h:static INLINE void FPU_FDIV_EA(Bitu op1){
src/fpu/fpu_instructions.h:static INLINE void FPU_FDIVR_EA(Bitu op1){
src/fpu/fpu_instructions.h:static INLINE void FPU_FCOM_EA(Bitu op1){
src/fpu/fpu.cpp:	for(Bitu i=0;i<8;i++)
src/fpu/fpu.cpp:static void EATREE(Bitu _rm){
src/fpu/fpu.cpp:	Bitu group=(_rm >> 3) & 7;
src/fpu/fpu.cpp:void FPU_ESC0_EA(Bitu rm,PhysPt addr) {
src/fpu/fpu.cpp:void FPU_ESC0_Normal(Bitu rm) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:void FPU_ESC1_EA(Bitu rm,PhysPt addr) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:void FPU_ESC1_Normal(Bitu rm) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:			Bitu reg_from=STV(sub);
src/fpu/fpu.cpp:void FPU_ESC2_EA(Bitu rm,PhysPt addr) {
src/fpu/fpu.cpp:void FPU_ESC2_Normal(Bitu rm) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:void FPU_ESC3_EA(Bitu rm,PhysPt addr) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:void FPU_ESC3_Normal(Bitu rm) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:void FPU_ESC4_EA(Bitu rm,PhysPt addr) {
src/fpu/fpu.cpp:void FPU_ESC4_Normal(Bitu rm) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:void FPU_ESC5_EA(Bitu rm,PhysPt addr) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:void FPU_ESC5_Normal(Bitu rm) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:void FPU_ESC6_EA(Bitu rm,PhysPt addr) {
src/fpu/fpu.cpp:void FPU_ESC6_Normal(Bitu rm) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:void FPU_ESC7_EA(Bitu rm,PhysPt addr) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/fpu/fpu.cpp:void FPU_ESC7_Normal(Bitu rm) {
src/fpu/fpu.cpp:	Bitu group=(rm >> 3) & 7;
src/fpu/fpu.cpp:	Bitu sub=(rm & 7);
src/shell/shell.cpp:Bitu call_shellstop;
src/shell/shell.cpp:static Bitu shellstop_handler(void) {
src/shell/shell.cpp:Bitu DOS_Shell::GetRedirection(char *s, char **ifn, char **ofn,bool * append) {
src/shell/shell.cpp:	Bitu num=0;
src/shell/shell.cpp:	Bitu num = 0;		/* Number of commands in this line */
src/shell/shell.cpp:		Bitu i = 1;
src/shell/shell.cpp:			for(Bitu temp = 0;temp < line.size();++temp) if(line[temp] == '\'') line[temp]='\"';
src/shell/shell.cpp:		Bitu dummy = 1;
src/shell/shell.cpp:static Bitu INT2E_Handler(void) {
src/shell/shell.cpp:	Bitu call_int2e=CALLBACK_Allocate();
src/shell/shell.cpp:	MEM_BlockWrite(env_write,path_string,(Bitu)(strlen(path_string)+1));
src/shell/shell.cpp:	MEM_BlockWrite(env_write,comspec_string,(Bitu)(strlen(comspec_string)+1));
src/shell/shell.cpp:	MEM_BlockWrite(env_write,full_name,(Bitu)(strlen(full_name)+1));
Binary file src/shell/shell_cmds.o matches
Binary file src/shell/shell_batch.o matches
src/shell/shell.cpp.orig:Bitu call_shellstop;
src/shell/shell.cpp.orig:static Bitu shellstop_handler(void) {
src/shell/shell.cpp.orig:Bitu DOS_Shell::GetRedirection(char *s, char **ifn, char **ofn,bool * append) {
src/shell/shell.cpp.orig:	Bitu num=0;
src/shell/shell.cpp.orig:	Bitu num = 0;		/* Number of commands in this line */
src/shell/shell.cpp.orig:		Bitu i = 1;
src/shell/shell.cpp.orig:			for(Bitu temp = 0;temp < line.size();++temp) if(line[temp] == '\'') line[temp]='\"';
src/shell/shell.cpp.orig:		Bitu dummy = 1;
src/shell/shell.cpp.orig:static Bitu INT2E_Handler(void) {
src/shell/shell.cpp.orig:	Bitu call_int2e=CALLBACK_Allocate();
src/shell/shell.cpp.orig:	MEM_BlockWrite(env_write,path_string,(Bitu)(strlen(path_string)+1));
src/shell/shell.cpp.orig:	MEM_BlockWrite(env_write,comspec_string,(Bitu)(strlen(comspec_string)+1));
src/shell/shell.cpp.orig:	MEM_BlockWrite(env_write,full_name,(Bitu)(strlen(full_name)+1));
src/shell/shell_cmds.cpp:	Bitu w_count=0;
src/shell/shell_cmds.cpp:	Bitu p_count=0;
src/shell/shell_cmds.cpp:	Bitu w_size = optW?5:1;
src/shell/shell_cmds.cpp:		Bitu free_space=1024*1024*100;
src/shell/shell_cmds.cpp:		Bitu count=GetEnvCount();
src/shell/shell_cmds.cpp:		for (Bitu a=0;a<count;a++) {
src/shell/shell_cmds.cpp:	Bitu bufferptr=0;
src/shell/shell_cmds.cpp:	for(Bitu i = 0; i < 5; i++) {
Binary file src/shell/shell_misc.o matches
Binary file src/shell/shell.o matches
Binary file src/shell/libshell.a matches
src/shell/shell_misc.cpp:	Bitu size=CMD_MAXLINE-2; //lastcharacter+0
src/shell/shell_misc.cpp:	Bitu str_len=0;Bitu str_index=0;
src/shell/shell_misc.cpp:						str_len = str_index = (Bitu)it_history->length();
src/shell/shell_misc.cpp:						for(Bitu i=str_index;i<str_len-1;i++) {
src/shell/shell_misc.cpp:				for(Bitu i=str_len;i>str_index;i--) {
src/shell/shell_misc.cpp:		MEM_BlockWrite(Real2Phys(file_name),fullname,(Bitu)(strlen(fullname)+1));
src/shell/shell_misc.cpp:	Bitu i_path = 0;
Binary file src/misc/setup.o matches
src/misc/programs.cpp:Bitu call_program;
src/misc/programs.cpp:static Bitu PROGRAMS_Handler(void) {
src/misc/programs.cpp:	Bitu size=sizeof(Bit8u);
src/misc/programs.cpp:bool Program::GetEnvNum(Bitu num,std::string & result) {
src/misc/programs.cpp:Bitu Program::GetEnvCount(void) {
src/misc/programs.cpp:	Bitu num=0;
src/misc/programs.cpp:		MEM_BlockWrite(env_write,env_string,(Bitu)(strlen(env_string)+1));
src/misc/programs.cpp:		MEM_BlockWrite(env_write,env_string,(Bitu)(strlen(env_string)+1));
src/misc/programs.cpp:			Bitu size = control->configfiles.size();
src/misc/programs.cpp:					for(Bitu i = 1; i < size; i++)
src/misc/programs.cpp:					Bitu i = 0;
src/misc/programs.cpp:						for(Bitu k = 0; k < pv.size(); k++) {
src/misc/programs.cpp:			for(Bitu i = 0; i < pvars.size(); i++) sec->HandleInputline(pvars[i]);
src/misc/programs.cpp:					Bitu i = 0;
src/misc/programs.cpp:			for(Bitu i = 3; i < pvars.size(); i++) value += (std::string(" ") + pvars[i]);
Binary file src/misc/programs.o matches
src/misc/support.cpp:	bool negative=false;Bitu ret=0;
src/misc/support.cpp:	Bitu ret=0;
src/misc/setup.cpp:	Bitu i = 1;
src/misc/setup.cpp:	for(Bitu i = 0; i < vector.size(); i++) {
src/misc/setup.cpp:		for(Bitu i = 0; *params[i]!=0; i++) {
Binary file src/misc/libmisc.a matches
Binary file src/misc/support.o matches
Binary file src/hardware/memory.o matches
src/hardware/vga_memory.cpp:static INLINE void hostWrite(HostPt off, Bitu val) {
src/hardware/vga_memory.cpp:static INLINE Bitu  hostRead(HostPt off ) {
src/hardware/vga_memory.cpp:	Bitu base, mask;
src/hardware/vga_memory.cpp:	Bitu readHandler(PhysPt start) {
src/hardware/vga_memory.cpp:	Bitu readb(PhysPt addr) {
src/hardware/vga_memory.cpp:	Bitu readw(PhysPt addr) {
src/hardware/vga_memory.cpp:		Bitu ret = (readHandler(addr+0) << 0);
src/hardware/vga_memory.cpp:	Bitu readd(PhysPt addr) {
src/hardware/vga_memory.cpp:		Bitu ret = (readHandler(addr+0) << 0);
src/hardware/vga_memory.cpp:	Bitu readHandler(PhysPt addr) {
src/hardware/vga_memory.cpp:	void writeb(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writew(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writed(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	Bitu readb(PhysPt addr) {
src/hardware/vga_memory.cpp:	Bitu readw(PhysPt addr) {
src/hardware/vga_memory.cpp:		Bitu ret = (readHandler(addr+0) << 0);
src/hardware/vga_memory.cpp:	Bitu readd(PhysPt addr) {
src/hardware/vga_memory.cpp:		Bitu ret = (readHandler(addr+0) << 0);
src/hardware/vga_memory.cpp:	void writeb(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writew(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writed(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	static INLINE Bitu readHandler(PhysPt addr ) {
src/hardware/vga_memory.cpp:	static INLINE void writeCache(PhysPt addr, Bitu val) {
src/hardware/vga_memory.cpp:	static INLINE void writeHandler(PhysPt addr, Bitu val) {
src/hardware/vga_memory.cpp:	Bitu readb(PhysPt addr ) {
src/hardware/vga_memory.cpp:	Bitu readw(PhysPt addr ) {
src/hardware/vga_memory.cpp:			Bitu ret = (readHandler<Bit8u>( addr+0 ) << 0 );
src/hardware/vga_memory.cpp:	Bitu readd(PhysPt addr ) {
src/hardware/vga_memory.cpp:			Bitu ret = (readHandler<Bit8u>( addr+0 ) << 0 );
src/hardware/vga_memory.cpp:	void writeb(PhysPt addr, Bitu val ) {
src/hardware/vga_memory.cpp:	void writew(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writed(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writeb(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writew(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writed(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	Bitu readb(PhysPt addr) {
src/hardware/vga_memory.cpp:	void writeb(PhysPt addr,Bitu val){
src/hardware/vga_memory.cpp:	HostPt GetHostReadPt(Bitu phys_page) {
src/hardware/vga_memory.cpp:	HostPt GetHostWritePt(Bitu phys_page) {
src/hardware/vga_memory.cpp:	Bitu readb(PhysPt addr) {
src/hardware/vga_memory.cpp:	Bitu readw(PhysPt addr) {
src/hardware/vga_memory.cpp:	Bitu readd(PhysPt addr) {
src/hardware/vga_memory.cpp:	void writeb(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writew(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writed(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writeb(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writew(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writed(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	Bitu readb(PhysPt addr) {
src/hardware/vga_memory.cpp:	Bitu readw(PhysPt addr) {
src/hardware/vga_memory.cpp:		Bitu ret = (readHandler(addr+0) << 0);
src/hardware/vga_memory.cpp:	Bitu readd(PhysPt addr) {
src/hardware/vga_memory.cpp:		Bitu ret = (readHandler(addr+0) << 0);
src/hardware/vga_memory.cpp:	Bitu readb(PhysPt addr) {
src/hardware/vga_memory.cpp:	Bitu readw(PhysPt addr) {
src/hardware/vga_memory.cpp:	Bitu readd(PhysPt addr) {
src/hardware/vga_memory.cpp:	void writeb(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writew(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	void writed(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:	HostPt GetHostReadPt( Bitu phys_page ) {
src/hardware/vga_memory.cpp:	HostPt GetHostWritePt( Bitu phys_page ) {
src/hardware/vga_memory.cpp:extern void XGA_Write(Bitu port, Bitu val, Bitu len);
src/hardware/vga_memory.cpp:extern Bitu XGA_Read(Bitu port, Bitu len);
src/hardware/vga_memory.cpp:	void writeb(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:		Bitu port = PAGING_GetPhysicalAddress(addr) & 0xffff;
src/hardware/vga_memory.cpp:	void writew(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:		Bitu port = PAGING_GetPhysicalAddress(addr) & 0xffff;
src/hardware/vga_memory.cpp:	void writed(PhysPt addr,Bitu val) {
src/hardware/vga_memory.cpp:		Bitu port = PAGING_GetPhysicalAddress(addr) & 0xffff;
src/hardware/vga_memory.cpp:	Bitu readb(PhysPt addr) {
src/hardware/vga_memory.cpp:		Bitu port = PAGING_GetPhysicalAddress(addr) & 0xffff;
src/hardware/vga_memory.cpp:	Bitu readw(PhysPt addr) {
src/hardware/vga_memory.cpp:		Bitu port = PAGING_GetPhysicalAddress(addr) & 0xffff;
src/hardware/vga_memory.cpp:	Bitu readd(PhysPt addr) {
src/hardware/vga_memory.cpp:		Bitu port = PAGING_GetPhysicalAddress(addr) & 0xffff;
src/hardware/vga_memory.cpp:	HostPt GetHostReadPt(Bitu phys_page) {
src/hardware/vga_memory.cpp:	HostPt GetHostWritePt(Bitu phys_page) {
src/hardware/vga_memory.cpp:	HostPt GetHostReadPt(Bitu phys_page) {
src/hardware/vga_memory.cpp:	HostPt GetHostWritePt(Bitu phys_page) {
src/hardware/vga_memory.cpp:	HostPt GetHostReadPt(Bitu phys_page) {
src/hardware/vga_memory.cpp:	HostPt GetHostWritePt(Bitu phys_page) {
src/hardware/vga_memory.cpp:	Bitu readb(PhysPt /*addr*/) {
src/hardware/vga_memory.cpp:	void writeb(PhysPt /*addr*/,Bitu /*val*/) {
src/hardware/vga_memory.cpp:	vga.mem.linear=(Bit8u*)(((Bitu)vga.mem.linear_orgptr + 16-1) & ~(16-1));
src/hardware/vga_memory.cpp:	vga.fastmem=(Bit8u*)(((Bitu)vga.fastmem_orgptr + 16-1) & ~(16-1));
src/hardware/adlib.cpp:		virtual void Generate( MixerChannel* chan, Bitu samples ) {
src/hardware/adlib.cpp:				Bitu todo = samples > 1024 ? 1024 : samples;
src/hardware/adlib.cpp:		virtual void Init( Bitu rate ) {
src/hardware/adlib.cpp:		virtual void Generate( MixerChannel* chan, Bitu samples ) {
src/hardware/adlib.cpp:				Bitu todo = samples > 1024 ? 1024 : samples;
src/hardware/adlib.cpp:		virtual void Init( Bitu rate ) {
src/hardware/adlib.cpp:		Bitu i, val;
src/hardware/adlib.cpp:			Bitu passed = PIC_Ticks - lastTicks;
src/hardware/adlib.cpp:					Bitu shift = (passed >> 8);
src/hardware/adlib.cpp:Bitu Module::CtrlRead( void ) {
src/hardware/adlib.cpp:void Module::PortWrite( Bitu port, Bitu val, Bitu iolen ) {
src/hardware/adlib.cpp:Bitu Module::PortRead( Bitu port, Bitu iolen ) {
src/hardware/adlib.cpp:static void OPL_CallBack(Bitu len) {
src/hardware/adlib.cpp:		Bitu i;
src/hardware/adlib.cpp:static Bitu OPL_Read(Bitu port,Bitu iolen) {
src/hardware/adlib.cpp:void OPL_Write(Bitu port,Bitu val,Bitu iolen) {
src/hardware/adlib.cpp:		Bitu offset = ((i % 9) / 3) * 8 + (i % 3);
src/hardware/adlib.cpp:	Bitu base = section->Get_hex("sbbase");
src/hardware/adlib.cpp:	Bitu rate = section->Get_int("oplrate");
Binary file src/hardware/serialport/serialdummy.o matches
src/hardware/serialport/misc_util.h:	bool SendArray(Bit8u* data, Bitu bufsize);
src/hardware/serialport/misc_util.h:	bool ReceiveArray(Bit8u* data, Bitu* size);
src/hardware/serialport/misc_util.h:	void SetSendBufferSize(Bitu bufsize);
src/hardware/serialport/misc_util.h:	bool SendArrayBuffered(Bit8u* data, Bitu bufsize);
src/hardware/serialport/misc_util.h:	Bitu sendbuffersize;
src/hardware/serialport/misc_util.h:	Bitu sendbufferindex;
src/hardware/serialport/directserial.cpp:CDirectSerial::CDirectSerial (Bitu id, CommandLine* cmd)
src/hardware/serialport/directserial.cpp:	if(getBituSubstring("rxdelay:", &rx_retry_max, cmd)) {
src/hardware/serialport/directserial.cpp:	Bitu baudrate;
src/hardware/serialport/serialdummy.cpp:CSerialDummy::CSerialDummy(Bitu id,	CommandLine* cmd):CSerial(id, cmd) {
src/hardware/serialport/misc_util.cpp:bool TCPClientSocket::ReceiveArray(Bit8u* data, Bitu* size) {
src/hardware/serialport/misc_util.cpp:		Bitu retval =0;
src/hardware/serialport/misc_util.cpp:bool TCPClientSocket::SendArray(Bit8u* data, Bitu bufsize) {
src/hardware/serialport/misc_util.cpp:bool TCPClientSocket::SendArrayBuffered(Bit8u* data, Bitu bufsize) {
src/hardware/serialport/misc_util.cpp:	Bitu bytes
src/hardware/serialport/misc_util.cpp:void TCPClientSocket::SetSendBufferSize(Bitu bufsize) {
Binary file src/hardware/serialport/directserial.o matches
src/hardware/serialport/serialdummy.h:	CSerialDummy(Bitu id, CommandLine* cmd);
src/hardware/serialport/serialport.cpp:static Bitu SERIAL_Read (Bitu port, Bitu iolen) {
src/hardware/serialport/serialport.cpp:	Bitu i;
src/hardware/serialport/serialport.cpp:	Bitu retval;
src/hardware/serialport/serialport.cpp:	Bitu index = port & 0x7;
src/hardware/serialport/serialport.cpp:static void SERIAL_Write (Bitu port, Bitu val, Bitu) {
src/hardware/serialport/serialport.cpp:	Bitu i;
src/hardware/serialport/serialport.cpp:	Bitu index = port & 0x7;
src/hardware/serialport/serialport.cpp:			Bitu debugindex=index;
src/hardware/serialport/serialport.cpp:		Bitu len=strlen(buf);
src/hardware/serialport/serialport.cpp:static void Serial_EventHandler(Bitu val) {
src/hardware/serialport/serialport.cpp:	Bitu serclassid=val&0x3;
src/hardware/serialport/serialport.cpp:	Bitu val = IER & waiting_interrupts;
src/hardware/serialport/serialport.cpp:Bitu CSerial::Read_RHR () {
src/hardware/serialport/serialport.cpp:Bitu CSerial::Read_IER () {
src/hardware/serialport/serialport.cpp:Bitu CSerial::Read_ISR () {
src/hardware/serialport/serialport.cpp:Bitu CSerial::Read_LCR () {
src/hardware/serialport/serialport.cpp:Bitu CSerial::Read_MCR () {
src/hardware/serialport/serialport.cpp:Bitu CSerial::Read_LSR () {
src/hardware/serialport/serialport.cpp:	Bitu retval = LSR & (LSR_ERROR_MASK|LSR_TX_EMPTY_MASK);
src/hardware/serialport/serialport.cpp:Bitu CSerial::Read_MSR () {
src/hardware/serialport/serialport.cpp:Bitu CSerial::Read_SPR () {
src/hardware/serialport/serialport.cpp:CSerial::CSerial(Bitu id, CommandLine* cmd) {
src/hardware/serialport/serialport.cpp:	getBituSubstring("irq:",&irq, cmd);
src/hardware/serialport/serialport.cpp:	for (Bitu i = 0; i <= 7; i++) {
src/hardware/serialport/serialport.cpp:bool CSerial::getBituSubstring(const char* name,Bitu* data, CommandLine* cmd) {
src/hardware/serialport/serialport.cpp:	for(Bitu i = 0; i <= SERIAL_BASE_EVENT_COUNT; i++)
src/hardware/serialport/serialport.cpp:bool CSerial::Getchar(Bit8u* data, Bit8u* lsr, bool wait_dsr, Bitu timeout) {
src/hardware/serialport/serialport.cpp:bool CSerial::Putchar(Bit8u data, bool wait_dsr, bool wait_cts, Bitu timeout) {
src/hardware/serialport/serialport.cpp:		for(Bitu i = 0; i < 4; i++) {
src/hardware/serialport/serialport.cpp:		for (Bitu i = 0; i < 4; i++)
src/hardware/serialport/directserial.h:	CDirectSerial(Bitu id, CommandLine* cmd);
src/hardware/serialport/directserial.h:	Bitu rx_state;
src/hardware/serialport/directserial.h:	Bitu rx_retry;		// counter of retries (every millisecond)
src/hardware/serialport/directserial.h:	Bitu rx_retry_max;	// how many POLL_EVENTS to wait before causing
src/hardware/serialport/nullmodem.cpp:CNullModem::CNullModem(Bitu id, CommandLine* cmd):CSerial (id, cmd) {
src/hardware/serialport/nullmodem.cpp:	Bitu temptcpport=23;
src/hardware/serialport/nullmodem.cpp:	Bitu bool_temp=0;
src/hardware/serialport/nullmodem.cpp:	if (getBituSubstring("usedtr:", &bool_temp, cmd)) {
src/hardware/serialport/nullmodem.cpp:	if (getBituSubstring("transparent:", &bool_temp, cmd)) {
src/hardware/serialport/nullmodem.cpp:	if (getBituSubstring("telnet:", &bool_temp, cmd)) {
src/hardware/serialport/nullmodem.cpp:	if (getBituSubstring("rxdelay:", &rx_retry_max, cmd)) {
src/hardware/serialport/nullmodem.cpp:	if (getBituSubstring("txdelay:", &tx_gather, cmd)) {
src/hardware/serialport/nullmodem.cpp:	if (getBituSubstring("port:", &temptcpport, cmd)) {
src/hardware/serialport/nullmodem.cpp:	if (getBituSubstring("inhsocket:", &bool_temp, cmd)) {
Binary file src/hardware/serialport/serialport.o matches
src/hardware/serialport/softmodem.cpp:CSerialModem::CSerialModem(Bitu id, CommandLine* cmd):CSerial(id, cmd) {
src/hardware/serialport/softmodem.cpp:	getBituSubstring("listenport:", &listenport, cmd);
src/hardware/serialport/softmodem.cpp:	for(Bitu i = SERIAL_BASE_EVENT_COUNT+1;	i <= SERIAL_MODEM_EVENT_COUNT; i++)
src/hardware/serialport/softmodem.cpp:void CSerialModem::SendNumber(Bitu val) {
src/hardware/serialport/softmodem.cpp:	char const * string;Bitu code;
src/hardware/serialport/softmodem.cpp:Bitu CSerialModem::ScanNumber(char * & scan) {
src/hardware/serialport/softmodem.cpp:	Bitu ret=0;
src/hardware/serialport/softmodem.cpp:			Bitu val = ScanNumber(scanbuf);	
src/hardware/serialport/softmodem.cpp:			Bitu index=ScanNumber(scanbuf);
src/hardware/serialport/softmodem.cpp:				Bitu val = ScanNumber(scanbuf);
src/hardware/serialport/softmodem.cpp:					Bitu val = ScanNumber(scanbuf);
src/hardware/serialport/softmodem.cpp:void CSerialModem::TelnetEmulation(Bit8u * data, Bitu size) {
src/hardware/serialport/softmodem.cpp:	Bitu i;
src/hardware/serialport/softmodem.cpp:	Bitu usesize;
src/hardware/serialport/softmodem.cpp:	Bitu txbuffersize =0;
Binary file src/hardware/serialport/libserial.a matches
src/hardware/serialport/softmodem.h:	CFifo(Bitu _size) {
src/hardware/serialport/softmodem.h:	INLINE Bitu left(void) {
src/hardware/serialport/softmodem.h:	INLINE Bitu inuse(void) {
src/hardware/serialport/softmodem.h:		Bitu where=pos+used;
src/hardware/serialport/softmodem.h:	void adds(Bit8u * _str,Bitu _len) {
src/hardware/serialport/softmodem.h:		Bitu where=pos+used;
src/hardware/serialport/softmodem.h:			Bitu where=pos;
src/hardware/serialport/softmodem.h:	void gets(Bit8u * _str,Bitu _len) {
src/hardware/serialport/softmodem.h:	Bitu size,pos,used;
src/hardware/serialport/softmodem.h:	CSerialModem(Bitu id, CommandLine* cmd);
src/hardware/serialport/softmodem.h:	void SendNumber(Bitu val);
src/hardware/serialport/softmodem.h:	Bitu ScanNumber(char * & scan);
src/hardware/serialport/softmodem.h:	void MC_Changed(Bitu new_mc);
src/hardware/serialport/softmodem.h:	void TelnetEmulation(Bit8u * data, Bitu size);
src/hardware/serialport/softmodem.h:	Bitu doresponse;
src/hardware/serialport/softmodem.h:	Bitu cmdpause;
src/hardware/serialport/softmodem.h:	Bitu plusinc;
src/hardware/serialport/softmodem.h:	Bitu cmdpos;
src/hardware/serialport/softmodem.h:	Bitu flowcontrol;
src/hardware/serialport/softmodem.h:	Bitu listenport;
src/hardware/serialport/softmodem.h:		Bitu len,pos;
src/hardware/serialport/nullmodem.h:	CNullModem(Bitu id, CommandLine* cmd);
src/hardware/serialport/nullmodem.h:	Bitu rx_state;
src/hardware/serialport/nullmodem.h:	Bitu rx_retry;		// counter of retries
src/hardware/serialport/nullmodem.h:	Bitu rx_retry_max;	// how many POLL_EVENTS to wait before causing
src/hardware/serialport/nullmodem.h:	Bitu tx_gather;		// how long to gather tx data before
Binary file src/hardware/vga_memory.o matches
src/hardware/disney.cpp:	Bitu used;					// current data buffer level
src/hardware/disney.cpp:	Bitu last_used;
src/hardware/disney.cpp:	Bitu state;
src/hardware/disney.cpp:	Bitu interface_det;
src/hardware/disney.cpp:	Bitu interface_det_ext;
src/hardware/disney.cpp:static void DISNEY_CallBack(Bitu len);
src/hardware/disney.cpp:static void DISNEY_disable(Bitu) {
src/hardware/disney.cpp:static void DISNEY_enable(Bitu freq) {
src/hardware/disney.cpp:static void DISNEY_analyze(Bitu channel){
src/hardware/disney.cpp:			Bitu ch_speed[2];
src/hardware/disney.cpp:			for(Bitu i = 0; i < 2; i++) {
src/hardware/disney.cpp:				ch_speed[i] = (Bitu)(1.0/((disney.da[i].speedcheck_sum/1000.0) /
src/hardware/disney.cpp:static void disney_write(Bitu port,Bitu val,Bitu iolen) {
src/hardware/disney.cpp:static Bitu disney_read(Bitu port,Bitu iolen) {
src/hardware/disney.cpp:	Bitu retval;
src/hardware/disney.cpp:static void DISNEY_PlayStereo(Bitu len, Bit8u* l, Bit8u* r) {
src/hardware/disney.cpp:	for(Bitu i = 0; i < len; i++) {
src/hardware/disney.cpp:static void DISNEY_CallBack(Bitu len) {
src/hardware/disney.cpp:	Bitu real_used;
Binary file src/hardware/keyboard.o matches
Binary file src/hardware/hardware.o matches
Binary file src/hardware/dbopl.o matches
src/hardware/opl.cpp:	Bit32u snare_phase_bit = (((Bitu)((op_pt1->tcount/FIXEDPT) / 0x100))&1);
src/hardware/opl.cpp:void change_attackrate(Bitu regbase, op_type* op_pt) {
src/hardware/opl.cpp:void change_decayrate(Bitu regbase, op_type* op_pt) {
src/hardware/opl.cpp:void change_releaserate(Bitu regbase, op_type* op_pt) {
src/hardware/opl.cpp:void change_sustainlevel(Bitu regbase, op_type* op_pt) {
src/hardware/opl.cpp:void change_waveform(Bitu regbase, op_type* op_pt) {
src/hardware/opl.cpp:void change_keepsustain(Bitu regbase, op_type* op_pt) {
src/hardware/opl.cpp:void change_vibrato(Bitu regbase, op_type* op_pt) {
src/hardware/opl.cpp:void change_feedback(Bitu chanbase, op_type* op_pt) {
src/hardware/opl.cpp:void change_frequency(Bitu chanbase, Bitu regbase, op_type* op_pt) {
src/hardware/opl.cpp:void enable_operator(Bitu regbase, op_type* op_pt, Bit32u act_type) {
src/hardware/opl.cpp:	static Bitu initfirstime = 0;
src/hardware/opl.cpp:void adlib_write(Bitu idx, Bit8u val) {
src/hardware/opl.cpp:		Bitu base = (idx-ARC_TVS_KSR_MUL)&0xff;
src/hardware/opl.cpp:			Bitu modop = regbase2modop[second_set?(base+22):base];
src/hardware/opl.cpp:			Bitu regbase = base+second_set;
src/hardware/opl.cpp:			Bitu chanbase = second_set?(modop-18+ARC_SECONDSET):modop;
src/hardware/opl.cpp:		Bitu base = (idx-ARC_KSL_OUTLEV)&0xff;
src/hardware/opl.cpp:			Bitu modop = regbase2modop[second_set?(base+22):base];
src/hardware/opl.cpp:			Bitu chanbase = second_set?(modop-18+ARC_SECONDSET):modop;
src/hardware/opl.cpp:			Bitu regbase = base+second_set;
src/hardware/opl.cpp:		Bitu base = (idx-ARC_ATTR_DECR)&0xff;
src/hardware/opl.cpp:			Bitu regbase = base+second_set;
src/hardware/opl.cpp:		Bitu base = (idx-ARC_SUSL_RELR)&0xff;
src/hardware/opl.cpp:			Bitu regbase = base+second_set;
src/hardware/opl.cpp:		Bitu base = (idx-ARC_FREQ_NUM)&0xff;
src/hardware/opl.cpp:			Bitu chanbase = base+second_set;
src/hardware/opl.cpp:		Bitu base = (idx-ARC_KON_BNUM)&0xff;
src/hardware/opl.cpp:			Bitu chanbase = base+second_set;
src/hardware/opl.cpp:		Bitu base = (idx-ARC_FEEDBACK)&0xff;
src/hardware/opl.cpp:			Bitu chanbase = base+second_set;
src/hardware/opl.cpp:		Bitu base = (idx-ARC_WAVE_SEL)&0xff;
src/hardware/opl.cpp:Bitu adlib_reg_read(Bitu port) {
src/hardware/opl.cpp:void adlib_write_index(Bitu port, Bit8u val) {
src/hardware/opl.cpp:		Bitu max_channel = NUM_CHANNELS;
src/hardware/opl.cpp:			Bitu k = cur_ch;
src/hardware/gus.cpp:	Bitu portbase;
src/hardware/gus.cpp:Bitu DEBUG_EnableDebugger(void);
src/hardware/gus.cpp:	Bitu totalmask=(myGUS.RampIRQ|myGUS.WaveIRQ) & myGUS.ActiveMask;
src/hardware/gus.cpp:static void GUS_TimerEvent(Bitu val) {
src/hardware/gus.cpp:static Bitu read_gus(Bitu port,Bitu iolen) {
src/hardware/gus.cpp:static void write_gus(Bitu port,Bitu val,Bitu iolen) {
src/hardware/gus.cpp:	Bitu dmaaddr = myGUS.dmaAddr << 4;
src/hardware/gus.cpp:		Bitu read=chan->Read(chan->currcnt+1,&GUSRam[dmaaddr]);
src/hardware/gus.cpp:			Bitu i;
src/hardware/gus.cpp:static void GUS_CallBack(Bitu len) {
src/hardware/gus.cpp:	Bitu i;
src/hardware/gus.cpp:		     << dec << (Bitu)myGUS.dma1 << "," << (Bitu)myGUS.dma2 << ","
src/hardware/gus.cpp:		     << (Bitu)myGUS.irq1 << "," << (Bitu)myGUS.irq2 << ends;
src/hardware/gus.cpp:		for(Bitu i=0;i<32;i++) {
Binary file src/hardware/gameblaster.o matches
Binary file src/hardware/vga.o matches
src/hardware/vga.cpp:void VGA_StartResize(Bitu delay /*=50*/) {
src/hardware/vga.cpp:void VGA_SetClock(Bitu which,Bitu target) {
src/hardware/vga.cpp:		Bitu n,m;
src/hardware/vga.cpp:	Bitu n,r;
src/hardware/vga.cpp:		Bitu f_vco = target * (1 << r);
src/hardware/vga.cpp:			Bitu temp_target = S3_CLOCK(m,n,r);
src/hardware/vga.cpp:	for (Bitu i=0;i<16;i++) {
src/hardware/vga.cpp:	for (Bitu i=0;i<256;i++) {
src/hardware/vga.cpp:	Bitu i,j;
Binary file src/hardware/joystick.o matches
Binary file src/hardware/vga_attr.o matches
Binary file src/hardware/tandy_sound.o matches
Binary file src/hardware/vga_other.o matches
Binary file src/hardware/parport/libparallel.a matches
Binary file src/hardware/parport/printer.o matches
src/hardware/parport/printer.cpp:#define PIXX ((Bitu)floor(curX*dpi+0.5))
src/hardware/parport/printer.cpp:#define PIXY ((Bitu)floor(curY*dpi+0.5))
src/hardware/parport/printer.cpp:static Bitu printer_timout;
src/hardware/parport/printer.cpp:						(Bitu)(defaultPageWidth*dpi), 
src/hardware/parport/printer.cpp:						(Bitu)(defaultPageHeight*dpi), 
src/hardware/parport/printer.cpp:		for (Bitu i=0; i<32; i++)
src/hardware/parport/printer.cpp:		for (Bitu i=0;i<32;i++)
src/hardware/parport/printer.cpp:				//	(Bitu)definedUnit,PARAM16(2),PARAM16(4),topMargin,bottomMargin,
src/hardware/parport/printer.cpp:static void PRINTER_EventHandler(Bitu param);
src/hardware/parport/printer.cpp:	for (Bitu y=0; y<bitmap.rows; y++) {
src/hardware/parport/printer.cpp:		for (Bitu x=0; x<bitmap.width; x++) {
src/hardware/parport/printer.cpp:void CPrinter::drawLine(Bitu fromx, Bitu tox, Bitu y, bool broken)
src/hardware/parport/printer.cpp:	Bitu breakmod = dpi / 15;
src/hardware/parport/printer.cpp:	Bitu gapstart = (breakmod * 4)/5;
src/hardware/parport/printer.cpp:	for (Bitu x=fromx; x<=tox; x++)
src/hardware/parport/printer.cpp:	Bitu pixsizeX=1; 
src/hardware/parport/printer.cpp:	Bitu pixsizeY=1;
src/hardware/parport/printer.cpp://	Bitu pixsizeX = dpi/bitGraph.horizDens > 0? dpi/bitGraph.horizDens : 1;
src/hardware/parport/printer.cpp://	Bitu pixsizeY = dpi/bitGraph.vertDens > 0? dpi/bitGraph.vertDens : 1;
src/hardware/parport/printer.cpp:	for (Bitu i=0; i<bitGraph.bytesColumn; i++) // for each byte
src/hardware/parport/printer.cpp:		for (Bitu j=128; j!=0; j>>=1) { // for each bit
src/hardware/parport/printer.cpp:				for (Bitu xx=0; xx<pixsizeX; xx++)
src/hardware/parport/printer.cpp:					for (Bitu yy=0; yy<pixsizeY; yy++) {
src/hardware/parport/printer.cpp:	Bitu i = 1;
src/hardware/parport/printer.cpp:	Bitu slen = strlen(document_path);
src/hardware/parport/printer.cpp:		Bitu i;
src/hardware/parport/printer.cpp:Bitu PRINTER_readdata(Bitu port,Bitu iolen) {
src/hardware/parport/printer.cpp:void PRINTER_writedata(Bitu port,Bitu val,Bitu iolen) {
src/hardware/parport/printer.cpp:Bitu PRINTER_readstatus(Bitu port,Bitu iolen) {
src/hardware/parport/printer.cpp:static void PRINTER_EventHandler(Bitu param) {
src/hardware/parport/printer.cpp:void PRINTER_writecontrol(Bitu port,Bitu val, Bitu iolen)
src/hardware/parport/printer.cpp:Bitu PRINTER_readcontrol(Bitu port,Bitu iolen)
Binary file src/hardware/parport/directlpt_linux.o matches
src/hardware/parport/directlpt_win32.cpp:CDirectLPT::CDirectLPT (Bitu nr, Bit8u initIrq, CommandLine* cmd)
src/hardware/parport/directlpt_win32.cpp:	Bitu timeout = 10000;
src/hardware/parport/directlpt_win32.cpp:	Bitu time = timeout+SDL_GetTicks();
src/hardware/parport/directlpt_win32.cpp:	Bitu z = 0;
src/hardware/parport/directlpt_win32.cpp:Bitu CDirectLPT::Read_PR()
src/hardware/parport/directlpt_win32.cpp:Bitu CDirectLPT::Read_COM()
src/hardware/parport/directlpt_win32.cpp:Bitu CDirectLPT::Read_SR()
src/hardware/parport/directlpt_win32.cpp:void CDirectLPT::Write_PR(Bitu val)
src/hardware/parport/directlpt_win32.cpp:void CDirectLPT::Write_CON(Bitu val)
src/hardware/parport/directlpt_win32.cpp:void CDirectLPT::Write_IOSEL(Bitu val)
src/hardware/parport/printer_if.h:Bitu PRINTER_readdata(Bitu port,Bitu iolen);
src/hardware/parport/printer_if.h:void PRINTER_writedata(Bitu port,Bitu val,Bitu iolen);
src/hardware/parport/printer_if.h:Bitu PRINTER_readstatus(Bitu port,Bitu iolen);
src/hardware/parport/printer_if.h:void PRINTER_writecontrol(Bitu port,Bitu val, Bitu iolen);
src/hardware/parport/printer_if.h:Bitu PRINTER_readcontrol(Bitu port,Bitu iolen);
src/hardware/parport/directlpt_win32.h:			Bitu nr,
src/hardware/parport/directlpt_win32.h:	Bitu Read_PR();
src/hardware/parport/directlpt_win32.h:	Bitu Read_COM();
src/hardware/parport/directlpt_win32.h:	Bitu Read_SR();
src/hardware/parport/directlpt_win32.h:	void Write_PR(Bitu);
src/hardware/parport/directlpt_win32.h:	void Write_CON(Bitu);
src/hardware/parport/directlpt_win32.h:	void Write_IOSEL(Bitu);
src/hardware/parport/parport.cpp:static Bitu PARALLEL_Read (Bitu port, Bitu iolen) {
src/hardware/parport/parport.cpp:	for(Bitu i = 0; i < 3; i++) {
src/hardware/parport/parport.cpp:			Bitu retval=0xff;
src/hardware/parport/parport.cpp:static void PARALLEL_Write (Bitu port, Bitu val, Bitu) {
src/hardware/parport/parport.cpp:	for(Bitu i = 0; i < 4; i++) {
src/hardware/parport/parport.cpp:		Bitu len=strlen(buf);
src/hardware/parport/parport.cpp:CParallel::CParallel(CommandLine* cmd, Bitu portnr, Bit8u initirq) {
src/hardware/parport/parport.cpp:	for (Bitu i = 0; i < 3; i++) {
src/hardware/parport/parport.cpp:void RunIdleTime(Bitu milliseconds)
src/hardware/parport/parport.cpp:	Bitu time=SDL_GetTicks()+milliseconds;
src/hardware/parport/parport.cpp:		for (Bitu i = 0; i < 3; i++) {
src/hardware/parport/parport.cpp:		for (Bitu i = 0; i < 3; i++)
src/hardware/parport/directlpt_linux.h:	CDirectLPT(Bitu nr, Bit8u initIrq, CommandLine* cmd);
src/hardware/parport/directlpt_linux.h:	Bitu Read_PR();
src/hardware/parport/directlpt_linux.h:	Bitu Read_COM();
src/hardware/parport/directlpt_linux.h:	Bitu Read_SR();
src/hardware/parport/directlpt_linux.h:	void Write_PR(Bitu);
src/hardware/parport/directlpt_linux.h:	void Write_CON(Bitu);
src/hardware/parport/directlpt_linux.h:	void Write_IOSEL(Bitu);
src/hardware/parport/printer_redir.cpp:CPrinterRedir::CPrinterRedir(Bitu nr, Bit8u initIrq, CommandLine* cmd)
src/hardware/parport/printer_redir.cpp:Bitu CPrinterRedir::Read_PR() {
src/hardware/parport/printer_redir.cpp:Bitu CPrinterRedir::Read_COM() {
src/hardware/parport/printer_redir.cpp:Bitu CPrinterRedir::Read_SR() {
src/hardware/parport/printer_redir.cpp:void CPrinterRedir::Write_PR(Bitu val) {
src/hardware/parport/printer_redir.cpp:void CPrinterRedir::Write_CON(Bitu val) {
src/hardware/parport/printer_redir.cpp:void CPrinterRedir::Write_IOSEL(Bitu val) {
src/hardware/parport/printer_redir.h:	CPrinterRedir(Bitu nr, Bit8u initIrq, CommandLine* cmd);
src/hardware/parport/printer_redir.h:	Bitu Read_PR();
src/hardware/parport/printer_redir.h:	Bitu Read_COM();
src/hardware/parport/printer_redir.h:	Bitu Read_SR();
src/hardware/parport/printer_redir.h:	void Write_PR(Bitu);
src/hardware/parport/printer_redir.h:	void Write_CON(Bitu);
src/hardware/parport/printer_redir.h:	void Write_IOSEL(Bitu);
src/hardware/parport/directlpt_linux.cpp:CDirectLPT::CDirectLPT (Bitu nr, Bit8u initIrq, CommandLine* cmd)
src/hardware/parport/directlpt_linux.cpp:	Bitu timeout = 10000;
src/hardware/parport/directlpt_linux.cpp:	Bitu time = timeout+SDL_GetTicks();
src/hardware/parport/directlpt_linux.cpp:	Bitu z = 0;
src/hardware/parport/directlpt_linux.cpp:Bitu CDirectLPT::Read_PR() {
src/hardware/parport/directlpt_linux.cpp:	Bitu retval;
src/hardware/parport/directlpt_linux.cpp:Bitu CDirectLPT::Read_COM() {
src/hardware/parport/directlpt_linux.cpp:	Bitu retval;
src/hardware/parport/directlpt_linux.cpp:Bitu CDirectLPT::Read_SR() {
src/hardware/parport/directlpt_linux.cpp:	//Bitu retval;
src/hardware/parport/directlpt_linux.cpp:	Bitu b = wiringPiI2CReadReg8 (porthandle, 0x13);
src/hardware/parport/directlpt_linux.cpp:	Bitu retval = (b&2)<<5|(b&4)<<5|(b&8)<<2 |(b&16)|(b&64)>>3;
src/hardware/parport/directlpt_linux.cpp:void CDirectLPT::Write_PR(Bitu val){
src/hardware/parport/directlpt_linux.cpp:void CDirectLPT::Write_CON(Bitu val) {
src/hardware/parport/directlpt_linux.cpp:	 Bitu controlout = (val&1)|(val&2)<<4|(val&4)<<5; //sort Controlbyte to GPIOB Outputs, Automatic Write only outputs eg Register OLATB
src/hardware/parport/directlpt_linux.cpp:void CDirectLPT::Write_IOSEL(Bitu val) {
Binary file src/hardware/parport/parport.o matches
src/hardware/parport/filelpt.cpp:CFileLPT::CFileLPT (Bitu nr, Bit8u initIrq, const char* path, CommandLine* cmd)
src/hardware/parport/filelpt.cpp:	Bitu timeout = 10000;
src/hardware/parport/filelpt.cpp:	Bitu time = timeout+SDL_GetTicks();
src/hardware/parport/filelpt.cpp:	Bitu z = 0;
src/hardware/parport/filelpt.cpp:Bitu CFileLPT::Read_PR()
src/hardware/parport/filelpt.cpp:Bitu CFileLPT::Read_COM()
src/hardware/parport/filelpt.cpp:Bitu CFileLPT::Read_SR()
src/hardware/parport/filelpt.cpp:void CFileLPT::Write_PR(Bitu val) {
src/hardware/parport/filelpt.cpp:void CFileLPT::Write_CON(Bitu val) {
src/hardware/parport/filelpt.cpp:void CFileLPT::Write_IOSEL(Bitu val) {
src/hardware/parport/printer.h:	void drawLine(Bitu fromx, Bitu tox, Bitu y, bool broken);
src/hardware/parport/filelpt.h:			Bitu nr,
src/hardware/parport/filelpt.h:	Bitu Read_PR();
src/hardware/parport/filelpt.h:	Bitu Read_COM();
src/hardware/parport/filelpt.h:	Bitu Read_SR();
src/hardware/parport/filelpt.h:	void Write_PR(Bitu);
src/hardware/parport/filelpt.h:	void Write_CON(Bitu);
src/hardware/parport/filelpt.h:	void Write_IOSEL(Bitu);
Binary file src/hardware/parport/printer_redir.o matches
src/hardware/opl.h:	define Bits, Bitu, Bit32s, Bit32u, Bit16s, Bit16u, Bit8s, Bit8u here
src/hardware/opl.h:typedef uintptr_t	Bitu;
src/hardware/opl.h:Bitu chip_num;
src/hardware/opl.h:void enable_operator(Bitu regbase, op_type* op_pt);
src/hardware/opl.h:void change_frequency(Bitu chanbase, Bitu regbase, op_type* op_pt);
src/hardware/opl.h:void change_attackrate(Bitu regbase, op_type* op_pt);
src/hardware/opl.h:void change_decayrate(Bitu regbase, op_type* op_pt);
src/hardware/opl.h:void change_releaserate(Bitu regbase, op_type* op_pt);
src/hardware/opl.h:void change_sustainlevel(Bitu regbase, op_type* op_pt);
src/hardware/opl.h:void change_waveform(Bitu regbase, op_type* op_pt);
src/hardware/opl.h:void change_keepsustain(Bitu regbase, op_type* op_pt);
src/hardware/opl.h:void change_vibrato(Bitu regbase, op_type* op_pt);
src/hardware/opl.h:void change_feedback(Bitu chanbase, op_type* op_pt);
src/hardware/opl.h:void adlib_write(Bitu idx, Bit8u val);
src/hardware/opl.h:Bitu adlib_reg_read(Bitu port);
src/hardware/opl.h:void adlib_write_index(Bitu port, Bit8u val);
Binary file src/hardware/disney.o matches
src/hardware/ipx.cpp:Bitu ECBSerialNumber = 0;
src/hardware/ipx.cpp:Bitu ECBAmount = 0;
src/hardware/ipx.cpp:	Bitu length=buflen;
src/hardware/ipx.cpp:	Bitu fragCount = getFragCount(); 
src/hardware/ipx.cpp:	Bitu bufoffset = 0;
src/hardware/ipx.cpp:	for(Bitu i = 0;i < fragCount;i++) {
src/hardware/ipx.cpp:		for(Bitu t = 0;t < tmpFrag.size;t++) {
src/hardware/ipx.cpp:	for(Bitu i=0;i<6;i++)
src/hardware/ipx.cpp:	for(Bitu i=0;i<6;i++)
src/hardware/ipx.cpp:	for(Bitu i=0;i<socketCount;i++) {
src/hardware/ipx.cpp:static void IPX_AES_EventHandler(Bitu param)
src/hardware/ipx.cpp:		if(tmpECB->iuflag==USEFLAG_AESCOUNT && param==(Bitu)tmpECB->ECBAddr) {
src/hardware/ipx.cpp:			for(Bitu i = 0; i < 6; i++) 
src/hardware/ipx.cpp:				(1000.0f/(1193182.0f/65536.0f))*(float)reg_ax,(Bitu)tmpECB->ECBAddr);
src/hardware/ipx.cpp:						PIC_RemoveSpecificEvents(IPX_AES_EventHandler,(Bitu)ecbaddress);
src/hardware/ipx.cpp:Bitu IPX_Handler(void) {
src/hardware/ipx.cpp:Bitu IPX_IntHandler(void) {
src/hardware/ipx.cpp:	for(Bitu m=0;m<4;m++) {
src/hardware/ipx.cpp:	for(Bitu m=0;m<6;m++) {
src/hardware/ipx.cpp:Bitu IPX_ESRHandler(void) {
src/hardware/ipx.cpp:		for(Bitu i = 0;i < 32;i++)
src/hardware/dma.cpp:	Bitu i;
src/hardware/dma.cpp:static void DMA_BlockRead(PhysPt spage,PhysPt offset,void * data,Bitu size,Bit8u dma16) {
src/hardware/dma.cpp:	Bitu highpart_addr_page = spage>>12;
src/hardware/dma.cpp:		Bitu page = highpart_addr_page+(offset >> 12);
src/hardware/dma.cpp:static void DMA_BlockWrite(PhysPt spage,PhysPt offset,void * data,Bitu size,Bit8u dma16) {
src/hardware/dma.cpp:	Bitu highpart_addr_page = spage>>12;
src/hardware/dma.cpp:		Bitu page = highpart_addr_page+(offset >> 12);
src/hardware/dma.cpp:static void DMA_Write_Port(Bitu port,Bitu val,Bitu /*iolen*/) {
src/hardware/dma.cpp:static Bitu DMA_Read_Port(Bitu port,Bitu iolen) {
src/hardware/dma.cpp:void DmaController::WriteControllerReg(Bitu reg,Bitu val,Bitu /*len*/) {
src/hardware/dma.cpp:Bitu DmaController::ReadControllerReg(Bitu reg,Bitu /*len*/) {
src/hardware/dma.cpp:	DmaChannel * chan;Bitu ret;
src/hardware/dma.cpp:Bitu DmaChannel::Read(Bitu want, Bit8u * buffer) {
src/hardware/dma.cpp:	Bitu done=0;
src/hardware/dma.cpp:	Bitu left=(currcnt+1);
src/hardware/dma.cpp:Bitu DmaChannel::Write(Bitu want, Bit8u * buffer) {
src/hardware/dma.cpp:	Bitu done=0;
src/hardware/dma.cpp:	Bitu left=(currcnt+1);
src/hardware/dma.cpp:		Bitu i;
src/hardware/dma.cpp:			Bitu mask=IO_MB;
src/hardware/dma.cpp:void DMA_SetWrapping(Bitu wrap) {
src/hardware/dma.cpp:	Bitu i;
src/hardware/vga_xga.cpp:	Bitu curcommand;
src/hardware/vga_xga.cpp:		Bitu datasize;
src/hardware/vga_xga.cpp:		Bitu buswidth;
src/hardware/vga_xga.cpp:void XGA_Write_Multifunc(Bitu val, Bitu len) {
src/hardware/vga_xga.cpp:	Bitu regselect = val >> 12;
src/hardware/vga_xga.cpp:	Bitu dataval = val & 0xfff;
src/hardware/vga_xga.cpp:Bitu XGA_Read_Multifunc() {
src/hardware/vga_xga.cpp:void XGA_DrawPoint(Bitu x, Bitu y, Bitu c) {
src/hardware/vga_xga.cpp:Bitu XGA_GetPoint(Bitu x, Bitu y) {
src/hardware/vga_xga.cpp:Bitu XGA_GetMixResult(Bitu mixmode, Bitu srcval, Bitu dstdata) {
src/hardware/vga_xga.cpp:	Bitu destval = 0;
src/hardware/vga_xga.cpp:void XGA_DrawLineVector(Bitu val) {
src/hardware/vga_xga.cpp:	Bitu srcval;
src/hardware/vga_xga.cpp:	Bitu destval;
src/hardware/vga_xga.cpp:	Bitu dstdata;
src/hardware/vga_xga.cpp:		Bitu mixmode = (xga.pix_cntl >> 6) & 0x3;
src/hardware/vga_xga.cpp:void XGA_DrawLineBresenham(Bitu val) {
src/hardware/vga_xga.cpp:	Bitu srcval;
src/hardware/vga_xga.cpp:	Bitu destval;
src/hardware/vga_xga.cpp:	Bitu dstdata;
src/hardware/vga_xga.cpp:			Bitu mixmode = (xga.pix_cntl >> 6) & 0x3;
src/hardware/vga_xga.cpp:void XGA_DrawRectangle(Bitu val) {
src/hardware/vga_xga.cpp:	Bitu srcval;
src/hardware/vga_xga.cpp:	Bitu destval;
src/hardware/vga_xga.cpp:	Bitu dstdata;
src/hardware/vga_xga.cpp:			Bitu mixmode = (xga.pix_cntl >> 6) & 0x3;
src/hardware/vga_xga.cpp:void XGA_DrawWaitSub(Bitu mixmode, Bitu srcval) {
src/hardware/vga_xga.cpp:	Bitu destval;
src/hardware/vga_xga.cpp:	Bitu dstdata;
src/hardware/vga_xga.cpp:void XGA_DrawWait(Bitu val, Bitu len) {
src/hardware/vga_xga.cpp:	Bitu mixmode = (xga.pix_cntl >> 6) & 0x3;
src/hardware/vga_xga.cpp:	Bitu srcval;
src/hardware/vga_xga.cpp:							for(Bitu i = 0; i < len; i++) {
src/hardware/vga_xga.cpp:					Bitu chunksize;
src/hardware/vga_xga.cpp:					Bitu chunks;
src/hardware/vga_xga.cpp:					for(Bitu k = 0; k < chunks; k++) { // chunks counter
src/hardware/vga_xga.cpp:						for(Bitu n = 0; n < chunksize; n++) { // pixels
src/hardware/vga_xga.cpp:							Bitu mixmode;
src/hardware/vga_xga.cpp:							Bitu mask = 1 << ((((n&0xF8)+(8-(n&0x7)))-1)+chunksize*k);
src/hardware/vga_xga.cpp:void XGA_BlitRect(Bitu val) {
src/hardware/vga_xga.cpp:	Bitu srcdata;
src/hardware/vga_xga.cpp:	Bitu dstdata;
src/hardware/vga_xga.cpp:	Bitu srcval;
src/hardware/vga_xga.cpp:	Bitu destval;
src/hardware/vga_xga.cpp:	Bitu mixselect = (xga.pix_cntl >> 6) & 0x3;
src/hardware/vga_xga.cpp:	Bitu mixmode = 0x67; /* Source is bitmap data, mix mode is src */
src/hardware/vga_xga.cpp:void XGA_DrawPattern(Bitu val) {
src/hardware/vga_xga.cpp:	Bitu srcdata;
src/hardware/vga_xga.cpp:	Bitu dstdata;
src/hardware/vga_xga.cpp:	Bitu srcval;
src/hardware/vga_xga.cpp:	Bitu destval;
src/hardware/vga_xga.cpp:	Bitu mixselect = (xga.pix_cntl >> 6) & 0x3;
src/hardware/vga_xga.cpp:	Bitu mixmode = 0x67; /* Source is bitmap data, mix mode is src */
src/hardware/vga_xga.cpp:void XGA_DrawCmd(Bitu val, Bitu len) {
src/hardware/vga_xga.cpp:void XGA_SetDualReg(Bit32u& reg, Bitu val) {
src/hardware/vga_xga.cpp:Bitu XGA_GetDualReg(Bit32u reg) {
src/hardware/vga_xga.cpp:extern Bitu vga_read_p3da(Bitu port,Bitu iolen);
src/hardware/vga_xga.cpp:extern void vga_write_p3d4(Bitu port,Bitu val,Bitu iolen);
src/hardware/vga_xga.cpp:extern Bitu vga_read_p3d4(Bitu port,Bitu iolen);
src/hardware/vga_xga.cpp:extern void vga_write_p3d5(Bitu port,Bitu val,Bitu iolen);
src/hardware/vga_xga.cpp:extern Bitu vga_read_p3d5(Bitu port,Bitu iolen);
src/hardware/vga_xga.cpp:void XGA_Write(Bitu port, Bitu val, Bitu len) {
src/hardware/vga_xga.cpp:Bitu XGA_Read(Bitu port, Bitu len) {
Binary file src/hardware/vga_misc.o matches
Binary file src/hardware/pic.o matches
Binary file src/hardware/cmos.o matches
Binary file src/hardware/pcspeaker.o matches
src/hardware/iohandler.cpp:static Bitu IO_ReadBlocked(Bitu /*port*/,Bitu /*iolen*/) {
src/hardware/iohandler.cpp:static void IO_WriteBlocked(Bitu /*port*/,Bitu /*val*/,Bitu /*iolen*/) {
src/hardware/iohandler.cpp:static Bitu IO_ReadDefault(Bitu port,Bitu iolen) {
src/hardware/iohandler.cpp:void IO_WriteDefault(Bitu port,Bitu val,Bitu iolen) {
src/hardware/iohandler.cpp:void IO_RegisterReadHandler(Bitu port,IO_ReadHandler * handler,Bitu mask,Bitu range) {
src/hardware/iohandler.cpp:void IO_RegisterWriteHandler(Bitu port,IO_WriteHandler * handler,Bitu mask,Bitu range) {
src/hardware/iohandler.cpp:void IO_FreeReadHandler(Bitu port,Bitu mask,Bitu range) {
src/hardware/iohandler.cpp:void IO_FreeWriteHandler(Bitu port,Bitu mask,Bitu range) {
src/hardware/iohandler.cpp:void IO_ReadHandleObject::Install(Bitu port,IO_ReadHandler * handler,Bitu mask,Bitu range) {
src/hardware/iohandler.cpp:void IO_WriteHandleObject::Install(Bitu port,IO_WriteHandler * handler,Bitu mask,Bitu range) {
src/hardware/iohandler.cpp:	Bitu cs;
src/hardware/iohandler.cpp:	Bitu eip;
src/hardware/iohandler.cpp:	Bitu used;
src/hardware/iohandler.cpp:void log_io(Bitu width, bool write, Bitu port, Bitu val) {
src/hardware/iohandler.cpp:void IO_WriteB(Bitu port,Bitu val) {
src/hardware/iohandler.cpp:void IO_WriteW(Bitu port,Bitu val) {
src/hardware/iohandler.cpp:void IO_WriteD(Bitu port,Bitu val) {
src/hardware/iohandler.cpp:Bitu IO_ReadB(Bitu port) {
src/hardware/iohandler.cpp:	Bitu retval;
src/hardware/iohandler.cpp:Bitu IO_ReadW(Bitu port) {
src/hardware/iohandler.cpp:	Bitu retval;
src/hardware/iohandler.cpp:Bitu IO_ReadD(Bitu port) {
src/hardware/iohandler.cpp:	Bitu retval;
src/hardware/vga_other.cpp:static void write_crtc_index_other(Bitu /*port*/,Bitu val,Bitu /*iolen*/) {
src/hardware/vga_other.cpp:static Bitu read_crtc_index_other(Bitu /*port*/,Bitu /*iolen*/) {
src/hardware/vga_other.cpp:static void write_crtc_data_other(Bitu /*port*/,Bitu val,Bitu /*iolen*/) {
src/hardware/vga_other.cpp:static Bitu read_crtc_data_other(Bitu /*port*/,Bitu /*iolen*/) {
src/hardware/vga_other.cpp:	return (Bitu)(~0);
src/hardware/vga_other.cpp:static void write_lightpen(Bitu port,Bitu val,Bitu) {
src/hardware/vga_other.cpp:			Bitu current_scanline = (Bitu)(timeInFrame / vga.draw.delay.htotal);
src/hardware/vga_other.cpp:	Bitu CGApal[4] = {
src/hardware/vga_other.cpp:static void write_cga_color_select(Bitu val) {
src/hardware/vga_other.cpp:static void write_cga(Bitu port,Bitu val,Bitu /*iolen*/) {
src/hardware/vga_other.cpp:		vga.tandy.addr_mask = (Bitu)(~0);
src/hardware/vga_other.cpp:static void write_tandy(Bitu port,Bitu val,Bitu /*iolen*/) {
src/hardware/vga_other.cpp:static void write_pcjr(Bitu port,Bitu val,Bitu /*iolen*/) {
src/hardware/vga_other.cpp:static void write_hercules(Bitu port,Bitu val,Bitu /*iolen*/) {
src/hardware/vga_other.cpp:/* static Bitu read_hercules(Bitu port,Bitu iolen) {
src/hardware/vga_other.cpp:Bitu read_herc_status(Bitu /*port*/,Bitu /*iolen*/) {
src/hardware/vga_other.cpp:	Bitu i;
src/hardware/vga_other.cpp:		Bitu base=0x3b0;
src/hardware/vga_other.cpp:		for (Bitu i = 0; i < 4; i++) {
src/hardware/vga_other.cpp:		Bitu base=0x3d0;
src/hardware/vga_other.cpp:		for (Bitu port_ct=0; port_ct<4; port_ct++) {
src/hardware/hardware.cpp:Bitu CaptureState;
src/hardware/hardware.cpp:		Bitu used;
src/hardware/hardware.cpp:		Bitu used,done;
src/hardware/hardware.cpp:		Bitu rowlen;
src/hardware/hardware.cpp:		Bitu		frames;
src/hardware/hardware.cpp:		Bitu		audioused;
src/hardware/hardware.cpp:		Bitu		audiorate;
src/hardware/hardware.cpp:		Bitu		audiowritten;
src/hardware/hardware.cpp:		Bitu		width, height, bpp;
src/hardware/hardware.cpp:		Bitu		written;
src/hardware/hardware.cpp:		Bitu		indexsize, indexused;
src/hardware/hardware.cpp:	Bitu last=0;
src/hardware/hardware.cpp:		Bitu num=atoi(&tempname[strlen(file_start)]);
src/hardware/hardware.cpp:		Bitu main_list;
src/hardware/hardware.cpp:		Bitu header_pos=0;
src/hardware/hardware.cpp:void CAPTURE_AddImage(Bitu width, Bitu height, Bitu bpp, Bitu pitch, Bitu flags, float fps, Bit8u * data, Bit8u * pal) {
src/hardware/hardware.cpp:	Bitu i;
src/hardware/hardware.cpp:	Bitu countWidth = width;
src/hardware/hardware.cpp:   					for (Bitu x=0;x<countWidth;x++)
src/hardware/hardware.cpp:					for (Bitu x=0;x<countWidth;x++) {
src/hardware/hardware.cpp:						Bitu pixel = ((Bit16u *)srcLine)[x];
src/hardware/hardware.cpp:					for (Bitu x=0;x<countWidth;x++) {
src/hardware/hardware.cpp:						Bitu pixel = ((Bit16u *)srcLine)[x];
src/hardware/hardware.cpp:					for (Bitu x=0;x<countWidth;x++) {
src/hardware/hardware.cpp:						Bitu pixel = ((Bit16u *)srcLine)[x];
src/hardware/hardware.cpp:					for (Bitu x=0;x<countWidth;x++) {
src/hardware/hardware.cpp:						Bitu pixel = ((Bit16u *)srcLine)[x];
src/hardware/hardware.cpp:					for (Bitu x=0;x<countWidth;x++) {
src/hardware/hardware.cpp:					for (Bitu x=0;x<countWidth;x++) {
src/hardware/hardware.cpp:				Bitu x;
src/hardware/hardware.cpp:				Bitu countWidth = width >> 1;
src/hardware/hardware.cpp:		Bitu left = WAVE_BUF - capture.video.audioused;
src/hardware/hardware.cpp:			Bitu left = WAVE_BUF - capture.wave.used;
src/hardware/hardware.cpp:void CAPTURE_AddMidi(bool sysex, Bitu len, Bit8u * data) {
src/hardware/hardware.cpp:	for (Bitu i=0;i<len;i++) 
Binary file src/hardware/adlib.o matches
Binary file src/hardware/vga_tseng.o matches
src/hardware/vga_tseng.cpp:	Bitu store_3d4_31;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_32;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_33;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_34;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_35;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_36;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_37;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_3f;
src/hardware/vga_tseng.cpp:	Bitu store_3c0_16;
src/hardware/vga_tseng.cpp:	Bitu store_3c0_17;
src/hardware/vga_tseng.cpp:	Bitu store_3c4_06;
src/hardware/vga_tseng.cpp:	Bitu store_3c4_07;
src/hardware/vga_tseng.cpp:	Bitu clockFreq[16];
src/hardware/vga_tseng.cpp:	Bitu biosMode;
src/hardware/vga_tseng.cpp:void write_p3d5_et4k(Bitu reg,Bitu val,Bitu iolen) {
src/hardware/vga_tseng.cpp:Bitu read_p3d5_et4k(Bitu reg,Bitu iolen) {
src/hardware/vga_tseng.cpp:void write_p3c5_et4k(Bitu reg,Bitu val,Bitu iolen) {
src/hardware/vga_tseng.cpp:Bitu read_p3c5_et4k(Bitu reg,Bitu iolen) {
src/hardware/vga_tseng.cpp:void write_p3cd_et4k(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_tseng.cpp:Bitu read_p3cd_et4k(Bitu port,Bitu iolen) {
src/hardware/vga_tseng.cpp:void write_p3c0_et4k(Bitu reg,Bitu val,Bitu iolen) {
src/hardware/vga_tseng.cpp:Bitu read_p3c1_et4k(Bitu reg,Bitu iolen) {
src/hardware/vga_tseng.cpp:static Bitu get_clock_index_et4k() {
src/hardware/vga_tseng.cpp:static void set_clock_index_et4k(Bitu index) {
src/hardware/vga_tseng.cpp:void FinishSetMode_ET4K(Bitu crtc_base, VGA_ModeExtraData* modeData) {
src/hardware/vga_tseng.cpp:		Bitu target = modeData->vtotal*8*modeData->htotal*60;
src/hardware/vga_tseng.cpp:		Bitu best = 1;
src/hardware/vga_tseng.cpp:		for (Bitu i=0; i<16; i++) {
src/hardware/vga_tseng.cpp:void SetClock_ET4K(Bitu which,Bitu target) {
src/hardware/vga_tseng.cpp:Bitu GetClock_ET4K() {
src/hardware/vga_tseng.cpp:bool AcceptsMode_ET4K(Bitu mode) {
src/hardware/vga_tseng.cpp:	Bitu store_3d4_1b;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_1c;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_1d;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_1e;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_1f;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_20;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_21;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_23; // note that 22 is missing
src/hardware/vga_tseng.cpp:	Bitu store_3d4_24;
src/hardware/vga_tseng.cpp:	Bitu store_3d4_25;
src/hardware/vga_tseng.cpp:	Bitu store_3c0_16;
src/hardware/vga_tseng.cpp:	Bitu store_3c0_17;
src/hardware/vga_tseng.cpp:	Bitu store_3c4_06;
src/hardware/vga_tseng.cpp:	Bitu store_3c4_07;
src/hardware/vga_tseng.cpp:	Bitu clockFreq[8];
src/hardware/vga_tseng.cpp:	Bitu biosMode;
src/hardware/vga_tseng.cpp:void write_p3d5_et3k(Bitu reg,Bitu val,Bitu iolen) {
src/hardware/vga_tseng.cpp:Bitu read_p3d5_et3k(Bitu reg,Bitu iolen) {
src/hardware/vga_tseng.cpp:void write_p3c5_et3k(Bitu reg,Bitu val,Bitu iolen) {
src/hardware/vga_tseng.cpp:Bitu read_p3c5_et3k(Bitu reg,Bitu iolen) {
src/hardware/vga_tseng.cpp:void write_p3cd_et3k(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_tseng.cpp:Bitu read_p3cd_et3k(Bitu port,Bitu iolen) {
src/hardware/vga_tseng.cpp:void write_p3c0_et3k(Bitu reg,Bitu val,Bitu iolen) {
src/hardware/vga_tseng.cpp:Bitu read_p3c1_et3k(Bitu reg,Bitu iolen) {
src/hardware/vga_tseng.cpp:static Bitu get_clock_index_et3k() {
src/hardware/vga_tseng.cpp:static void set_clock_index_et3k(Bitu index) {
src/hardware/vga_tseng.cpp:void FinishSetMode_ET3K(Bitu crtc_base, VGA_ModeExtraData* modeData) {
src/hardware/vga_tseng.cpp:	for (Bitu i=0x16; i<=0x21; i++)
src/hardware/vga_tseng.cpp:		Bitu target = modeData->vtotal*8*modeData->htotal*60;
src/hardware/vga_tseng.cpp:		Bitu best = 1;
src/hardware/vga_tseng.cpp:		for (Bitu i=0; i<8; i++) {
src/hardware/vga_tseng.cpp:void SetClock_ET3K(Bitu which,Bitu target) {
src/hardware/vga_tseng.cpp:Bitu GetClock_ET3K() {
src/hardware/vga_tseng.cpp:bool AcceptsMode_ET3K(Bitu mode) {
src/hardware/gameblaster.cpp:static Bitu last_command;
src/hardware/gameblaster.cpp:static Bitu base_port;
src/hardware/gameblaster.cpp:static void write_cms(Bitu port, Bitu val, Bitu /* iolen */) {
src/hardware/gameblaster.cpp:static void CMS_CallBack(Bitu len) {
src/hardware/gameblaster.cpp:	for (Bitu l=0;l<len;l++) {
src/hardware/gameblaster.cpp:static void write_cms_detect(Bitu port, Bitu val, Bitu /* iolen */) {
src/hardware/gameblaster.cpp:static Bitu read_cms_detect(Bitu port, Bitu /* iolen */) {
src/hardware/gameblaster.cpp:		Bitu sample_rate_temp = section->Get_int("oplrate");
Binary file src/hardware/vga_dac.o matches
Binary file src/hardware/vga_paradise.o matches
src/hardware/cmos.cpp:static void cmos_timerevent(Bitu val) {
src/hardware/cmos.cpp:void cmos_selreg(Bitu port,Bitu val,Bitu iolen) {
src/hardware/cmos.cpp:static void cmos_writereg(Bitu port,Bitu val,Bitu iolen) {
src/hardware/cmos.cpp:static Bitu cmos_readreg(Bitu port,Bitu iolen) {
src/hardware/cmos.cpp:	Bitu drive_a, drive_b;
src/hardware/cmos.cpp:void CMOS_SetRegister(Bitu regNr, Bit8u val) {
src/hardware/cmos.cpp:		Bitu exsize=(MEM_TotalPages()*4)-1024;
src/hardware/joystick.cpp:	Bitu xcount,ycount;
src/hardware/joystick.cpp:static Bitu read_p201(Bitu port,Bitu iolen) {
src/hardware/joystick.cpp:static Bitu read_p201_timed(Bitu port,Bitu iolen) {
src/hardware/joystick.cpp:static void write_p201(Bitu port,Bitu val,Bitu iolen) {
src/hardware/joystick.cpp:		stick[0].xcount=(Bitu)((stick[0].xpos*RANGE)+RANGE);
src/hardware/joystick.cpp:		stick[0].ycount=(Bitu)((stick[0].ypos*RANGE)+RANGE);
src/hardware/joystick.cpp:		stick[1].xcount=(Bitu)(((swap34? stick[1].ypos : stick[1].xpos)*RANGE)+RANGE);
src/hardware/joystick.cpp:		stick[1].ycount=(Bitu)(((swap34? stick[1].xpos : stick[1].ypos)*RANGE)+RANGE);
src/hardware/joystick.cpp:static void write_p201_timed(Bitu port,Bitu val,Bitu iolen) {
src/hardware/joystick.cpp:void JOYSTICK_Enable(Bitu which,bool enabled) {
src/hardware/joystick.cpp:void JOYSTICK_Button(Bitu which,Bitu num,bool pressed) {
src/hardware/joystick.cpp:void JOYSTICK_Move_X(Bitu which,float x) {
src/hardware/joystick.cpp:void JOYSTICK_Move_Y(Bitu which,float y) {
src/hardware/joystick.cpp:bool JOYSTICK_IsEnabled(Bitu which) {
src/hardware/joystick.cpp:bool JOYSTICK_GetButton(Bitu which, Bitu num) {
src/hardware/joystick.cpp:float JOYSTICK_GetMove_X(Bitu which) {
src/hardware/joystick.cpp:float JOYSTICK_GetMove_Y(Bitu which) {
src/hardware/vga_s3.cpp:void SVGA_S3_WriteCRTC(Bitu reg,Bitu val,Bitu iolen) {
src/hardware/vga_s3.cpp:		if ((((Bitu)vga.s3.hgc.startaddr)<<10)+((64*64*2)/8) > vga.vmemsize) {
src/hardware/vga_s3.cpp:Bitu SVGA_S3_ReadCRTC( Bitu reg, Bitu iolen) {
src/hardware/vga_s3.cpp:void SVGA_S3_WriteSEQ(Bitu reg,Bitu val,Bitu iolen) {
src/hardware/vga_s3.cpp:Bitu SVGA_S3_ReadSEQ(Bitu reg,Bitu iolen) {
src/hardware/vga_s3.cpp:Bitu SVGA_S3_GetClock(void) {
src/hardware/vga_s3.cpp:	Bitu clock = (vga.misc_output >> 2) & 3;
src/hardware/vga_s3.cpp:bool SVGA_S3_AcceptsMode(Bitu mode) {
src/hardware/mpu401.cpp:static void MPU401_Event(Bitu);
src/hardware/mpu401.cpp:static void MPU401_ResetDone(Bitu);
src/hardware/mpu401.cpp:static void MPU401_EOIHandler(Bitu val=0);
src/hardware/mpu401.cpp:static void MPU401_WriteData(Bitu port,Bitu val,Bitu iolen);
src/hardware/mpu401.cpp:	Bitu irq;
src/hardware/mpu401.cpp:	Bitu queue_pos,queue_used;
src/hardware/mpu401.cpp:		Bitu command_byte,cmd_pending;
src/hardware/mpu401.cpp:		Bitu pos=mpu.queue_used+mpu.queue_pos;
src/hardware/mpu401.cpp:static Bitu MPU401_ReadStatus(Bitu port,Bitu iolen) {
src/hardware/mpu401.cpp:static void MPU401_WriteCommand(Bitu port,Bitu val,Bitu iolen) {
src/hardware/mpu401.cpp:				for (Bitu i=0xb0;i<0xbf;i++) {	/* All notes off */
src/hardware/mpu401.cpp:			for (Bitu i=0xb0;i<0xbf;i++) {	/* All notes off */
src/hardware/mpu401.cpp:			for (Bitu i=0;i<8;i++) {
src/hardware/mpu401.cpp:static Bitu MPU401_ReadData(Bitu port,Bitu iolen) {
src/hardware/mpu401.cpp:static void MPU401_WriteData(Bitu port,Bitu val,Bitu iolen) {
src/hardware/mpu401.cpp:	static Bitu length,cnt,posd;
src/hardware/mpu401.cpp:	Bitu val;
src/hardware/mpu401.cpp:			for (Bitu i=0;i<mpu.playbuf[chan].vlength;i++)
src/hardware/mpu401.cpp:static void MPU401_Event(Bitu val) {
src/hardware/mpu401.cpp:	for (Bitu i=0;i<8;i++) { /* Decrease counters */
src/hardware/mpu401.cpp:	Bitu new_time;
src/hardware/mpu401.cpp:static void MPU401_EOIHandler(Bitu val) {
src/hardware/mpu401.cpp:	Bitu i=0;
src/hardware/mpu401.cpp:static void MPU401_ResetDone(Bitu) {
src/hardware/mpu401.cpp:	for (Bitu i=0;i<8;i++) {mpu.playbuf[i].type=T_OVERFLOW;mpu.playbuf[i].counter=0;}
Binary file src/hardware/vga_draw.o matches
src/hardware/disney.cpp.orig:	Bitu used;					// current data buffer level
src/hardware/disney.cpp.orig:	Bitu last_used;
src/hardware/disney.cpp.orig:	Bitu state;
src/hardware/disney.cpp.orig:	Bitu interface_det;
src/hardware/disney.cpp.orig:	Bitu interface_det_ext;
src/hardware/disney.cpp.orig:static void DISNEY_CallBack(Bitu len);
src/hardware/disney.cpp.orig:static void DISNEY_disable(Bitu) {
src/hardware/disney.cpp.orig:static void DISNEY_enable(Bitu freq) {
src/hardware/disney.cpp.orig:static void DISNEY_analyze(Bitu channel){
src/hardware/disney.cpp.orig:			Bitu ch_speed[2];
src/hardware/disney.cpp.orig:			for(Bitu i = 0; i < 2; i++) {
src/hardware/disney.cpp.orig:				ch_speed[i] = (Bitu)(1.0/((disney.da[i].speedcheck_sum/1000.0) /
src/hardware/disney.cpp.orig:static void disney_write(Bitu port,Bitu val,Bitu iolen) {
src/hardware/disney.cpp.orig:static Bitu disney_read(Bitu port,Bitu iolen) {
src/hardware/disney.cpp.orig:	Bitu retval;
src/hardware/disney.cpp.orig:static void DISNEY_PlayStereo(Bitu len, Bit8u* l, Bit8u* r) {
src/hardware/disney.cpp.orig:	for(Bitu i = 0; i < len; i++) {
src/hardware/disney.cpp.orig:static void DISNEY_CallBack(Bitu len) {
src/hardware/disney.cpp.orig:	Bitu real_used;
Binary file src/hardware/vga_xga.o matches
src/hardware/vga_gfx.cpp:static void write_p3ce(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_gfx.cpp:static Bitu read_p3ce(Bitu port,Bitu iolen) {
src/hardware/vga_gfx.cpp:static void write_p3cf(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_gfx.cpp:static Bitu read_p3cf(Bitu port,Bitu iolen) {
src/hardware/vga_seq.cpp:Bitu read_p3c4(Bitu /*port*/,Bitu /*iolen*/) {
src/hardware/vga_seq.cpp:void write_p3c4(Bitu /*port*/,Bitu val,Bitu /*iolen*/) {
src/hardware/vga_seq.cpp:void write_p3c5(Bitu /*port*/,Bitu val,Bitu iolen) {
src/hardware/vga_seq.cpp:Bitu read_p3c5(Bitu /*port*/,Bitu iolen) {
src/hardware/dbopl.h:typedef Bits ( DB_FASTCALL *WaveHandler) ( Bitu i, Bitu volume );
src/hardware/dbopl.h:	Bitu ForwardWave();
src/hardware/dbopl.h:	Bitu ForwardVolume();
src/hardware/dbopl.h:	Bits GetWave( Bitu index, Bitu vol );
src/hardware/dbopl.h:	inline Operator* Op( Bitu index ) {
src/hardware/dbopl.h:	void GenerateBlock2( Bitu samples, Bit32s* output );
src/hardware/dbopl.h:	void GenerateBlock3( Bitu samples, Bit32s* output );
src/hardware/dbopl.h:	virtual void Generate( MixerChannel* chan, Bitu samples );
src/hardware/dbopl.h:	virtual void Init( Bitu rate );
Binary file src/hardware/libhardware.a matches
Binary file src/hardware/mpu401.o matches
src/hardware/timer.cpp:	Bitu cntr;
src/hardware/timer.cpp:static void PIT0_Event(Bitu /*val*/) {
src/hardware/timer.cpp:static bool counter_output(Bitu counter) {
src/hardware/timer.cpp:static void status_latch(Bitu counter) {
src/hardware/timer.cpp:static void counter_latch(Bitu counter) {
src/hardware/timer.cpp:		Bitu ticks_since_then = (Bitu)(passed_time / (1000.0/PIT_TICK_RATE));
src/hardware/timer.cpp:static void write_latch(Bitu port,Bitu val,Bitu /*iolen*/) {
src/hardware/timer.cpp:	Bitu counter=port-0x40;
src/hardware/timer.cpp:static Bitu read_latch(Bitu port,Bitu /*iolen*/) {
src/hardware/timer.cpp:static void write_p43(Bitu /*port*/,Bitu val,Bitu /*iolen*/) {
src/hardware/timer.cpp:	Bitu latch=(val >> 6) & 0x03;
Binary file src/hardware/iohandler.o matches
src/hardware/vga_dac.cpp:static void VGA_DAC_SendColor( Bitu index, Bitu src ) {
src/hardware/vga_dac.cpp:static void VGA_DAC_UpdateColor( Bitu index ) {
src/hardware/vga_dac.cpp:	Bitu maskIndex = index & vga.dac.pel_mask;
src/hardware/vga_dac.cpp:static void write_p3c6(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_dac.cpp:		for ( Bitu i = 0;i<256;i++) 
src/hardware/vga_dac.cpp:static Bitu read_p3c6(Bitu port,Bitu iolen) {
src/hardware/vga_dac.cpp:static void write_p3c7(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_dac.cpp:static Bitu read_p3c7(Bitu port,Bitu iolen) {
src/hardware/vga_dac.cpp:static void write_p3c8(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_dac.cpp:static Bitu read_p3c8(Bitu port, Bitu iolen){
src/hardware/vga_dac.cpp:static void write_p3c9(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_dac.cpp:				Bitu index = vga.dac.write_index;
src/hardware/vga_dac.cpp:					for ( Bitu i = index+1;i<256;i++) 
src/hardware/vga_dac.cpp:			for (Bitu i=0;i<16;i++) {
src/hardware/vga_dac.cpp:static Bitu read_p3c9(Bitu port,Bitu iolen) {
src/hardware/vga_dac.cpp:void VGA_DAC_SetEntry(Bitu entry,Bit8u red,Bit8u green,Bit8u blue) {
src/hardware/vga_dac.cpp:	for (Bitu i=0;i<16;i++) 
Binary file src/hardware/vga_seq.o matches
src/hardware/sblaster.cpp:	Bitu freq;
src/hardware/sblaster.cpp:		Bitu rate,mul;
src/hardware/sblaster.cpp:		Bitu total,left,min;
src/hardware/sblaster.cpp:		Bitu bits;
src/hardware/sblaster.cpp:		Bitu remain_size;
src/hardware/sblaster.cpp:			Bitu pos,used;
src/hardware/sblaster.cpp:		Bitu write_busy;
src/hardware/sblaster.cpp:		Bitu used;
src/hardware/sblaster.cpp:		Bitu base;
src/hardware/sblaster.cpp:		Bitu irq;
src/hardware/sblaster.cpp:		Bitu count;
src/hardware/sblaster.cpp:static void END_DMA_Event(Bitu);
src/hardware/sblaster.cpp:static void DMA_Silent_Event(Bitu val);
src/hardware/sblaster.cpp:static void GenerateDMASound(Bitu size);
src/hardware/sblaster.cpp:static void GenerateDMASound(Bitu size) {
src/hardware/sblaster.cpp:	Bitu read=0;Bitu done=0;Bitu i=0;
src/hardware/sblaster.cpp:			Bitu total=read+sb.dma.remain_size;
src/hardware/sblaster.cpp:			Bitu total=read+sb.dma.remain_size;
src/hardware/sblaster.cpp:static void GenerateDACSound(Bitu len) {
src/hardware/sblaster.cpp:	Bitu dac_add=(sb.dac.used<<16)/len;
src/hardware/sblaster.cpp:	Bitu dac_pos=0;
src/hardware/sblaster.cpp:	for (Bitu i=len;i;i--) {
src/hardware/sblaster.cpp:static void DMA_Silent_Event(Bitu val) {
src/hardware/sblaster.cpp:	Bitu read=sb.dma.chan->Read(val,sb.dma.buf.b8);
src/hardware/sblaster.cpp:		Bitu bigger=(sb.dma.left > sb.dma.min) ? sb.dma.min : sb.dma.left;
src/hardware/sblaster.cpp:static void END_DMA_Event(Bitu val) {
src/hardware/sblaster.cpp:		Bitu bigger=(sb.dma.left > sb.dma.min) ? sb.dma.min : sb.dma.left;
src/hardware/sblaster.cpp:static void DSP_RaiseIRQEvent(Bitu /*val*/) {
src/hardware/sblaster.cpp:static void DSP_DoDMATransfer(DMA_MODES mode,Bitu freq,bool stereo) {
src/hardware/sblaster.cpp:static void DSP_PrepareDMA_New(DMA_MODES mode,Bitu length,bool autoinit,bool stereo) {
src/hardware/sblaster.cpp:	Bitu freq=sb.freq;
src/hardware/sblaster.cpp:		Bitu start=sb.dsp.out.used+sb.dsp.out.pos;
src/hardware/sblaster.cpp:static void DSP_FinishReset(Bitu /*val*/) {
src/hardware/sblaster.cpp:static void DSP_ChangeRate(Bitu freq) {
src/hardware/sblaster.cpp:Bitu DEBUG_EnableDebugger(void);
src/hardware/sblaster.cpp:			for (Bitu i = 0; i < 8; i++)
src/hardware/sblaster.cpp:static Bitu read_sb(Bitu port,Bitu /*iolen*/) {
src/hardware/sblaster.cpp:static void write_sb(Bitu port,Bitu val,Bitu /*iolen*/) {
src/hardware/sblaster.cpp:static void adlib_gusforward(Bitu /*port*/,Bitu val,Bitu /*iolen*/) {
src/hardware/sblaster.cpp:bool SB_Get_Address(Bitu& sbaddr, Bitu& sbirq, Bitu& sbdma) {
src/hardware/sblaster.cpp:static void SBLASTER_CallBack(Bitu len) {
src/hardware/sblaster.cpp:		Bitu i;
src/hardware/sblaster.cpp:		Bitu dma8bit=section->Get_int("dma");
src/hardware/sblaster.cpp:		Bitu dma16bit=section->Get_int("hdma");
src/hardware/sblaster.cpp:		     << " I" << dec << (Bitu)sb.hw.irq << " D" << (Bitu)sb.hw.dma8;
src/hardware/sblaster.cpp:		if (sb.type==SBT_16) temp << " H" << (Bitu)sb.hw.dma16;
src/hardware/adlib.h:	virtual void Generate( MixerChannel* chan, Bitu samples ) = 0;
src/hardware/adlib.h:	virtual void Init( Bitu rate ) = 0;
src/hardware/adlib.h:	Bitu CtrlRead( void );
src/hardware/adlib.h:	void PortWrite( Bitu port, Bitu val, Bitu iolen );
src/hardware/adlib.h:	Bitu PortRead( Bitu port, Bitu iolen );
src/hardware/mixer.cpp:	Bitu pos,done;
src/hardware/mixer.cpp:	Bitu needed, min_needed, max_needed;
src/hardware/mixer.cpp:MixerChannel * MIXER_AddChannel(MIXER_Handler handler,Bitu freq,const char * name) {
src/hardware/mixer.cpp:void MixerChannel::SetFreq(Bitu _freq) {
src/hardware/mixer.cpp:void MixerChannel::Mix(Bitu _needed) {
src/hardware/mixer.cpp:		Bitu todo=needed-done;
src/hardware/mixer.cpp:inline void MixerChannel::AddSamples(Bitu len, const Type* data) {
src/hardware/mixer.cpp:	Bitu mixpos=mixer.pos+done;
src/hardware/mixer.cpp:	Bitu pos=0;Bitu new_pos;
src/hardware/mixer.cpp:void MixerChannel::AddStretched(Bitu len,Bit16s * data) {
src/hardware/mixer.cpp:	Bitu outlen=needed-done;Bits diff;
src/hardware/mixer.cpp:	Bitu temp_add=(len << MIXER_SHIFT)/outlen;
src/hardware/mixer.cpp:	Bitu mixpos=mixer.pos+done;done=needed;
src/hardware/mixer.cpp:	Bitu pos=0;
src/hardware/mixer.cpp:		Bitu new_pos=freq_index >> MIXER_SHIFT;
src/hardware/mixer.cpp:void MixerChannel::AddSamples_m8(Bitu len, const Bit8u * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_s8(Bitu len,const Bit8u * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_m8s(Bitu len,const Bit8s * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_s8s(Bitu len,const Bit8s * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_m16(Bitu len,const Bit16s * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_s16(Bitu len,const Bit16s * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_m16u(Bitu len,const Bit16u * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_s16u(Bitu len,const Bit16u * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_m32(Bitu len,const Bit32s * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_s32(Bitu len,const Bit32s * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_m16_nonnative(Bitu len,const Bit16s * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_s16_nonnative(Bitu len,const Bit16s * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_m16u_nonnative(Bitu len,const Bit16u * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_s16u_nonnative(Bitu len,const Bit16u * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_m32_nonnative(Bitu len,const Bit32s * data) {
src/hardware/mixer.cpp:void MixerChannel::AddSamples_s32_nonnative(Bitu len,const Bit32s * data) {
src/hardware/mixer.cpp:	Mix((Bitu)(index*mixer.needed));
src/hardware/mixer.cpp:static void MIXER_MixData(Bitu needed) {
src/hardware/mixer.cpp:		Bitu added=needed-mixer.done;
src/hardware/mixer.cpp:		Bitu readpos=(mixer.pos+mixer.done)&MIXER_BUFMASK;
src/hardware/mixer.cpp:		for (Bitu i=0;i<added;i++) {
src/hardware/mixer.cpp:	for (Bitu i=0;i<mixer.needed;i++) {
src/hardware/mixer.cpp:	Bitu need=(Bitu)len/MIXER_SSIZE;
src/hardware/mixer.cpp:	Bitu reduce;
src/hardware/mixer.cpp:	Bitu pos, index, index_add;
src/hardware/mixer.cpp:		Bitu left = mixer.done - need;
src/hardware/mixer.cpp:				Bitu needed = mixer.needed - need;
src/hardware/mixer.cpp:				Bitu diff = (mixer.min_needed>needed?mixer.min_needed:needed) - left;
src/hardware/mixer.cpp:			Bitu diff = left - mixer.min_needed;
src/hardware/mixer.cpp:			Bitu i = (pos + (index >> MIXER_SHIFT )) & MIXER_BUFMASK;
src/hardware/mixer.cpp:		Bitu w=0;
src/hardware/mixer.cpp:MixerChannel* MixerObject::Install(MIXER_Handler handler,Bitu freq,const char * name){
src/hardware/vga_paradise.cpp:	Bitu PR0A;
src/hardware/vga_paradise.cpp:	Bitu PR0B;
src/hardware/vga_paradise.cpp:	Bitu PR1;
src/hardware/vga_paradise.cpp:	Bitu PR2;
src/hardware/vga_paradise.cpp:	Bitu PR3;
src/hardware/vga_paradise.cpp:	Bitu PR4;
src/hardware/vga_paradise.cpp:	Bitu PR5;
src/hardware/vga_paradise.cpp:	Bitu clockFreq[4];
src/hardware/vga_paradise.cpp:	Bitu biosMode;
src/hardware/vga_paradise.cpp:void write_p3cf_pvga1a(Bitu reg,Bitu val,Bitu iolen) {
src/hardware/vga_paradise.cpp:Bitu read_p3cf_pvga1a(Bitu reg,Bitu iolen) {
src/hardware/vga_paradise.cpp:void FinishSetMode_PVGA1A(Bitu /*crtc_base*/, VGA_ModeExtraData* modeData) {
src/hardware/vga_paradise.cpp:	Bitu oldlock = IO_Read(0x3cf);
src/hardware/vga_paradise.cpp:void SetClock_PVGA1A(Bitu which,Bitu target) {
src/hardware/vga_paradise.cpp:Bitu GetClock_PVGA1A() {
src/hardware/vga_paradise.cpp:bool AcceptsMode_PVGA1A(Bitu mode) {
Binary file src/hardware/vga_crtc.o matches
Binary file src/hardware/dma.o matches
src/hardware/vga_attr.cpp:			for (Bitu i=0;i<64;i++) {
src/hardware/vga_attr.cpp:			for (Bitu i=0;i<64;i++) {
src/hardware/vga_attr.cpp:			for (Bitu i=0;i<64;i++) {
src/hardware/vga_attr.cpp:Bitu read_p3c0(Bitu /*port*/,Bitu /*iolen*/) {
src/hardware/vga_attr.cpp:	Bitu retval = attr(index) & 0x1f;
src/hardware/vga_attr.cpp:void write_p3c0(Bitu /*port*/,Bitu val,Bitu iolen) {
src/hardware/vga_attr.cpp:			Bitu difference = attr(mode_control)^val;
src/hardware/vga_attr.cpp:Bitu read_p3c1(Bitu /*port*/,Bitu iolen) {
Binary file src/hardware/vga_s3.o matches
src/hardware/pcspeaker.cpp:	Bitu pit_mode;
src/hardware/pcspeaker.cpp:	Bitu rate;
src/hardware/pcspeaker.cpp:	Bitu last_ticks;
src/hardware/pcspeaker.cpp:	Bitu min_tr;
src/hardware/pcspeaker.cpp:	Bitu used;
src/hardware/pcspeaker.cpp:void PCSPEAKER_SetCounter(Bitu cntr,Bitu mode) {
src/hardware/pcspeaker.cpp:void PCSPEAKER_SetType(Bitu mode) {
src/hardware/pcspeaker.cpp:static void PCSPEAKER_CallBack(Bitu len) {
src/hardware/pcspeaker.cpp:	Bitu count=len;
src/hardware/pcspeaker.cpp:	Bitu pos=0;
src/hardware/pcspeaker.cpp:	Bitu test_ticks = PIC_Ticks;
src/hardware/dbopl.cpp:static inline Bits MakeVolume( Bitu wave, Bitu volume ) {
src/hardware/dbopl.cpp:	Bitu total = wave + volume;
src/hardware/dbopl.cpp:	Bitu index = total & 0xff;
src/hardware/dbopl.cpp:	Bitu sig = ExpTable[ index ];
src/hardware/dbopl.cpp:	Bitu exp = total >> 8;
src/hardware/dbopl.cpp:static Bits DB_FASTCALL WaveForm0( Bitu i, Bitu volume ) {
src/hardware/dbopl.cpp:	Bitu wave = SinTable[i & 511];
src/hardware/dbopl.cpp:static Bits DB_FASTCALL WaveForm1( Bitu i, Bitu volume ) {
src/hardware/dbopl.cpp:static Bits DB_FASTCALL WaveForm2( Bitu i, Bitu volume ) {
src/hardware/dbopl.cpp:	Bitu wave = SinTable[i & 511];
src/hardware/dbopl.cpp:static Bits DB_FASTCALL WaveForm3( Bitu i, Bitu volume ) {
src/hardware/dbopl.cpp:	Bitu wave = SinTable[i & 255];
src/hardware/dbopl.cpp:static Bits DB_FASTCALL WaveForm4( Bitu i, Bitu volume ) {
src/hardware/dbopl.cpp:	Bitu wave = SinTable[i & 511];
src/hardware/dbopl.cpp:static Bits DB_FASTCALL WaveForm5( Bitu i, Bitu volume ) {
src/hardware/dbopl.cpp:	Bitu wave = SinTable[i & 511];
src/hardware/dbopl.cpp:static Bits DB_FASTCALL WaveForm6( Bitu i, Bitu volume ) {
src/hardware/dbopl.cpp:static Bits DB_FASTCALL WaveForm7( Bitu i, Bitu volume ) {
src/hardware/dbopl.cpp:	Bitu wave = (i << 3);
src/hardware/dbopl.cpp:INLINE Bitu Operator::ForwardVolume() {
src/hardware/dbopl.cpp:INLINE Bitu Operator::ForwardWave() {
src/hardware/dbopl.cpp:INLINE Bits Operator::GetWave( Bitu index, Bitu vol ) {
src/hardware/dbopl.cpp:	Bitu vol = ForwardVolume();
src/hardware/dbopl.cpp:		Bitu index = ForwardWave();
src/hardware/dbopl.cpp:	Bitu change = (chanData ^ ( val << 8 ) ) & 0x1f00;
src/hardware/dbopl.cpp:	for ( Bitu i = 0; i < samples; i++ ) {
src/hardware/dbopl.cpp:	Bitu count = noiseCounter >> LFO_SH;
src/hardware/dbopl.cpp:	Bitu index;
src/hardware/dbopl.cpp:void Chip::GenerateBlock2( Bitu total, Bit32s* output ) {
src/hardware/dbopl.cpp:void Chip::GenerateBlock3( Bitu total, Bit32s* output  ) {
src/hardware/dbopl.cpp:	for ( Bitu i = 0; i < 32; i++ ) {
src/hardware/dbopl.cpp:		Bitu index = i & 0xf;
src/hardware/dbopl.cpp:		Bitu blah = reinterpret_cast<Bitu>( &(chip->chan[ index ]) );
src/hardware/dbopl.cpp:	for ( Bitu i = 0; i < 64; i++ ) {
src/hardware/dbopl.cpp:		Bitu chNum = (i / 8) * 3 + (i % 8) % 3;
src/hardware/dbopl.cpp:		Bitu opNum = ( i % 8 ) / 3;
src/hardware/dbopl.cpp:		Bitu blah = reinterpret_cast<Bitu>( &(chan->op[opNum]) );
src/hardware/dbopl.cpp:	for ( Bitu i = 0; i < 18; i++ ) {
src/hardware/dbopl.cpp:		for ( Bitu c = 0; c < 32; c++ ) {
src/hardware/dbopl.cpp:	for ( Bitu i = 0; i < 36; i++ ) {
src/hardware/dbopl.cpp:		for ( Bitu c = 0; c < 64; c++ ) {
src/hardware/dbopl.cpp:void Handler::Generate( MixerChannel* chan, Bitu samples ) {
src/hardware/dbopl.cpp:void Handler::Init( Bitu rate ) {
src/hardware/vga_draw.cpp:typedef Bit8u * (* VGA_Line_Handler)(Bitu vidstart, Bitu line);
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_1BPP_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	for (Bitu x=vga.draw.blocks;x>0;x--, vidstart++) {
src/hardware/vga_draw.cpp:		Bitu val = base[(vidstart & (8 * 1024 -1))];
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_2BPP_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	for (Bitu x=0;x<vga.draw.blocks;x++) {
src/hardware/vga_draw.cpp:		Bitu val = base[vidstart & vga.tandy.addr_mask];
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_2BPPHiRes_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	for (Bitu x=0;x<vga.draw.blocks;x++) {
src/hardware/vga_draw.cpp:		Bitu val1 = base[vidstart & vga.tandy.addr_mask];
src/hardware/vga_draw.cpp:		Bitu val2 = base[vidstart & vga.tandy.addr_mask];
src/hardware/vga_draw.cpp:static Bitu temp[643]={0};
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_CGA16_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	for(Bitu x = 2; x < 640; x+=2) {
src/hardware/vga_draw.cpp:	Bitu i = 2;
src/hardware/vga_draw.cpp:	for (Bitu x=0;x<vga.draw.blocks;x++) {
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_4BPP_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	Bitu end = vga.draw.blocks*2;
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_4BPP_Line_Double(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	Bitu end = vga.draw.blocks;
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_Changes_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	Bitu checkMask = vga.changes.checkMask;
src/hardware/vga_draw.cpp:	Bitu start = (vidstart >> VGA_CHANGE_SHIFT);
src/hardware/vga_draw.cpp:	Bitu end = ((vidstart + vga.draw.line_length ) >> VGA_CHANGE_SHIFT);
src/hardware/vga_draw.cpp:			Bitu offset = vidstart & vga.draw.linear_mask;
src/hardware/vga_draw.cpp:			if (GCC_UNLIKELY( ((Bitu)ret) & (sizeof(Bitu)-1)) ) {
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_Linear_Line(Bitu vidstart, Bitu /*line*/) {
src/hardware/vga_draw.cpp:	Bitu offset = vidstart & vga.draw.linear_mask;
src/hardware/vga_draw.cpp:		Bitu end = (offset + vga.draw.line_length) & vga.draw.linear_mask;
src/hardware/vga_draw.cpp:		Bitu wrapped_len = end & 0xFFF;
src/hardware/vga_draw.cpp:		Bitu unwrapped_len = vga.draw.line_length-wrapped_len;
src/hardware/vga_draw.cpp:	if (GCC_UNLIKELY( ((Bitu)ret) & (sizeof(Bitu)-1)) ) {
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_Xlat16_Linear_Line(Bitu vidstart, Bitu /*line*/) {
src/hardware/vga_draw.cpp:	Bitu offset = vidstart & vga.draw.linear_mask;
src/hardware/vga_draw.cpp:		Bitu end = (offset + vga.draw.line_length) & vga.draw.linear_mask;
src/hardware/vga_draw.cpp:		Bitu wrapped_len = end & 0xFFF;
src/hardware/vga_draw.cpp:		Bitu unwrapped_len = vga.draw.line_length-wrapped_len;
src/hardware/vga_draw.cpp:		for(Bitu i = 0; i < unwrapped_len; i++)
src/hardware/vga_draw.cpp:		for(Bitu i = 0; i < wrapped_len; i++)
src/hardware/vga_draw.cpp:		for(Bitu i = 0; i < vga.draw.line_length; i++) {
src/hardware/vga_draw.cpp:/* static Bit8u * VGA_Draw_Chain_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	Bitu i = 0;
src/hardware/vga_draw.cpp:		Bitu addr = vidstart + i;
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_VGA_Line_HWMouse( Bitu vidstart, Bitu /*line*/) {
src/hardware/vga_draw.cpp:	Bitu lineat = (vidstart-(vga.config.real_start<<2)) / vga.draw.width;
src/hardware/vga_draw.cpp:		Bitu sourceStartBit = ((lineat - vga.s3.hgc.originy) + vga.s3.hgc.posy)*64 + vga.s3.hgc.posx; 
src/hardware/vga_draw.cpp:		Bitu cursorMemStart = ((sourceStartBit >> 2)& ~1) + (((Bit32u)vga.s3.hgc.startaddr) << 10);
src/hardware/vga_draw.cpp:		Bitu cursorStartBit = sourceStartBit & 0x7;
src/hardware/vga_draw.cpp:		Bitu cursorMemEnd = cursorMemStart + ((64-vga.s3.hgc.posx) >> 2);
src/hardware/vga_draw.cpp:		for (Bitu m = cursorMemStart; m < cursorMemEnd; (m&1)?(m+=3):m++) {
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_LIN16_Line_HWMouse(Bitu vidstart, Bitu /*line*/) {
src/hardware/vga_draw.cpp:	Bitu lineat = ((vidstart-(vga.config.real_start<<2)) >> 1) / vga.draw.width;
src/hardware/vga_draw.cpp:		Bitu sourceStartBit = ((lineat - vga.s3.hgc.originy) + vga.s3.hgc.posy)*64 + vga.s3.hgc.posx; 
src/hardware/vga_draw.cpp: 		Bitu cursorMemStart = ((sourceStartBit >> 2)& ~1) + (((Bit32u)vga.s3.hgc.startaddr) << 10);
src/hardware/vga_draw.cpp:		Bitu cursorStartBit = sourceStartBit & 0x7;
src/hardware/vga_draw.cpp:		Bitu cursorMemEnd = cursorMemStart + ((64-vga.s3.hgc.posx) >> 2);
src/hardware/vga_draw.cpp:		for (Bitu m = cursorMemStart; m < cursorMemEnd; (m&1)?(m+=3):m++) {
src/hardware/vga_draw.cpp:static Bit8u * VGA_Draw_LIN32_Line_HWMouse(Bitu vidstart, Bitu /*line*/) {
src/hardware/vga_draw.cpp:	Bitu lineat = ((vidstart-(vga.config.real_start<<2)) >> 2) / vga.draw.width;
src/hardware/vga_draw.cpp:		Bitu sourceStartBit = ((lineat - vga.s3.hgc.originy) + vga.s3.hgc.posy)*64 + vga.s3.hgc.posx; 
src/hardware/vga_draw.cpp:		Bitu cursorMemStart = ((sourceStartBit >> 2)& ~1) + (((Bit32u)vga.s3.hgc.startaddr) << 10);
src/hardware/vga_draw.cpp:		Bitu cursorStartBit = sourceStartBit & 0x7;
src/hardware/vga_draw.cpp:		Bitu cursorMemEnd = cursorMemStart + ((64-vga.s3.hgc.posx) >> 2);
src/hardware/vga_draw.cpp:		for (Bitu m = cursorMemStart; m < cursorMemEnd; (m&1)?(m+=3):m++) {
src/hardware/vga_draw.cpp:static const Bit8u* VGA_Text_Memwrap(Bitu vidstart) {
src/hardware/vga_draw.cpp:	Bitu line_end = 2 * vga.draw.blocks;
src/hardware/vga_draw.cpp:		Bitu break_pos = (vga.draw.linear_mask - vidstart) + 1;
src/hardware/vga_draw.cpp:static Bit8u * VGA_TEXT_Draw_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	for (Bitu cx=0;cx<vga.draw.blocks;cx++) {
src/hardware/vga_draw.cpp:		Bitu chr=vidmem[cx*2];
src/hardware/vga_draw.cpp:		Bitu col=vidmem[cx*2+1];
src/hardware/vga_draw.cpp:		Bitu font=vga.draw.font_tables[(col >> 3)&1][chr*32+line];
src/hardware/vga_draw.cpp:static Bit8u * VGA_TEXT_Herc_Draw_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	for (Bitu cx=0;cx<vga.draw.blocks;cx++) {
src/hardware/vga_draw.cpp:		Bitu chr=vidmem[cx*2];
src/hardware/vga_draw.cpp:		Bitu attrib=vidmem[cx*2+1];
src/hardware/vga_draw.cpp:				if (((Bitu)(vga.crtc.underline_location&0x1f)==line) && ((attrib&0x77)==0x1)) underline=true;
src/hardware/vga_draw.cpp:				Bitu font=vga.draw.font_tables[0][chr*32+line];
src/hardware/vga_draw.cpp:static Bit8u* VGA_TEXT_Draw_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	Bitu blocks = vga.draw.blocks;
src/hardware/vga_draw.cpp:		Bitu chr = *vidmem++;
src/hardware/vga_draw.cpp:		Bitu attr = *vidmem++;
src/hardware/vga_draw.cpp:		Bitu font = vga.draw.font_tables[(attr >> 3)&1][(chr<<5)+line];
src/hardware/vga_draw.cpp:		Bitu background = attr >> 4;
src/hardware/vga_draw.cpp:		Bitu foreground = (vga.draw.blink || (!(attr&0x80)))?
src/hardware/vga_draw.cpp:			for (Bitu n = 0; n < 9; n++) {
src/hardware/vga_draw.cpp:			for (Bitu n = 0; n < 8; n++) {
src/hardware/vga_draw.cpp:			Bitu index = attr_addr * (vga.draw.char9dot? 9:8);
src/hardware/vga_draw.cpp:			Bitu foreground = vga.tandy.draw_base[vga.draw.cursor.address+1] & 0xf;
src/hardware/vga_draw.cpp:			for (Bitu i = 0; i < 8; i++) {
src/hardware/vga_draw.cpp:static Bit8u* VGA_TEXT_Xlat16_Draw_Line(Bitu vidstart, Bitu line) {
src/hardware/vga_draw.cpp:	Bitu blocks = vga.draw.blocks;
src/hardware/vga_draw.cpp:		Bitu chr = *vidmem++;
src/hardware/vga_draw.cpp:		Bitu attr = *vidmem++;
src/hardware/vga_draw.cpp:		Bitu font = vga.draw.font_tables[(attr >> 3)&1][(chr<<5)+line];
src/hardware/vga_draw.cpp:		Bitu background = attr >> 4;
src/hardware/vga_draw.cpp:		Bitu foreground = (vga.draw.blink || (!(attr&0x80)))?
src/hardware/vga_draw.cpp:			for (Bitu n = 0; n < 9; n++) {
src/hardware/vga_draw.cpp:			for (Bitu n = 0; n < 8; n++) {
src/hardware/vga_draw.cpp:			Bitu index = attr_addr * (vga.draw.char9dot? 18:16);
src/hardware/vga_draw.cpp:			Bitu foreground = vga.tandy.draw_base[vga.draw.cursor.address+1] & 0xf;
src/hardware/vga_draw.cpp:			for (Bitu i = 0; i < 8; i++) {
src/hardware/vga_draw.cpp:		Bitu end = vga.draw.address >> VGA_CHANGE_SHIFT;
src/hardware/vga_draw.cpp:		Bitu total = 4 + end - vga.changes.start;
src/hardware/vga_draw.cpp:static void VGA_DrawSingleLine(Bitu /*blah*/) {
src/hardware/vga_draw.cpp:				for(Bitu i = 0; i < 256; i++)
src/hardware/vga_draw.cpp:			for (Bitu i = 0; i < sizeof(TempLine)/2; i++) {
src/hardware/vga_draw.cpp:static void VGA_DrawEGASingleLine(Bitu /*blah*/) {
src/hardware/vga_draw.cpp:		Bitu address = vga.draw.address;
src/hardware/vga_draw.cpp:static void VGA_DrawPart(Bitu lines) {
src/hardware/vga_draw.cpp:void VGA_SetBlinking(Bitu enabled) {
src/hardware/vga_draw.cpp:	Bitu b;
src/hardware/vga_draw.cpp:	for (Bitu i=0;i<8;i++) TXT_BG_Table[i+8]=(b+i) | ((b+i) << 8)| ((b+i) <<16) | ((b+i) << 24);
src/hardware/vga_draw.cpp:static void VGA_VertInterrupt(Bitu /*val*/) {
src/hardware/vga_draw.cpp:static void VGA_Other_VertInterrupt(Bitu val) {
src/hardware/vga_draw.cpp:static void VGA_DisplayStartLatch(Bitu /*val*/) {
src/hardware/vga_draw.cpp:static void VGA_PanningLatch(Bitu /*val*/) {
src/hardware/vga_draw.cpp:static void VGA_VerticalTimer(Bitu /*val*/) {
src/hardware/vga_draw.cpp:		vga.draw.split_line = (Bitu)((vga.config.line_compare+1)/vga.draw.lines_scaled);
src/hardware/vga_draw.cpp:void VGA_SetupDrawing(Bitu /*val*/) {
src/hardware/vga_draw.cpp:	double fps; Bitu clock;
src/hardware/vga_draw.cpp:	Bitu htotal, hdend, hbstart, hbend, hrstart, hrend;
src/hardware/vga_draw.cpp:	Bitu vtotal, vdend, vbstart, vbend, vrstart, vrend;
src/hardware/vga_draw.cpp:	Bitu vblank_skip;
src/hardware/vga_draw.cpp:	Bitu sync = vga.misc_output >> 6;
src/hardware/vga_draw.cpp:	Bitu width=hdend;
src/hardware/vga_draw.cpp:	Bitu height=vdend;
src/hardware/vga_draw.cpp:	Bitu bpp;
Binary file src/hardware/sblaster.o matches
src/hardware/vga_crtc.cpp:void vga_write_p3d5(Bitu port,Bitu val,Bitu iolen);
src/hardware/vga_crtc.cpp:Bitu DEBUG_EnableDebugger(void);
src/hardware/vga_crtc.cpp:void vga_write_p3d4(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_crtc.cpp:Bitu vga_read_p3d4(Bitu port,Bitu iolen) {
src/hardware/vga_crtc.cpp:void vga_write_p3d5(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_crtc.cpp:Bitu vga_read_p3d5(Bitu port,Bitu iolen) {
src/hardware/pic.cpp:	Bitu icw_words;
src/hardware/pic.cpp:	Bitu icw_index;
src/hardware/pic.cpp:Bitu PIC_Ticks = 0;
src/hardware/pic.cpp:Bitu PIC_IRQCheck = 0; //Maybe make it a bool and/or ensure 32bit size (x86 dynamic core seems to assume 32 bit variable size)
src/hardware/pic.cpp:	Bitu value;
src/hardware/pic.cpp:static void write_command(Bitu port,Bitu val,Bitu iolen) {
src/hardware/pic.cpp:static void write_data(Bitu port,Bitu val,Bitu iolen) {
src/hardware/pic.cpp:static Bitu read_command(Bitu port,Bitu iolen) {
src/hardware/pic.cpp:static Bitu read_data(Bitu port,Bitu iolen) {
src/hardware/pic.cpp:void PIC_ActivateIRQ(Bitu irq) {
src/hardware/pic.cpp:	Bitu t = irq>7 ? (irq - 8): irq;
src/hardware/pic.cpp:void PIC_DeActivateIRQ(Bitu irq) {
src/hardware/pic.cpp:	Bitu t = irq>7 ? (irq - 8): irq;
src/hardware/pic.cpp:static void inline master_startIRQ(Bitu i){
src/hardware/pic.cpp:void PIC_SetIRQMask(Bitu irq, bool masked) {
src/hardware/pic.cpp:	Bitu t = irq>7 ? (irq - 8): irq;
src/hardware/pic.cpp:void PIC_AddEvent(PIC_EventHandler handler,float delay,Bitu val) {
src/hardware/pic.cpp:void PIC_RemoveSpecificEvents(PIC_EventHandler handler, Bitu val) {
src/hardware/pic.cpp:		Bitu i;
src/hardware/tandy_sound.cpp:	Bitu last_write;
src/hardware/tandy_sound.cpp:			Bitu base;
src/hardware/tandy_sound.cpp:			Bitu rate;
src/hardware/tandy_sound.cpp:static void SN76496Write(Bitu /*port*/,Bitu data,Bitu /*iolen*/) {
src/hardware/tandy_sound.cpp:static void SN76496Update(Bitu length) {
src/hardware/tandy_sound.cpp:	Bitu count=length;
src/hardware/tandy_sound.cpp:bool TS_Get_Address(Bitu& tsaddr, Bitu& tsirq, Bitu& tsdma) {
src/hardware/tandy_sound.cpp:			tandy.dac.chan->SetFreq((Bitu)freq);
src/hardware/tandy_sound.cpp:static void TandyDACWrite(Bitu port,Bitu data,Bitu /*iolen*/) {
src/hardware/tandy_sound.cpp:		Bitu oldmode = tandy.dac.mode;
src/hardware/tandy_sound.cpp:static Bitu TandyDACRead(Bitu port,Bitu /*iolen*/) {
src/hardware/tandy_sound.cpp:static void TandyDACGenerateDMASound(Bitu length) {
src/hardware/tandy_sound.cpp:		Bitu read=tandy.dac.dma.chan->Read(length,tandy.dac.dma.buf);
src/hardware/tandy_sound.cpp:			for (Bitu ct=read; ct < length; ct++) {
src/hardware/tandy_sound.cpp:static void TandyDACUpdate(Bitu length) {
src/hardware/tandy_sound.cpp:			Bitu len = length;
src/hardware/tandy_sound.cpp:			for (Bitu ct=0; ct < length; ct++) {
src/hardware/tandy_sound.cpp:		Bitu sbport, sbirq, sbdma;
src/hardware/tandy_sound.cpp:		Bitu i;
Binary file src/hardware/vga_gfx.o matches
src/hardware/keyboard.cpp:	Bitu used;
src/hardware/keyboard.cpp:	Bitu pos;
src/hardware/keyboard.cpp:		Bitu wait;
src/hardware/keyboard.cpp:		Bitu pause,rate;
src/hardware/keyboard.cpp:static void KEYBOARD_TransferBuffer(Bitu val) {
src/hardware/keyboard.cpp:	Bitu start=keyb.pos+keyb.used;
src/hardware/keyboard.cpp:static Bitu read_p60(Bitu port,Bitu iolen) {
src/hardware/keyboard.cpp:static void write_p60(Bitu port,Bitu val,Bitu iolen) {
src/hardware/keyboard.cpp:static Bitu read_p61(Bitu port,Bitu iolen) {
src/hardware/keyboard.cpp:static void write_p61(Bitu port,Bitu val,Bitu iolen) {
src/hardware/keyboard.cpp:static void write_p64(Bitu port,Bitu val,Bitu iolen) {
src/hardware/keyboard.cpp:static Bitu read_p64(Bitu port,Bitu iolen) {
src/hardware/memory.cpp:	Bitu used;
src/hardware/memory.cpp:	Bitu pages;
src/hardware/memory.cpp:		Bitu		start_page;
src/hardware/memory.cpp:		Bitu		end_page;
src/hardware/memory.cpp:		Bitu		pages;
src/hardware/memory.cpp:	Bitu readb(PhysPt addr) {
src/hardware/memory.cpp:	void writeb(PhysPt addr,Bitu val) {
src/hardware/memory.cpp:	HostPt GetHostReadPt(Bitu phys_page) {
src/hardware/memory.cpp:	HostPt GetHostWritePt(Bitu phys_page) {
src/hardware/memory.cpp:	void writeb(PhysPt addr,Bitu val){
src/hardware/memory.cpp:	void writew(PhysPt addr,Bitu val){
src/hardware/memory.cpp:	void writed(PhysPt addr,Bitu val){
src/hardware/memory.cpp:void MEM_SetLFB(Bitu page, Bitu pages, PageHandler *handler, PageHandler *mmiohandler) {
src/hardware/memory.cpp:PageHandler * MEM_GetPageHandler(Bitu phys_page) {
src/hardware/memory.cpp:void MEM_SetPageHandler(Bitu phys_page,Bitu pages,PageHandler * handler) {
src/hardware/memory.cpp:void MEM_ResetPageHandler(Bitu phys_page, Bitu pages) {
src/hardware/memory.cpp:Bitu mem_strlen(PhysPt pt) {
src/hardware/memory.cpp:	Bitu x=0;
src/hardware/memory.cpp:void mem_memcpy(PhysPt dest,PhysPt src,Bitu size) {
src/hardware/memory.cpp:void MEM_BlockRead(PhysPt pt,void * data,Bitu size) {
src/hardware/memory.cpp:void MEM_BlockWrite(PhysPt pt,void const * const data,Bitu size) {
src/hardware/memory.cpp:void MEM_BlockCopy(PhysPt dest,PhysPt src,Bitu size) {
src/hardware/memory.cpp:void MEM_StrCopy(PhysPt pt,char * data,Bitu size) {
src/hardware/memory.cpp:Bitu MEM_TotalPages(void) {
src/hardware/memory.cpp:Bitu MEM_FreeLargest(void) {
src/hardware/memory.cpp:	Bitu size=0;Bitu largest=0;
src/hardware/memory.cpp:	Bitu index=XMS_START;	
src/hardware/memory.cpp:Bitu MEM_FreeTotal(void) {
src/hardware/memory.cpp:	Bitu free=0;
src/hardware/memory.cpp:	Bitu index=XMS_START;	
src/hardware/memory.cpp:Bitu MEM_AllocatedPages(MemHandle handle) 
src/hardware/memory.cpp:	Bitu pages = 0;
src/hardware/memory.cpp:INLINE Bitu BestMatch(Bitu size) {
src/hardware/memory.cpp:	Bitu index=XMS_START;	
src/hardware/memory.cpp:	Bitu first=0;
src/hardware/memory.cpp:	Bitu best=0xfffffff;
src/hardware/memory.cpp:	Bitu best_first=0;
src/hardware/memory.cpp:				Bitu pages=index-first;
src/hardware/memory.cpp:MemHandle MEM_AllocatePages(Bitu pages,bool sequence) {
src/hardware/memory.cpp:		Bitu index=BestMatch(pages);
src/hardware/memory.cpp:			Bitu index=BestMatch(1);
src/hardware/memory.cpp:bool MEM_ReAllocatePages(MemHandle & handle,Bitu pages,bool sequence) {
src/hardware/memory.cpp:	MemHandle last;Bitu old_pages=0;
src/hardware/memory.cpp:		Bitu need=pages-old_pages;
src/hardware/memory.cpp:			Bitu free=0;
src/hardware/memory.cpp:MemHandle MEM_NextHandleAt(MemHandle handle,Bitu where) {
src/hardware/memory.cpp:	Bitu phys_base=enabled ? (1024/4) : 0;
src/hardware/memory.cpp:	for (Bitu i=0;i<16;i++) PAGING_MapPage((1024/4)+i,phys_base+i);
src/hardware/memory.cpp:static void write_p92(Bitu port,Bitu val,Bitu iolen) {	
src/hardware/memory.cpp:static Bitu read_p92(Bitu port,Bitu iolen) {
src/hardware/memory.cpp:	for (Bitu ct=0xe0;ct<0xf0;ct++) {
src/hardware/memory.cpp:	for (Bitu ct=0xd0;ct<0xe0;ct++) {
src/hardware/memory.cpp:		Bitu i;
src/hardware/memory.cpp:		Bitu memsize=section->Get_int("memsize");
src/hardware/pci_bus.cpp:static Bitu pci_devices_installed=0;	// number of registered PCI devices
src/hardware/pci_bus.cpp:static void write_pci_addr(Bitu port,Bitu val,Bitu iolen) {
src/hardware/pci_bus.cpp:static void write_pci(Bitu port,Bitu val,Bitu iolen) {
src/hardware/pci_bus.cpp:static Bitu read_pci_addr(Bitu port,Bitu iolen) {
src/hardware/pci_bus.cpp:static Bitu read_pci(Bitu port,Bitu iolen) {
src/hardware/pci_bus.cpp:static Bitu PCI_PM_Handler() {
src/hardware/pci_bus.cpp:	for (Bitu dct=0;dct<PCI_MAX_PCIFUNCTIONS-1;dct++) subdevices[dct]=0;
src/hardware/pci_bus.cpp:void PCI_Device::SetPCIId(Bitu number, Bits subfct) {
src/hardware/pci_bus.cpp:static const Bitu max_rqueued_devices=16;
src/hardware/pci_bus.cpp:static Bitu num_rqueued_devices=0;
src/hardware/pci_bus.cpp:		for (Bitu ct=0;ct<4;ct++) {
src/hardware/pci_bus.cpp:		for (Bitu dev=0; dev<PCI_MAX_PCIDEVICES; dev++)
src/hardware/pci_bus.cpp:			for (Bitu fct=0; fct<PCI_MAX_PCIFUNCTIONS-1; fct++)
src/hardware/pci_bus.cpp:				for (Bitu reg=0; reg<256; reg++)
src/hardware/pci_bus.cpp:		for (Bitu dev=0; dev<PCI_MAX_PCIDEVICES; dev++)
src/hardware/pci_bus.cpp:			for (Bitu fct=0; fct<PCI_MAX_PCIFUNCTIONS-1; fct++)
src/hardware/pci_bus.cpp:				for (Bitu reg=0; reg<256; reg++)
src/hardware/pci_bus.cpp:		for (Bitu ct=0;ct<4;ct++) {
src/hardware/pci_bus.cpp:		for (Bitu dct=0;dct<pci_devices_installed;dct++) {
src/hardware/pci_bus.cpp:					for (Bitu sct=1;sct<PCI_MAX_PCIFUNCTIONS;sct++) {
src/hardware/pci_bus.cpp:		for (Bitu dct=0;dct<PCI_MAX_PCIDEVICES;dct++) {
src/hardware/pci_bus.cpp:		Bitu last_active_device=PCI_MAX_PCIDEVICES;
src/hardware/pci_bus.cpp:		for (Bitu dct=0;dct<PCI_MAX_PCIDEVICES;dct++) {
src/hardware/pci_bus.cpp:		for (Bitu devct=0;devct<PCI_MAX_PCIDEVICES;devct++)
src/hardware/pci_bus.cpp:			for (Bitu dct=0;dct<num_rqueued_devices;dct++) {
Binary file src/hardware/timer.o matches
Binary file src/hardware/mixer.o matches
Binary file src/hardware/gus.o matches
src/hardware/vga_misc.cpp:void vga_write_p3d4(Bitu port,Bitu val,Bitu iolen);
src/hardware/vga_misc.cpp:Bitu vga_read_p3d4(Bitu port,Bitu iolen);
src/hardware/vga_misc.cpp:void vga_write_p3d5(Bitu port,Bitu val,Bitu iolen);
src/hardware/vga_misc.cpp:Bitu vga_read_p3d5(Bitu port,Bitu iolen);
src/hardware/vga_misc.cpp:Bitu vga_read_p3da(Bitu port,Bitu iolen) {
src/hardware/vga_misc.cpp:static void write_p3c2(Bitu port,Bitu val,Bitu iolen) {
src/hardware/vga_misc.cpp:	Bitu base=(val & 0x1) ? 0x3d0 : 0x3b0;
src/hardware/vga_misc.cpp:	Bitu free=(val & 0x1) ? 0x3b0 : 0x3d0;
src/hardware/vga_misc.cpp:	Bitu first=2, last=2;
src/hardware/vga_misc.cpp:	for (Bitu i=first; i<=last; i++) {
src/hardware/vga_misc.cpp:static Bitu read_p3cc(Bitu port,Bitu iolen) {
src/hardware/vga_misc.cpp:static Bitu read_p3ca(Bitu port,Bitu iolen) {
src/hardware/vga_misc.cpp:static Bitu read_p3c8(Bitu port,Bitu iolen) {
src/hardware/vga_misc.cpp:static Bitu read_p3c2(Bitu port,Bitu iolen) {
src/dosbox.cpp.orig:static Bitu Normal_Loop(void) {
src/dosbox.cpp.orig:				Bitu blah = (*CallBack_Handlers[ret])();
src/dosbox.cpp.orig:	Bitu ret;
Binary file src/ints/mouse.o matches
src/ints/int10_vesa.cpp:	Bitu setwindow;
src/ints/int10_vesa.cpp:	Bitu pmStart;
src/ints/int10_vesa.cpp:	Bitu pmWindow;
src/ints/int10_vesa.cpp:	Bitu pmPalette;
src/ints/int10_vesa.cpp:	Bitu i;
src/ints/int10_vesa.cpp:	Bitu id=mem_readd(buffer);
src/ints/int10_vesa.cpp:	Bitu pageSize;
src/ints/int10_vesa.cpp:	Bitu i=0;
src/ints/int10_vesa.cpp:	Bitu pages = 0;
src/ints/int10_vesa.cpp:Bit8u VESA_SetPalette(PhysPt data,Bitu index,Bitu count) {
src/ints/int10_vesa.cpp:Bit8u VESA_GetPalette(PhysPt data,Bitu index,Bitu count) {
src/ints/int10_vesa.cpp:	Bitu pixels_per_offset;
src/ints/int10_vesa.cpp:	Bitu bytes_per_offset = 8;
src/ints/int10_vesa.cpp:	Bitu vmemsize = vga.vmemsize;
src/ints/int10_vesa.cpp:	Bitu new_offset = vga.config.scan_len;
src/ints/int10_vesa.cpp:	Bitu screen_height = CurMode->sheight;
src/ints/int10_vesa.cpp:	Bitu pixels_per_offset;
src/ints/int10_vesa.cpp:	Bitu panning_factor = 1;
src/ints/int10_vesa.cpp:	Bitu virtual_screen_width = vga.config.scan_len * pixels_per_offset;
src/ints/int10_vesa.cpp:	Bitu new_start_pixel = virtual_screen_width * y + x;
src/ints/int10_vesa.cpp:	Bitu new_crtc_start = new_start_pixel / (pixels_per_offset/2);
src/ints/int10_vesa.cpp:	Bitu new_panning = new_start_pixel % (pixels_per_offset/2);
src/ints/int10_vesa.cpp:	Bitu pixels_per_offset;
src/ints/int10_vesa.cpp:	Bitu panning_factor = 1;
src/ints/int10_vesa.cpp:	Bitu virtual_screen_width = vga.config.scan_len * pixels_per_offset;
src/ints/int10_vesa.cpp:	Bitu start_pixel = vga.config.display_start * (pixels_per_offset/2) 
src/ints/int10_vesa.cpp:static Bitu VESA_SetWindow(void) {
src/ints/int10_vesa.cpp:static Bitu VESA_PMSetWindow(void) {
src/ints/int10_vesa.cpp:static Bitu VESA_PMSetPalette(void) {
src/ints/int10_vesa.cpp:static Bitu VESA_PMSetStart(void) {
src/ints/int10_vesa.cpp:	Bitu i;
src/ints/int10_vesa.cpp:	Bitu len=(Bitu)(strlen(string_oem)+1);
src/ints/mouse.cpp:static Bitu call_int33,call_int74,int74_ret_callback,call_mouse_bd;
src/ints/mouse.cpp:static Bitu call_ps2;
src/ints/mouse.cpp:Bitu PS2_Handler(void) {
src/ints/mouse.cpp:void MOUSE_Limit_Events(Bitu /*val*/) {
src/ints/mouse.cpp:			for(Bitu i = mouse.events ; i ; i--)
src/ints/mouse.cpp:		Bitu rows = real_readb(BIOSMEM_SEG,BIOSMEM_NB_ROWS);
src/ints/mouse.cpp:static Bitu INT33_Handler(void) {
src/ints/mouse.cpp:static Bitu MOUSE_BD_Handler(void) {
src/ints/mouse.cpp:static Bitu INT74_Handler(void) {
src/ints/mouse.cpp:Bitu MOUSE_UserInt_CB_Handler(void) {
src/ints/xms.h:Bitu	XMS_QueryFreeMemory		(Bit16u& largestFree, Bit16u& totalFree);
src/ints/xms.h:Bitu	XMS_AllocateMemory		(Bitu size, Bit16u& handle);
src/ints/xms.h:Bitu	XMS_FreeMemory			(Bitu handle);
src/ints/xms.h:Bitu	XMS_MoveMemory			(PhysPt bpt);
src/ints/xms.h:Bitu	XMS_LockMemory			(Bitu handle, Bit32u& address);
src/ints/xms.h:Bitu	XMS_UnlockMemory		(Bitu handle);
src/ints/xms.h:Bitu	XMS_GetHandleInformation(Bitu handle, Bit8u& lockCount, Bit8u& numFree, Bit16u& size);
src/ints/xms.h:Bitu	XMS_ResizeMemory		(Bitu handle, Bitu newSize);
src/ints/xms.h:Bitu	XMS_EnableA20			(bool enable);
src/ints/xms.h:Bitu	XMS_GetEnabledA20		(void);
src/ints/bios_keyboard.cpp:static Bitu call_int16,call_irq1,call_irq6;
src/ints/bios_keyboard.cpp:static Bitu IRQ1_Handler(void) {
src/ints/bios_keyboard.cpp:	Bitu scancode=reg_al;	/* Read the code */
src/ints/bios_keyboard.cpp:static Bitu INT16_Handler(void) {
src/ints/int10_char.cpp:	Bitu copy=(cright-cleft);
src/ints/int10_char.cpp:	Bitu nextline=CurMode->twidth;
src/ints/int10_char.cpp:	for (Bitu i=0;i<cheight/2U;i++) {
src/ints/int10_char.cpp:	Bitu copy=(cright-cleft)*2;Bitu nextline=CurMode->twidth*2;
src/ints/int10_char.cpp:	for (Bitu i=0;i<cheight/2U;i++) {
src/ints/int10_char.cpp:	Bitu copy=(cright-cleft)*4;Bitu nextline=CurMode->twidth*4;
src/ints/int10_char.cpp:	for (Bitu i=0;i<cheight/banks;i++) {
src/ints/int10_char.cpp:		for (Bitu b=0;b<banks;b++) MEM_BlockCopy(dest+b*8*1024,src+b*8*1024,copy);
src/ints/int10_char.cpp:	PhysPt src,dest;Bitu copy;
src/ints/int10_char.cpp:	Bitu nextline=CurMode->twidth;
src/ints/int10_char.cpp:	Bitu rowsize=(cright-cleft);
src/ints/int10_char.cpp:		for (Bitu x=0;x<rowsize;x++) mem_writeb(dest+x,mem_readb(src+x));
src/ints/int10_char.cpp:	PhysPt src,dest;Bitu copy;
src/ints/int10_char.cpp:	Bitu nextline=8*CurMode->twidth;
src/ints/int10_char.cpp:	Bitu rowsize=8*(cright-cleft);
src/ints/int10_char.cpp:		for (Bitu x=0;x<rowsize;x++) mem_writeb(dest+x,mem_readb(src+x));
src/ints/int10_char.cpp:	Bitu copy=(cright-cleft);
src/ints/int10_char.cpp:	Bitu nextline=CurMode->twidth;
src/ints/int10_char.cpp:	for (Bitu i=0;i<cheight/2U;i++) {
src/ints/int10_char.cpp:		for (Bitu x=0;x<copy;x++) {
src/ints/int10_char.cpp:	Bitu copy=(cright-cleft)*2;Bitu nextline=CurMode->twidth*2;
src/ints/int10_char.cpp:	for (Bitu i=0;i<cheight/2U;i++) {
src/ints/int10_char.cpp:		for (Bitu x=0;x<copy;x++) {
src/ints/int10_char.cpp:	Bitu copy=(cright-cleft)*4;Bitu nextline=CurMode->twidth*4;
src/ints/int10_char.cpp:	for (Bitu i=0;i<cheight/banks;i++) {
src/ints/int10_char.cpp:		for (Bitu x=0;x<copy;x++) {
src/ints/int10_char.cpp:			for (Bitu b=0;b<banks;b++) mem_writeb(dest+b*8*1024+x,attr);
src/ints/int10_char.cpp:	Bitu nextline=CurMode->twidth;
src/ints/int10_char.cpp:	Bitu copy = cheight;Bitu rowsize=(cright-cleft);
src/ints/int10_char.cpp:		for (Bitu x=0;x<rowsize;x++) mem_writeb(dest+x,0xff);
src/ints/int10_char.cpp:	Bitu nextline=8*CurMode->twidth;
src/ints/int10_char.cpp:	Bitu copy = cheight;Bitu rowsize=8*(cright-cleft);
src/ints/int10_char.cpp:		for (Bitu x=0;x<rowsize;x++) mem_writeb(dest+x,attr);
src/ints/int10_char.cpp:			Bitu cpupage =
src/ints/int10_char.cpp:	Bitu x,y,pos = row*real_readw(BIOSMEM_SEG,BIOSMEM_NB_COLS)+col;
src/ints/int10_char.cpp:	Bitu x,y,pos = row*real_readw(BIOSMEM_SEG,BIOSMEM_NB_COLS)+col;
Binary file src/ints/int10_vptable.o matches
Binary file src/ints/int10_char.o matches
src/ints/int10_video_state.cpp:Bitu INT10_VideoState_GetSize(Bitu state) {
src/ints/int10_video_state.cpp:	Bitu size=0x20;
src/ints/int10_video_state.cpp:bool INT10_VideoState_Save(Bitu state,RealPt buffer) {
src/ints/int10_video_state.cpp:	Bitu ct;
src/ints/int10_video_state.cpp:	Bitu base_seg=RealSeg(buffer);
src/ints/int10_video_state.cpp:	Bitu base_dest=RealOff(buffer)+0x20;
src/ints/int10_video_state.cpp:		Bitu dac_state=IO_ReadB(0x3c7)&1;
src/ints/int10_video_state.cpp:		Bitu dac_windex=IO_ReadB(0x3c8);
src/ints/int10_video_state.cpp://		Bitu seq_8=IO_ReadB(0x3c5);
src/ints/int10_video_state.cpp:		Bitu ct_dest=0x13;
src/ints/int10_video_state.cpp:bool INT10_VideoState_Restore(Bitu state,RealPt buffer) {
src/ints/int10_video_state.cpp:	Bitu ct;
src/ints/int10_video_state.cpp:		Bitu dac_state=real_readb(base_seg,base_dest+0x000);
src/ints/int10_video_state.cpp:		Bitu seq_idx=IO_ReadB(0x3c4);
src/ints/int10_video_state.cpp://		Bitu seq_8=IO_ReadB(0x3c5);
src/ints/int10_video_state.cpp://		Bitu crtc_idx=IO_ReadB(0x3d4);
src/ints/int10_video_state.cpp:		Bitu ct_dest=0x13;
src/ints/int10_video_state.cpp:		Bitu sysval1=IO_ReadB(crt_reg+1);
src/ints/int10_video_state.cpp:		Bitu sysva2=IO_ReadB(crt_reg+1);
Binary file src/ints/xms.o matches
src/ints/int10_modes.cpp:	Bitu i=0;
src/ints/int10_modes.cpp:	Bitu crtc_base=machine==MCH_HERC ? 0x3b4 : 0x3d4;
src/ints/int10_modes.cpp:		for(Bitu i = 0; i < 16; i++) {
src/ints/int10_modes.cpp:	bool clearmem=true;Bitu i;
src/ints/int10_modes.cpp:	Bitu blank_end=(CurMode->htotal-2) & 0x7f;
src/ints/int10_modes.cpp:	Bitu ret_start;
src/ints/int10_modes.cpp:	Bitu ret_end;
src/ints/int10_modes.cpp:	Bitu vretrace;
src/ints/int10_modes.cpp:	Bitu vblank_trim;
src/ints/int10_modes.cpp:	Bitu line_compare=(CurMode->vtotal < 1024) ? 1023 : 2047;
src/ints/int10_modes.cpp:	Bitu offset;
src/ints/int10_modes.cpp:			Bitu clock=CurMode->vtotal*8*CurMode->htotal*70;
src/ints/int10_modes.cpp:		Bitu reg_50=S3_XGA_8BPP;
src/ints/int10_modes.cpp:Bitu VideoModeMemSize(Bitu mode) {
src/ints/int10_modes.cpp:	Bitu i=0;
Binary file src/ints/libints.a matches
src/ints/int10_memory.cpp:void INT10_LoadFont(PhysPt font,bool reload,Bitu count,Bitu offset,Bitu map,Bitu height) {
src/ints/int10_memory.cpp:	for (Bitu i=0;i<count;i++) {
src/ints/int10_memory.cpp:		while (Bitu chr=(Bitu)mem_readb(font++)) {
src/ints/int10_memory.cpp:		Bitu rows=CurMode->sheight/height;
src/ints/int10_memory.cpp:		Bitu vdend=rows*height*((CurMode->sheight==200)?2:1)-1;
src/ints/int10_memory.cpp:		Bitu pagesize=rows*real_readb(BIOSMEM_SEG,BIOSMEM_NB_COLS)*2;
src/ints/int10_memory.cpp:	Bitu map=0;
src/ints/int10_memory.cpp:	Bitu i;
src/ints/int10_memory.cpp:	for (Bitu i=0;i<256*16;i++) {
src/ints/int10_memory.cpp:	for (Bitu i=0;i<256*14;i++) {
src/ints/int10_memory.cpp:	for (Bitu i=0;i<128*8;i++) {
src/ints/int10_memory.cpp:	for (Bitu i=0;i<128*8;i++) {
src/ints/int10_memory.cpp:		Bitu last_rombyte = 32*1024 - 1;		//32 KB romsize
src/ints/int10_memory.cpp:		for (Bitu i = 0;i < last_rombyte;i++)
src/ints/int10_memory.cpp:		sum = (Bit8u)((256 - (Bitu)sum)&0xff);
Binary file src/ints/int10_vesa.o matches
src/ints/int10_misc.cpp:			if ((Bitu)ch+cl>regs) cl=(Bit8u)(regs-ch);
src/ints/int10_misc.cpp:			for (Bitu i=0; i<cl; i++) {
src/ints/int10_misc.cpp:			if ((Bitu)ch+cl>regs) cl=(Bit8u)(regs-ch);
src/ints/int10_misc.cpp:				for (Bitu i=0; i<cl; i++) {
src/ints/int10_misc.cpp:				for (Bitu i=0; i<cl; i++) {
Binary file src/ints/bios.o matches
src/ints/int10.h:	Bitu	swidth, sheight;
src/ints/int10.h:	Bitu	twidth, theight;
src/ints/int10.h:	Bitu	cwidth, cheight;
src/ints/int10.h:	Bitu	ptotal,pstart,plength;
src/ints/int10.h:	Bitu	htotal,vtotal;
src/ints/int10.h:	Bitu	hdispend,vdispend;
src/ints/int10.h:	Bitu	special;
src/ints/int10.h:void INT10_LoadFont(PhysPt font,bool reload,Bitu count,Bitu offset,Bitu map,Bitu height);
src/ints/int10.h:Bit8u VESA_SetPalette(PhysPt data,Bitu index,Bitu count);
src/ints/int10.h:Bit8u VESA_GetPalette(PhysPt data,Bitu index,Bitu count);
src/ints/int10.h:Bitu INT10_VideoState_GetSize(Bitu state);
src/ints/int10.h:bool INT10_VideoState_Save(Bitu state,RealPt buffer);
src/ints/int10.h:bool INT10_VideoState_Restore(Bitu state,RealPt buffer);
src/ints/bios_disk.cpp:Bitu call_int13;
src/ints/bios_disk.cpp:Bitu diskparm0, diskparm1;
src/ints/bios_disk.cpp:void CMOS_SetRegister(Bitu regNr, Bit8u val); //For setting equipment word
src/ints/bios_disk.cpp:		Bitu numofdisks = (equipment>>6)&3;
src/ints/bios_disk.cpp:	for(Bitu i=0;i<DOS_DRIVES;i++) {
src/ints/bios_disk.cpp:static Bitu INT13_DiskHandler(void) {
src/ints/bios_disk.cpp:	Bitu  i,t;
src/ints/xms.cpp:	Bitu	size;
src/ints/xms.cpp:Bitu XMS_EnableA20(bool enable) {
src/ints/xms.cpp:Bitu XMS_GetEnabledA20(void) {
src/ints/xms.cpp:static INLINE bool InvalidHandle(Bitu handle) {
src/ints/xms.cpp:Bitu XMS_QueryFreeMemory(Bit16u& largestFree, Bit16u& totalFree) {
src/ints/xms.cpp:Bitu XMS_AllocateMemory(Bitu size, Bit16u& handle) {	// size = kb
src/ints/xms.cpp:		Bitu pages=(size/4) + ((size & 3) ? 1 : 0);
src/ints/xms.cpp:Bitu XMS_FreeMemory(Bitu handle) {
src/ints/xms.cpp:Bitu XMS_MoveMemory(PhysPt bpt) {
src/ints/xms.cpp:	Bitu length=mem_readd(bpt+offsetof(XMS_MemMove,length));
src/ints/xms.cpp:	Bitu src_handle=mem_readw(bpt+offsetof(XMS_MemMove,src_handle));
src/ints/xms.cpp:	Bitu dest_handle=mem_readw(bpt+offsetof(XMS_MemMove,dest_handle));
src/ints/xms.cpp:Bitu XMS_LockMemory(Bitu handle, Bit32u& address) {
src/ints/xms.cpp:Bitu XMS_UnlockMemory(Bitu handle) {
src/ints/xms.cpp:Bitu XMS_GetHandleInformation(Bitu handle, Bit8u& lockCount, Bit8u& numFree, Bit16u& size) {
src/ints/xms.cpp:	for (Bitu i=1;i<XMS_HANDLES;i++) {
src/ints/xms.cpp:Bitu XMS_ResizeMemory(Bitu handle, Bitu newSize) {
src/ints/xms.cpp:	Bitu pages=newSize/4 + ((newSize & 3) ? 1 : 0);
src/ints/xms.cpp:INLINE void SET_RESULT(Bitu res,bool touch_bl_on_succes=true) {
src/ints/xms.cpp:Bitu XMS_Handler(void) {
src/ints/xms.cpp:		Bitu res = XMS_LockMemory(reg_dx, address);
src/ints/xms.cpp:		Bitu result = XMS_GetHandleInformation(reg_dx,reg_bh,free_handles,reg_dx);
src/ints/xms.cpp:Bitu GetEMSType(Section_prop * section);
src/ints/xms.cpp:		Bitu i;
src/ints/xms.cpp:		for (Bitu i = 1;i<XMS_HANDLES;i++) 
Binary file src/ints/bios_keyboard.o matches
Binary file src/ints/int10_video_state.o matches
Binary file src/ints/int10_memory.o matches
Binary file src/ints/int10_misc.o matches
Binary file src/ints/bios_disk.o matches
Binary file src/ints/ems.o matches
src/ints/bios.cpp.bak:void CMOS_SetRegister(Bitu regNr, Bit8u val); //For setting equipment word
src/ints/bios.cpp.bak:static Bitu INT70_Handler(void) {
src/ints/bios.cpp.bak:	Bitu sbport, sbirq, sbdma;
src/ints/bios.cpp.bak:	Bitu tsport, tsirq, tsdma;
src/ints/bios.cpp.bak:	Bitu length=real_readw(0x40,0xd0);
src/ints/bios.cpp.bak:static Bitu IRQ_TandyDAC(void) {
src/ints/bios.cpp.bak:		Bitu rb=real_readb(0x40,0xd3);
src/ints/bios.cpp.bak:static Bitu INT1A_Handler(void) {
src/ints/bios.cpp.bak:				Bitu devnr=0;
src/ints/bios.cpp.bak:				Bitu count=0x100;
src/ints/bios.cpp.bak:				for (Bitu i=0; i<=count; i++) {
src/ints/bios.cpp.bak:				Bitu devnr=0;
src/ints/bios.cpp.bak:				Bitu count=0x100;
src/ints/bios.cpp.bak:				for (Bitu i=0; i<=count; i++) {
src/ints/bios.cpp.bak:static Bitu INT11_Handler(void) {
src/ints/bios.cpp.bak:static Bitu INT8_Handler(void) {
src/ints/bios.cpp.bak:static Bitu INT1C_Handler(void) {
src/ints/bios.cpp.bak:static Bitu INT12_Handler(void) {
src/ints/bios.cpp.bak:static Bitu INT17_Handler(void) {
src/ints/bios.cpp.bak:static Bitu INT14_Handler(void) {
src/ints/bios.cpp.bak:		Bitu baudrate = 9600;
src/ints/bios.cpp.bak:		Bitu rawbaud=reg_al>>5;
src/ints/bios.cpp.bak:static Bitu INT15_Handler(void) {
src/ints/bios.cpp.bak:			Bitu   bytes	= reg_cx * 2;
src/ints/bios.cpp.bak:static Bitu Reboot_Handler(void) {
src/ints/bios.cpp.bak:	for(Bitu i = 0; i < strlen(text);i++) {
src/ints/bios.cpp.bak:		Bitu call_irq0=CALLBACK_Allocate();	
src/ints/bios.cpp.bak:		Bitu call_irq2=CALLBACK_Allocate();	
src/ints/bios.cpp.bak:		for(Bitu i = 0; i < strlen(b_type); i++) phys_writeb(0xfe00e + i,b_type[i]);
src/ints/bios.cpp.bak:		for(Bitu i = 0; i < strlen(b_vers); i++) phys_writeb(0xfe061+i,b_vers[i]);
src/ints/bios.cpp.bak:		for(Bitu i = 0; i < strlen(b_date); i++) phys_writeb(0xffff5+i,b_date[i]);
src/ints/bios.cpp.bak:			Bitu tandy_dac_type = 0;
src/ints/bios.cpp.bak:		Bitu ppindex=0; // number of lpt ports
src/ints/bios.cpp.bak:	for(Bitu i = 0; i < 4; i++) {
src/ints/bios.cpp.bak:	for(Bitu i = 0; i < 3; i++) {
src/ints/int10.cpp:static Bitu call_10;
src/ints/int10.cpp:static Bitu INT10_Handler(void) {
src/ints/int10.cpp:					Bitu ct;
src/ints/int10.cpp:				Bitu ret=INT10_VideoState_GetSize(reg_cx);
src/ints/int10.cpp:					Bitu ret=INT10_VideoState_GetSize(reg_cx);
src/ints/int10.cpp:			for (Bitu i=0;i<3*256;i++) IO_Write(0x3c9,0);
src/ints/int10.cpp:		Bitu i;
src/ints/ems.cpp:static Bitu ems_type;
src/ints/ems.cpp:	Bitu subfct=mem_readb(bufptr);
src/ints/ems.cpp:			for (Bitu frct=0; frct<EMM_PAGEFRAME4K/4; frct++) {
src/ints/ems.cpp:			for (Bitu frct=0; frct<0x10/4; frct++) {
src/ints/ems.cpp:				Bitu frnr=(frct+EMM_PAGEFRAME4K/4)*6;
src/ints/ems.cpp:			for (Bitu frct=(EMM_PAGEFRAME4K+0x10)/4; frct<0xf0/4; frct++) {
src/ints/ems.cpp:	Bitu pm_interface;
src/ints/ems.cpp:	Bitu count=MEM_FreeTotal()/4;
src/ints/ems.cpp:static Bit8u EMM_MapPage(Bitu phys_page,Bit16u handle,Bit16u log_page) {
src/ints/ems.cpp:		for (Bitu i=0;i<4;i++)
src/ints/ems.cpp:		for (Bitu i=0;i<4;i++) {
src/ints/ems.cpp:static Bit8u EMM_MapSegment(Bitu segment,Bit16u handle,Bit16u log_page) {
src/ints/ems.cpp:			for (Bitu i=0;i<4;i++)
src/ints/ems.cpp:			for (Bitu i=0;i<4;i++) {
src/ints/ems.cpp:	for (Bitu i=0;i<EMM_MAX_PHYS;i++) {
src/ints/ems.cpp:	for (Bitu i=0;i<0x40;i++) {
src/ints/ems.cpp:	for (Bitu i=0;i<EMM_MAX_PHYS;i++) {
src/ints/ems.cpp:	for (Bitu i=0;i<EMM_MAX_PHYS;i++) {
src/ints/ems.cpp:	Bitu src_off = 0,dest_off = 0 ;Bitu src_remain = 0,dest_remain = 0;
src/ints/ems.cpp:		Bitu pages=region.src_page_seg*4+(region.src_offset/MEM_PAGE_SIZE);
src/ints/ems.cpp:		Bitu pages=region.dest_page_seg*4+(region.dest_offset/MEM_PAGE_SIZE);
src/ints/ems.cpp:	Bitu toread;
src/ints/ems.cpp:static Bitu INT67_Handler(void) {
src/ints/ems.cpp:	Bitu i;
src/ints/ems.cpp:static Bitu VCPI_PM_Handler() {
src/ints/ems.cpp:static Bitu V86_Monitor() {
src/ints/ems.cpp:	Bitu int_num=(mem_readw(SegPhys(ss)+(reg_esp & cpu.stack.mask))-0x2803);
src/ints/ems.cpp:						Bitu rm_val=mem_readb((v86_cs<<4)+v86_ip+2);
src/ints/ems.cpp:						Bitu which=(rm_val >> 3) & 7;
src/ints/ems.cpp:						Bitu rm_val=mem_readb((v86_cs<<4)+v86_ip+2);
src/ints/ems.cpp:						Bitu which=(rm_val >> 3) & 7;
src/ints/ems.cpp:	for (Bitu tse_ct=0; tse_ct<0x68+0x200; tse_ct++) {
src/ints/ems.cpp:static Bitu INT4B_Handler() {
src/ints/ems.cpp:Bitu GetEMSType(Section_prop * section) {
src/ints/ems.cpp:	Bitu rtype = 0;
src/ints/ems.cpp:	Bitu call_int67;
src/ints/ems.cpp:		MEM_BlockWrite(PhysMake(ems_baseseg,0xa),emsname,(Bitu)(strlen(emsname)+1));
src/ints/ems.cpp:		Bitu i;
src/ints/int10_put_pixel.cpp:				Bitu cpupage =
src/ints/int10_put_pixel.cpp:				Bitu cpupage =
src/ints/int10_put_pixel.cpp:		Bitu ind = 1-(x & 0x1);
src/ints/int10_put_pixel.cpp:			if (CurMode->plength!=(Bitu)real_readw(BIOSMEM_SEG,BIOSMEM_PAGE_SIZE))
src/ints/int10_put_pixel.cpp:			if (CurMode->swidth!=(Bitu)real_readw(BIOSMEM_SEG,BIOSMEM_NB_COLS)*8)
src/ints/int10_put_pixel.cpp:			if (CurMode->swidth!=(Bitu)real_readw(BIOSMEM_SEG,BIOSMEM_NB_COLS)*8)
src/ints/int10_put_pixel.cpp:					Bitu cpupage = (real_readb(BIOSMEM_SEG, BIOSMEM_CRTCPU_PAGE) >> 3) & 0x7;
src/ints/int10_put_pixel.cpp:			if (CurMode->plength!=(Bitu)real_readw(BIOSMEM_SEG,BIOSMEM_PAGE_SIZE))
src/ints/int10_put_pixel.cpp:			if (CurMode->swidth!=(Bitu)real_readw(BIOSMEM_SEG,BIOSMEM_NB_COLS)*8)
src/ints/int10_put_pixel.cpp:			Bitu shift=7-(x & 7);
src/ints/int10_put_pixel.cpp:			if (CurMode->swidth!=(Bitu)real_readw(BIOSMEM_SEG,BIOSMEM_NB_COLS)*8)
src/ints/bios.cpp:void CMOS_SetRegister(Bitu regNr, Bit8u val); //For setting equipment word
src/ints/bios.cpp:static Bitu INT70_Handler(void) {
src/ints/bios.cpp:	Bitu sbport, sbirq, sbdma;
src/ints/bios.cpp:	Bitu tsport, tsirq, tsdma;
src/ints/bios.cpp:	Bitu length=real_readw(0x40,0xd0);
src/ints/bios.cpp:static Bitu IRQ_TandyDAC(void) {
src/ints/bios.cpp:		Bitu rb=real_readb(0x40,0xd3);
src/ints/bios.cpp:static Bitu INT1A_Handler(void) {
src/ints/bios.cpp:				Bitu devnr=0;
src/ints/bios.cpp:				Bitu count=0x100;
src/ints/bios.cpp:				for (Bitu i=0; i<=count; i++) {
src/ints/bios.cpp:				Bitu devnr=0;
src/ints/bios.cpp:				Bitu count=0x100;
src/ints/bios.cpp:				for (Bitu i=0; i<=count; i++) {
src/ints/bios.cpp:static Bitu INT11_Handler(void) {
src/ints/bios.cpp:static Bitu INT8_Handler(void) {
src/ints/bios.cpp:static Bitu INT1C_Handler(void) {
src/ints/bios.cpp:static Bitu INT12_Handler(void) {
src/ints/bios.cpp:static Bitu INT17_Handler(void) {
src/ints/bios.cpp:static Bitu INT14_Handler(void) {
src/ints/bios.cpp:		Bitu baudrate = 9600;
src/ints/bios.cpp:		Bitu rawbaud=reg_al>>5;
src/ints/bios.cpp:static Bitu INT15_Handler(void) {
src/ints/bios.cpp:			Bitu   bytes	= reg_cx * 2;
src/ints/bios.cpp:static Bitu Reboot_Handler(void) {
src/ints/bios.cpp:	for(Bitu i = 0; i < strlen(text);i++) {
src/ints/bios.cpp:		Bitu call_irq0=CALLBACK_Allocate();	
src/ints/bios.cpp:		Bitu call_irq2=CALLBACK_Allocate();	
src/ints/bios.cpp:		for(Bitu i = 0; i < strlen(b_type); i++) phys_writeb(0xfe00e + i,b_type[i]);
src/ints/bios.cpp:		for(Bitu i = 0; i < strlen(b_vers); i++) phys_writeb(0xfe061+i,b_vers[i]);
src/ints/bios.cpp:		for(Bitu i = 0; i < strlen(b_date); i++) phys_writeb(0xffff5+i,b_date[i]);
src/ints/bios.cpp:			Bitu tandy_dac_type = 0;
src/ints/bios.cpp:		Bitu ppindex=0; // number of lpt ports
src/ints/bios.cpp:	for(Bitu i = 0; i < 4; i++) {
src/ints/bios.cpp:	for(Bitu i = 0; i < 3; i++) {
Binary file src/ints/int10_modes.o matches
Binary file src/ints/int10_pal.o matches
Binary file src/ints/int10.o matches
src/ints/int10_vptable.cpp:		for (Bitu i=0;i<0x40*0x1d;i++) {
src/ints/int10_vptable.cpp:		for (Bitu i=0;i<0x40*0x17;i++) {
src/ints/int10_vptable.cpp:	Bitu i;
src/ints/int10_vptable.cpp:		Bitu ct;
src/ints/int10_vptable.cpp:			Bitu seq_regs[4];
src/ints/int10_vptable.cpp:			Bitu crtc_regs[0x19];
src/ints/int10_vptable.cpp:			Bitu attr_regs[0x14];
src/ints/int10_vptable.cpp:			Bitu gfx_regs[9];
src/ints/int10_vptable.cpp:		Bitu ct;
src/ints/int10_vptable.cpp:		Bitu seq_regs[4];
src/ints/int10_vptable.cpp:		Bitu crtc_regs[0x19];
src/ints/int10_vptable.cpp:		Bitu attr_regs[0x14];
src/ints/int10_vptable.cpp:		Bitu gfx_regs[9];
src/ints/int10_vptable.cpp:			Bitu ct;
src/ints/int10_vptable.cpp:			Bitu seq_regs[4];
src/ints/int10_vptable.cpp:			Bitu crtc_regs[0x19];
src/ints/int10_vptable.cpp:			Bitu attr_regs[0x14];
src/ints/int10_vptable.cpp:			Bitu gfx_regs[9];
src/ints/int10_vptable.cpp:			Bitu ct=i;
src/ints/int10_vptable.cpp:			Bitu seq_regs[4];
src/ints/int10_vptable.cpp:			Bitu crtc_regs[0x19];
src/ints/int10_vptable.cpp:			Bitu attr_regs[0x14];
src/ints/int10_vptable.cpp:			Bitu gfx_regs[9];
src/ints/int10_pal.cpp:	for (Bitu ct=0; ct<count; ct++) {
Binary file src/ints/int10_put_pixel.o matches
Binary file src/dosbox matches
Binary file src/dosbox.o matches
src/dosbox.cpp:static Bitu Normal_Loop(void) {
src/dosbox.cpp:				Bitu blah = (*CallBack_Handlers[ret])();
src/dosbox.cpp:	Bitu ret;
Binary file src/dos/dos_classes.o matches
Binary file src/dos/dos_files.o matches
src/dos/dos_devices.cpp.orig:	for(Bitu i = 0; i < DOS_DEVICES;i++) {
src/dos/dos_devices.cpp.orig:	for (Bitu i = 0; i <DOS_DEVICES;i++) {
Binary file src/dos/dos_misc.o matches
src/dos/cdrom_aspi_win32.cpp:	Bitu   buflen	= raw?2352*num:2048*num;
Binary file src/dos/libdos.a matches
Binary file src/dos/dos.o matches
src/dos/dos_tables.cpp:static Bitu call_casemap;
src/dos/dos_tables.cpp:	if ((Bitu)pages+(Bitu)dos_memseg>=DOS_PRIVATE_SEGMENT_END) {
src/dos/dos_tables.cpp:static Bitu DOS_CaseMapFunc(void) {
src/dos/dos_tables.cpp:	Bit16u seg;Bitu i;
src/dos/dos_tables.cpp:	for(Bitu d=0;d<26;d++) real_writeb(dos.tables.dpb,d,d);
src/dos/dos_tables.cpp:	for (Bitu ct=0; ct<0x20; ct++) real_writeb(seg,ct,0);
Binary file src/dos/drive_local.o matches
Binary file src/dos/dos_ioctl.o matches
src/dos/drive_cache.cpp:		Bitu numberSize		= endPos ? int(endPos)-int(cpos) : strlen(cpos);
src/dos/drive_cache.cpp:Bitu DOS_Drive_Cache::CreateShortNameID(CFileInfo* curDir, const char* name) {
src/dos/drive_cache.cpp:	Bitu foundNr	= 0;	
src/dos/drive_cache.cpp:			} while((Bitu)mid<curDir->longNameList.size() && (CompareShortname(name,curDir->longNameList[mid]->shortname)==0));
src/dos/drive_cache.cpp:	for (Bitu i = 0; i < filelist_size; i++) {
src/dos/drive_cache.cpp:bool DOS_Drive_Cache::SetResult(CFileInfo* dir, char* &result, Bitu entryNr)
src/dos/drive_cache.cpp:		for(Bitu n=0; n<MAX_OPENDIRS;n++) {	
src/dos/drive_cache.cpp:	for (Bitu i=0; i<dirSearch[dirID]->fileList.size(); i++) {
Binary file src/dos/dos_mscdex.o matches
src/dos/dos_ioctl.cpp:	Bitu handle=0;Bit8u drive=0;
src/dos/dos_ioctl.cpp:						Bitu size=(Bitu)(find_ext-bufin);
src/dos/dos_devices.cpp:	for(Bitu i = 0; i < DOS_DEVICES;i++) {
src/dos/dos_devices.cpp:	for (Bitu i = 0; i <DOS_DEVICES;i++) {
src/dos/dos_keyboard_layout.cpp:	Bitu read_codepage_file(const char* codepage_file_name, Bit32s codepage_id);
src/dos/dos_keyboard_layout.cpp:	Bitu read_keyboard_file(const char* keyboard_file_name, Bit32s req_cp);
src/dos/dos_keyboard_layout.cpp:	bool layout_key(Bitu key, Bit8u flags1, Bit8u flags2, Bit8u flags3);
src/dos/dos_keyboard_layout.cpp:	Bitu switch_keyboard_layout(const char* new_layout, keyboard_layout* &created_layout, Bit32s& tried_cp);
src/dos/dos_keyboard_layout.cpp:	Bitu language_code_count;
src/dos/dos_keyboard_layout.cpp:	Bitu read_keyboard_file(const char* keyboard_file_name, Bit32s specific_layout, Bit32s requested_codepage);
src/dos/dos_keyboard_layout.cpp:	bool map_key(Bitu key, Bit16u layouted_key, bool is_command, bool is_keypair);
src/dos/dos_keyboard_layout.cpp:		for (Bitu i=0; i<language_code_count; i++)
src/dos/dos_keyboard_layout.cpp:Bitu keyboard_layout::read_keyboard_file(const char* keyboard_file_name, Bit32s req_cp) {
src/dos/dos_keyboard_layout.cpp:		for (Bitu i=0; i<data_len;) {
src/dos/dos_keyboard_layout.cpp:			Bitu lcpos=0;
src/dos/dos_keyboard_layout.cpp:		for (Bitu i=0; i<data_len;) {
src/dos/dos_keyboard_layout.cpp:			Bitu lcpos=0;
src/dos/dos_keyboard_layout.cpp:Bitu keyboard_layout::read_keyboard_file(const char* keyboard_file_name, Bit32s specific_layout, Bit32s requested_codepage) {
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<33196; ct++) read_buf[read_buf_size++]=layout_keyboardsys[ct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<25431; ct++) read_buf[read_buf_size++]=layout_keybrd2sys[ct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<27122; ct++) read_buf[read_buf_size++]=layout_keybrd3sys[ct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<33196; ct++) read_buf[read_buf_size++]=layout_keyboardsys[ct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<25431; ct++) read_buf[read_buf_size++]=layout_keybrd2sys[ct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<27122; ct++) read_buf[read_buf_size++]=layout_keybrd3sys[ct];
src/dos/dos_keyboard_layout.cpp:	for (Bitu i=0; i<data_len;) {
src/dos/dos_keyboard_layout.cpp:		Bitu lcpos=0;
src/dos/dos_keyboard_layout.cpp:					Bitu charptr=read_buf_pos+addmap*((read_buf[read_buf_pos-2]&0x80)?2:1);
src/dos/dos_keyboard_layout.cpp:bool keyboard_layout::layout_key(Bitu key, Bit8u flags1, Bit8u flags2, Bit8u flags3) {
src/dos/dos_keyboard_layout.cpp:bool keyboard_layout::map_key(Bitu key, Bit16u layouted_key, bool is_command, bool is_keypair) {
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<33196; ct++) read_buf[read_buf_size++]=layout_keyboardsys[ct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<25431; ct++) read_buf[read_buf_size++]=layout_keybrd2sys[ct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<27122; ct++) read_buf[read_buf_size++]=layout_keybrd3sys[ct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<33196; ct++) read_buf[read_buf_size++]=layout_keyboardsys[ct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<25431; ct++) read_buf[read_buf_size++]=layout_keybrd2sys[ct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu ct=start_pos+2; ct<27122; ct++) read_buf[read_buf_size++]=layout_keybrd3sys[ct];
src/dos/dos_keyboard_layout.cpp:Bitu keyboard_layout::read_codepage_file(const char* codepage_file_name, Bit32s codepage_id) {
src/dos/dos_keyboard_layout.cpp:						for (Bitu bct=0; bct<6322; bct++) cpi_buf[bct]=font_ega_cpx[bct];
src/dos/dos_keyboard_layout.cpp:						for (Bitu bct=0; bct<5455; bct++) cpi_buf[bct]=font_ega3_cpx[bct];
src/dos/dos_keyboard_layout.cpp:						for (Bitu bct=0; bct<5720; bct++) cpi_buf[bct]=font_ega5_cpx[bct];
src/dos/dos_keyboard_layout.cpp:			for (Bitu i=0; i<100; i++) {
src/dos/dos_keyboard_layout.cpp:				size_of_cpxdata=(Bitu)fread(cpi_buf, sizeof(Bit8u), 65536, tempfile);
src/dos/dos_keyboard_layout.cpp:					for (Bitu i=0;i<256*16;i++) {
src/dos/dos_keyboard_layout.cpp:					for (Bitu i=0;i<256*14;i++) {
src/dos/dos_keyboard_layout.cpp:					for (Bitu i=0;i<128*8;i++) {
src/dos/dos_keyboard_layout.cpp:					for (Bitu i=0;i<128*8;i++) {
src/dos/dos_keyboard_layout.cpp:Bitu keyboard_layout::switch_keyboard_layout(const char* new_layout, keyboard_layout*& created_layout, Bit32s& tried_cp) {
src/dos/dos_keyboard_layout.cpp:		for (Bitu i=0; i<language_code_count; i++) {
src/dos/dos_keyboard_layout.cpp:			Bitu req_codepage=temp_layout->extract_codepage(new_layout);
src/dos/dos_keyboard_layout.cpp:			Bitu kerrcode=temp_layout->read_keyboard_file(new_layout, req_codepage);
src/dos/dos_keyboard_layout.cpp:bool DOS_LayoutKey(Bitu key, Bit8u flags1, Bit8u flags2, Bit8u flags3) {
src/dos/dos_keyboard_layout.cpp:Bitu DOS_LoadKeyboardLayout(const char * layoutname, Bit32s codepage, const char * codepagefile) {
src/dos/dos_keyboard_layout.cpp:	Bitu kerrcode=temp_layout->read_keyboard_file(layoutname, codepage);
src/dos/dos_keyboard_layout.cpp:Bitu DOS_SwitchKeyboardLayout(const char* new_layout, Bit32s& tried_cp) {
src/dos/dos_keyboard_layout.cpp:		Bitu ret_code=loaded_layout->switch_keyboard_layout(new_layout, changed_layout, tried_cp);
src/dos/dos_keyboard_layout.cpp:			if ((loaded_layout->read_codepage_file("auto", (Bitu)wants_dos_codepage)) == KEYB_NOERROR) {
src/dos/dos_keyboard_layout.cpp:			Bitu req_codepage = loaded_layout->extract_codepage(layoutname);
src/dos/dos_misc.cpp:static Bitu call_int2f,call_int2a;
src/dos/dos_misc.cpp:static Bitu INT2F_Handler(void) {
src/dos/dos_misc.cpp:static Bitu INT2A_Handler(void) {
src/dos/dos_misc.cpp:			Bitu sftofs=0x06+reg_bx*0x3b;
src/dos/dos_programs.cpp:Bitu DEBUG_EnableDebugger(void);
src/dos/dos_programs.cpp:static Bitu ZDRIVE_NUM = 25;
src/dos/dos_programs.cpp:			Bitu index=0;Bitu count=0;
src/dos/dos_programs.cpp:		Bitu i=0; 
src/dos/dos_programs.cpp:					Bitu ct=6;
src/dos/dos_programs.cpp:						for(Bitu dct=0;dct<MAX_SWAPPABLE_DISKS;dct++) {
src/dos/dos_programs.cpp:							for(Bitu dct=0;dct<MAX_SWAPPABLE_DISKS;dct++) {
src/dos/dos_programs.cpp:				for(Bitu dct=0;dct<MAX_SWAPPABLE_DISKS;dct++) {
src/dos/dos_programs.cpp:			Bitu data_read = fread(rom_buffer, 1, 0x8000, tmpfile);
src/dos/dos_programs.cpp:				for (Bitu i=0; i<data_read; i++) phys_writeb(rom_base + i, rom_buffer[i]);
src/dos/dos_programs.cpp:		for(Bitu i =0; i<DOS_DRIVES;i++) {
src/dos/dos_programs.cpp:				Bitu index=0;Bitu count=0;
src/dos/dos_programs.cpp:					Bitu sectors=(Bitu)(fcsize/(16*63));
src/dos/dos_programs.cpp:Bitu DOS_SwitchKeyboardLayout(const char* new_layout, Bit32s& tried_cp);
src/dos/dos_programs.cpp:Bitu DOS_LoadKeyboardLayout(const char * layoutname, Bit32s codepage, const char * codepagefile);
src/dos/dos_programs.cpp:			Bitu keyb_error=0;
src/dos/dos_classes.cpp:	for(Bitu i=0;i<sizeof(sDIB);i++) mem_writeb(pt+i,0xff);
src/dos/dos_classes.cpp:	for(Bitu i=0;i<14;i++) mem_writeb(pt+i,0);
src/dos/dos_classes.cpp:	Bitu i;
src/dos/dos_classes.cpp:	Bitu i;
src/dos/dos_classes.cpp:		Bitu size=(Bitu)(find_ext-pattern);
src/dos/dos_classes.cpp:		MEM_BlockWrite(pt+offsetof(sDTA,sext),find_ext,(strlen(find_ext)>3) ? 3 : (Bitu)strlen(find_ext));
src/dos/dos_classes.cpp:		MEM_BlockWrite(pt+offsetof(sDTA,sname),pattern,(strlen(pattern) > 8) ? 8 : (Bitu)strlen(pattern));
src/dos/dos_classes.cpp:	Bitu fill;
src/dos/dos_classes.cpp:	Bitu i;
src/dos/dos_classes.cpp:	for(Bitu i=0;i<sizeof(sSDA);i++) mem_writeb(pt+i,0x00);
src/dos/dev_con.h:	Bitu i;
src/dos/dev_con.h:			if(tempdata + static_cast<Bitu>(row) >= nrows)
src/dos/dev_con.h:			if(tempdata + static_cast<Bitu>(col) >= ncols) 
src/dos/dev_con.h:			//for(i = col;i<(Bitu) ncols; i++) INT10_TeletypeOutputAttr(' ',ansi.attr,true);
Binary file src/dos/drives.o matches
Binary file src/dos/dos_programs.o matches
src/dos/dos.cpp.orig:static void DOS_AddDays(Bitu days) {
src/dos/dos.cpp.orig:static Bitu DOS_21Handler(void) {
src/dos/dos.cpp.orig:	static Bitu time_start = 0; //For emulating temporary time changes.
src/dos/dos.cpp.orig:		Bitu ticks=((Bitu)reg_cx<<16)|reg_dx;
src/dos/dos.cpp.orig:		Bitu time=(Bitu)((100.0/((double)PIT_TICK_RATE/65536.0)) * (double)ticks);
src/dos/dos.cpp.orig:		reg_dl=(Bit8u)((Bitu)time % 100); // 1/100 seconds
src/dos/dos.cpp.orig:		reg_dh=(Bit8u)((Bitu)time % 60); // seconds
src/dos/dos.cpp.orig:		reg_cl=(Bit8u)((Bitu)time % 60); // minutes
src/dos/dos.cpp.orig:		reg_ch=(Bit8u)((Bitu)time % 24); // hours
src/dos/dos.cpp.orig:			MEM_BlockWrite(SegPhys(ds)+reg_si,name1,(Bitu)(strlen(name1)+1));	
src/dos/dos.cpp.orig:				MEM_BlockWrite(SegPhys(ds)+reg_dx,name1,(Bitu)(strlen(name1)+1));
src/dos/dos.cpp.orig:				MEM_BlockWrite(SegPhys(es)+reg_di,name2,(Bitu)(strlen(name2)+1));	
src/dos/dos.cpp.orig:			Bitu len = 0; /* For 0x21 and 0x22 */
src/dos/dos.cpp.orig:					Bitu amount = (reg_cx>=0x29)?0x22:(reg_cx-7);
src/dos/dos.cpp.orig:					for (Bitu count = 0; count < len;count++)
src/dos/dos.cpp.orig:static Bitu DOS_20Handler(void) {
src/dos/dos.cpp.orig:static Bitu DOS_27Handler(void) {
src/dos/dos.cpp.orig:static Bitu DOS_25Handler(void) {
src/dos/dos.cpp.orig:static Bitu DOS_26Handler(void) {
Binary file src/dos/dos_keyboard_layout.o matches
src/dos/drive_local.cpp:		for(Bitu i = 0;i < DOS_FILES;i++){
src/dos/drive_local.cpp:				Bitu max = DOS_FILES;
src/dos/dos_mscdex.cpp:static Bitu MSCDEX_Strategy_Handler(void); 
src/dos/dos_mscdex.cpp:static Bitu MSCDEX_Interrupt_Handler(void);
src/dos/dos_mscdex.cpp:	if ((Bitu)GetNumDrives()+1>=MSCDEX_MAX_DRIVES) return 4;
src/dos/dos_mscdex.cpp:		Bitu len;
src/dos/dos_mscdex.cpp:		Bitu len;
src/dos/dos_mscdex.cpp:		Bitu len;
src/dos/dos_mscdex.cpp:	Bitu	entryLength,nameLength;
src/dos/dos_mscdex.cpp:	Bitu dirEntrySector	= mem_readd(defBuffer+offset+2);
src/dos/dos_mscdex.cpp:	Bitu index;
src/dos/dos_mscdex.cpp:static Bitu MSCDEX_Strategy_Handler(void) {
src/dos/dos_mscdex.cpp:static Bitu MSCDEX_Interrupt_Handler(void) {
Binary file src/dos/drive_virtual.o matches
src/dos/cdrom_ioctl_os2.cpp:    Bitu buflen = raw ? num * CD_FRAMESIZE_RAW : num * CD_FRAMESIZE;
src/dos/dos_memory.cpp:static Bitu DOS_default_handler(void) {
Binary file src/dos/dos_execute.o matches
src/dos/drives.cpp:	Bitu r;
src/dos/drives.cpp:		Bitu size=(Bitu)(find_ext-file);
src/dos/drives.cpp:		Bitu size=(Bitu)(find_ext-wild);
src/dos/drives.cpp:	Bitu togo     = 8;
src/dos/drives.cpp:	Bitu vnamePos = 0;
src/dos/drives.cpp:	Bitu labelPos = 0;
Binary file src/dos/dos_tables.o matches
Binary file src/dos/dos_memory.o matches
src/dos/cdrom_ioctl_win32.cpp:	Bitu	buflen	= raw ? RAW_SECTOR_SIZE : COOKED_SECTOR_SIZE;
src/dos/cdrom_ioctl_win32.cpp:	Bitu	buflen	= raw ? num*RAW_SECTOR_SIZE : num*COOKED_SECTOR_SIZE;
src/dos/cdrom_ioctl_win32.cpp:void CDROM_Interface_Ioctl::dx_CDAudioCallBack(Bitu len) {
src/dos/cdrom_ioctl_win32.cpp:		for (Bitu pos=0;pos<len/4;pos++) {
Binary file src/dos/dos_devices.o matches
src/dos/dos_files.cpp:	Bitu r,w;
src/dos/dos_files.cpp:			for (Bitu i=0;i<strlen(tempdir);i++) {
src/dos/dos_files.cpp:	Bitu index=0;
src/dos/dos_files.cpp:		Bitu i = toread;
src/dos/dos.cpp:static void DOS_AddDays(Bitu days) {
src/dos/dos.cpp:static Bitu DOS_21Handler(void) {
src/dos/dos.cpp:	static Bitu time_start = 0; //For emulating temporary time changes.
src/dos/dos.cpp:		Bitu ticks=((Bitu)reg_cx<<16)|reg_dx;
src/dos/dos.cpp:		Bitu time=(Bitu)((100.0/((double)PIT_TICK_RATE/65536.0)) * (double)ticks);
src/dos/dos.cpp:		reg_dl=(Bit8u)((Bitu)time % 100); // 1/100 seconds
src/dos/dos.cpp:		reg_dh=(Bit8u)((Bitu)time % 60); // seconds
src/dos/dos.cpp:		reg_cl=(Bit8u)((Bitu)time % 60); // minutes
src/dos/dos.cpp:		reg_ch=(Bit8u)((Bitu)time % 24); // hours
src/dos/dos.cpp:			MEM_BlockWrite(SegPhys(ds)+reg_si,name1,(Bitu)(strlen(name1)+1));	
src/dos/dos.cpp:				MEM_BlockWrite(SegPhys(ds)+reg_dx,name1,(Bitu)(strlen(name1)+1));
src/dos/dos.cpp:				MEM_BlockWrite(SegPhys(es)+reg_di,name2,(Bitu)(strlen(name2)+1));	
src/dos/dos.cpp:			Bitu len = 0; /* For 0x21 and 0x22 */
src/dos/dos.cpp:					Bitu amount = (reg_cx>=0x29)?0x22:(reg_cx-7);
src/dos/dos.cpp:					for (Bitu count = 0; count < len;count++)
src/dos/dos.cpp:static Bitu DOS_20Handler(void) {
src/dos/dos.cpp:static Bitu DOS_27Handler(void) {
src/dos/dos.cpp:static Bitu DOS_25Handler(void) {
src/dos/dos.cpp:static Bitu DOS_26Handler(void) {
Binary file src/dos/drive_cache.o matches
src/dos/cdrom_image.cpp:	Bitu buflen = num * sectorSize;
src/dos/cdrom_image.cpp:void CDROM_Interface_Image::CDAudioCallBack(Bitu len)
src/dos/cdrom_image.cpp:		for (Bitu pos=0;pos<len/4;pos++) {
src/dos/cdrom_image.cpp:	for(Bitu i = 0; i < keyword.size(); i++) keyword[i] = toupper(keyword[i]);
src/dos/dos_execute.cpp:	for(Bitu i = 0;i < 8;i++) { //Don't put garbage in the title bar. Mac OS X doesn't like it
src/dos/dos_execute.cpp:		MEM_BlockWrite(envwrite,namebuf,(Bitu)(strlen(namebuf)+1));
src/dos/dos_execute.cpp:	EXE_Header head;Bitu i;
src/dos/dos_execute.cpp:	Bitu headersize=0,imagesize=0;
src/dos/dos_execute.cpp:		char stripname[8]= { 0 };Bitu index=0;
src/dos/dos_ioctl.cpp.orig:	Bitu handle=0;Bit8u drive=0;
src/dos/dos_ioctl.cpp.orig:						Bitu size=(Bitu)(find_ext-bufin);
Binary file src/dos/drive_fat.o matches
Binary file src/dos/cdrom_image.o matches
Binary file src/dos/drive_iso.o matches
Binary file src/dos/cdrom_ioctl_linux.o matches
src/dos/cdrom.h:static	void	CDAudioCallBack(Bitu len);
src/dos/cdrom.h:	static void dx_CDAudioCallBack(Bitu len);
src/debug/debug_inc.h:Bitu DasmI386(char* buffer, PhysPt pc, Bitu cur_ip, bool bit32);
src/debug/debug.cpp:	Bitu readb(PhysPt /*addr*/) {
src/debug/debug.cpp:	Bitu readw(PhysPt /*addr*/) {
src/debug/debug.cpp:	Bitu readd(PhysPt /*addr*/) {
src/debug/debug.cpp:	void writeb(PhysPt /*addr*/,Bitu /*val*/) {
src/debug/debug.cpp:	void writew(PhysPt /*addr*/,Bitu /*val*/) {
src/debug/debug.cpp:	void writed(PhysPt /*addr*/,Bitu /*val*/) {
src/debug/debug.cpp:static Bitu oldflags,oldcpucpl;
src/debug/debug.cpp:Bitu cycle_count;
src/debug/debug.cpp:static void SetColor(Bitu test) {
src/debug/debug.cpp:	Bitu sel;
src/debug/debug.cpp:	static bool				CheckBreakpoint		(Bitu seg, Bitu off);
src/debug/debug.cpp:bool CBreakpoint::CheckBreakpoint(Bitu seg, Bitu off)
src/debug/debug.cpp:				Bitu address; 
src/debug/debug.cpp:	char dline[200];Bitu size;
src/debug/debug.cpp:	Bitu changed_flags = reg_flags ^ oldflags;
src/debug/debug.cpp:	char dline[200];Bitu size;Bitu c;
src/debug/debug.cpp:		Bitu drawsize=size=DasmI386(dline, start, disEIP, cpu.code.big);
src/debug/debug.cpp:		Bitu nr = GetHexValue(pos,pos);
src/debug/debug.cpp:					Bitu bytes = 0;
src/debug/debug.cpp:					Bitu size = 0;
src/debug/debug.cpp:Bitu DEBUG_Loop(void) {
src/debug/debug.cpp:	Bitu length = cpu.gdt.GetLimit();
src/debug/debug.cpp:	Bitu i = 0;
src/debug/debug.cpp:	Bitu ldtSelector = cpu.gdt.SLDT();
src/debug/debug.cpp:	Bitu length = desc.GetLimit();
src/debug/debug.cpp:	Bitu i = 0;
src/debug/debug.cpp:	Bitu address = 0;
src/debug/debug.cpp:		Bitu sel = GetHexValue(selname,selname);
src/debug/debug.cpp:				Bitu table_addr=(paging.base.page<<12)+(i >> 10)*4;
src/debug/debug.cpp:					Bitu entry_addr=(table.block.base<<12)+(i & 0x3ff)*4;
src/debug/debug.cpp:			Bitu table_addr=(paging.base.page<<12)+(sel >> 10)*4;
src/debug/debug.cpp:				Bitu entry_addr=(table.block.base<<12)+(sel & 0x3ff)*4;
src/debug/debug.cpp:	Bitu sel=CPU_STR();
src/debug/debug.cpp:	char dline[200];Bitu size;
src/debug/debug.cpp:		Bitu reslen = strlen(res);
src/debug/debug.cpp:		if (reslen<22) for (Bitu i=0; i<22-reslen; i++) res[reslen+i] = ' '; res[22] = 0;
src/debug/debug.cpp:	Bitu len = strlen(dline);
src/debug/debug.cpp:	if (len<30) for (Bitu i=0; i<30-len; i++) dline[len + i] = ' '; dline[30] = 0;
src/debug/debug.cpp:		for (Bitu i=0; i<size; i++) {
src/debug/debug.cpp:		if (len<21) { for (Bitu i=0; i<21-len; i++) ibytes[len + i] =' '; ibytes[21]=0;} //NOTE THE BRACKETS
src/debug/debug.cpp:Bitu DEBUG_EnableDebugger(void)
src/debug/debug.cpp:Bitu debugCallback;
src/debug/debug.cpp:	for (Bitu x = 0; x < num;x++) {
src/debug/debug.cpp:		Bitu reslen = strlen(res);
src/debug/debug.cpp:		if (reslen<22) for (Bitu i=0; i<22-reslen; i++) res[reslen+i] = ' '; res[22] = 0;
src/debug/debug.cpp:	Bitu len = strlen(dline);
src/debug/debug.cpp:	if (len < 30) for (Bitu i=0; i < 30-len; i++) dline[len+i] = ' ';
src/debug/debug.cpp:	static Bitu zero_count = 0;
src/debug/debug_disasm.cpp:Bitu DasmI386(char* buffer, PhysPt pc, Bitu cur_ip, bool bit32)
src/debug/debug_disasm.cpp:  	Bitu c;
src/debug/debug_gui.cpp:	Bitu len=strlen(buf);
src/debug/debug_gui.cpp:	for (Bitu i = LOG_ALL + 1;i < LOG_MAX;i++) { //Skip LOG_ALL, it is always enabled
src/debug/debug_gui.cpp:	for (Bitu i = LOG_ALL + 1;i < LOG_MAX;i++) {
src/cpu/core_prefetch.cpp:extern Bitu cycle_count;
src/cpu/core_prefetch.cpp:	Bitu opcode_index;
src/cpu/core_prefetch.cpp:	Bitu prefixes;
src/cpu/core_prefetch.cpp:static Bitu pq_start;
src/cpu/core_prefetch.cpp:			Bitu remaining_bytes=pq_start+CPU_PrefetchQueueSize-(core.cseip+1);
src/cpu/core_prefetch.cpp:			for (Bitu i=0; i<remaining_bytes; i++) prefetch_buffer[i]=prefetch_buffer[core.cseip+1-pq_start+i];
src/cpu/core_prefetch.cpp:			for (Bitu i=remaining_bytes; i<CPU_PrefetchQueueSize; i++) prefetch_buffer[i]=LoadMb(core.cseip+1+i);
src/cpu/core_prefetch.cpp:		for (Bitu i=0; i<CPU_PrefetchQueueSize; i++) prefetch_buffer[i]=LoadMb(core.cseip+i);
src/cpu/core_prefetch.cpp:			Bitu remaining_bytes=pq_start+CPU_PrefetchQueueSize-(core.cseip+2);
src/cpu/core_prefetch.cpp:			for (Bitu i=0; i<remaining_bytes; i++) prefetch_buffer[i]=prefetch_buffer[core.cseip+2-pq_start+i];
src/cpu/core_prefetch.cpp:			for (Bitu i=remaining_bytes; i<CPU_PrefetchQueueSize; i++) prefetch_buffer[i]=LoadMb(core.cseip+2+i);
src/cpu/core_prefetch.cpp:		for (Bitu i=0; i<CPU_PrefetchQueueSize; i++) prefetch_buffer[i]=LoadMb(core.cseip+i);
src/cpu/core_prefetch.cpp:			Bitu remaining_bytes=pq_start+CPU_PrefetchQueueSize-(core.cseip+4);
src/cpu/core_prefetch.cpp:			for (Bitu i=0; i<remaining_bytes; i++) prefetch_buffer[i]=prefetch_buffer[core.cseip+4-pq_start+i];
src/cpu/core_prefetch.cpp:			for (Bitu i=remaining_bytes; i<CPU_PrefetchQueueSize; i++) prefetch_buffer[i]=LoadMb(core.cseip+4+i);
src/cpu/core_prefetch.cpp:		for (Bitu i=0; i<CPU_PrefetchQueueSize; i++) prefetch_buffer[i]=LoadMb(core.cseip+i);
src/cpu/core_prefetch.cpp:				Bitu len=(GETIP-reg_eip);
src/cpu/core_dynrec.cpp:	Bitu callback;				// the occurred callback
src/cpu/core_dynrec.cpp:	Bitu readdata;				// spare space used when reading from memory
src/cpu/core_dynrec.cpp:	Bitu temp_ip=SegPhys(cs)+reg_eip;
src/cpu/core_dynrec.cpp:				Bitu old_cycles=CPU_Cycles;
Binary file src/cpu/core_full.o matches
src/cpu/instructions.h:	Bitu tempu=(Bitu)reg_ax*(Bitu)(load(op1));				\
src/cpu/instructions.h:	Bitu val=load(op1);										\
src/cpu/instructions.h:	Bitu quo=reg_ax / val;									\
src/cpu/instructions.h:	Bitu val=load(op1);										\
src/cpu/instructions.h:	Bitu num=((Bit32u)reg_dx<<16)|reg_ax;							\
src/cpu/instructions.h:	Bitu quo=num/val;										\
src/cpu/instructions.h:	Bitu val=load(op1);										\
src/cpu/instructions.h:	GetRM;Bitu which=(rm>>3)&7;								\
src/cpu/instructions.h:	GetRM;Bitu which=(rm>>3)&7;								\
src/cpu/instructions.h:	GetRM;Bitu which=(rm>>3)&7;								\
src/cpu/core_full/load.h:			Bitu words=Fetchw();
src/cpu/core_full/load.h:			Bitu words=Fetchw();
src/cpu/core_full/load.h:			Bitu bytes=Fetchw();
src/cpu/core_full/load.h:			Bitu level=Fetchb();
src/cpu/core_full/load.h:			Bitu bytes=Fetchw();
src/cpu/core_full/load.h:			Bitu level=Fetchb();
src/cpu/core_full/string.h:	Bitu	si_index,di_index;
src/cpu/core_full/string.h:	Bitu	add_mask;
src/cpu/core_full/string.h:	Bitu	count,count_left;
src/cpu/core_full/string.h:		if ((count>(Bitu)CPU_Cycles) && (inst.code.op<R_SCASB)) {
src/cpu/core_full/op.h:			Bitu ar=inst_op2_d;
src/cpu/core_full/op.h:			Bitu limit=inst_op2_d;
src/cpu/core_full/op.h:			Bitu new_sel=inst_op1_d;
src/cpu/core_full/op.h:				Bitu count=0;
src/cpu/core_full/op.h:				Bitu count=0;
src/cpu/core_full/op.h:				Bitu count=15;
src/cpu/core_full/op.h:				Bitu count=31;
src/cpu/core_full/support.h:	Bitu entry;
src/cpu/core_full/support.h:	Bitu rm;
src/cpu/core_full/support.h:	Bitu rm_off;
src/cpu/core_full/support.h:	Bitu rm_eai;
src/cpu/core_full/support.h:	Bitu rm_index;
src/cpu/core_full/support.h:	Bitu rm_mod;
src/cpu/core_full/support.h:	Bitu new_flags;
src/cpu/core_full/support.h:	Bitu cond;
src/cpu/core_full/support.h:	Bitu prefix;
src/cpu/core_full/ea_lookup.h:	Bitu sib=Fetchb();												\
src/cpu/flags.cpp:	Bitu type=lflags.type;
src/cpu/flags.cpp:	Bitu type=lflags.type;
src/cpu/flags.cpp:	Bitu type=lflags.type;
src/cpu/flags.cpp:	Bitu type=lflags.type;
src/cpu/flags.cpp:Bitu FillFlags(void) {
src/cpu/flags.cpp:	Bitu new_word=(reg_flags & ~FLAG_MASK);
src/cpu/flags.cpp:Bitu FillFlags(void) {
Binary file src/cpu/core_prefetch.o matches
Binary file src/cpu/cpu.o matches
src/cpu/core_simple.cpp:extern Bitu cycle_count;
src/cpu/core_simple.cpp:	Bitu opcode_index;
src/cpu/core_simple.cpp:	Bitu prefixes;
src/cpu/core_simple.cpp:				Bitu len=(GETIP-reg_eip);
Binary file src/cpu/libcpu.a matches
src/cpu/lazyflags.h:Bitu FillFlags(void);
src/cpu/lazyflags.h:	Bitu type;
src/cpu/lazyflags.h:	Bitu prev_type;
src/cpu/lazyflags.h:	Bitu oldcf;
src/cpu/paging.cpp:Bitu PageHandler::readb(PhysPt addr) {
src/cpu/paging.cpp:Bitu PageHandler::readw(PhysPt addr) {
src/cpu/paging.cpp:	Bitu ret = (readb(addr+0) << 0);
src/cpu/paging.cpp:Bitu PageHandler::readd(PhysPt addr) {
src/cpu/paging.cpp:	Bitu ret = (readb(addr+0) << 0);
src/cpu/paging.cpp:void PageHandler::writeb(PhysPt addr,Bitu /*val*/) {
src/cpu/paging.cpp:void PageHandler::writew(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:void PageHandler::writed(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:HostPt PageHandler::GetHostReadPt(Bitu /*phys_page*/) {
src/cpu/paging.cpp:HostPt PageHandler::GetHostWritePt(Bitu /*phys_page*/) {
src/cpu/paging.cpp:bool PageHandler::writeb_checked(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:bool PageHandler::writew_checked(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:bool PageHandler::writed_checked(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:	Bitu cs;
src/cpu/paging.cpp:	Bitu eip;
src/cpu/paging.cpp:	Bitu page_addr;
src/cpu/paging.cpp:	Bitu mpl;
src/cpu/paging.cpp:	Bitu used;
src/cpu/paging.cpp:Bitu DEBUG_EnableDebugger(void);
src/cpu/paging.cpp:void PAGING_PageFault(PhysPt lin_addr,Bitu page_addr,Bitu faultcode) {
src/cpu/paging.cpp:static INLINE void InitPageUpdateLink(Bitu relink,PhysPt addr) {
src/cpu/paging.cpp:	Bitu lin_page=lin_addr >> 12;
src/cpu/paging.cpp:	Bitu d_index=lin_page >> 10;
src/cpu/paging.cpp:	Bitu t_index=lin_page & 0x3ff;
src/cpu/paging.cpp:	Bitu table_addr=(paging.base.page<<12)+d_index*4;
src/cpu/paging.cpp:	Bitu entry_addr=(table.block.base<<12)+t_index*4;
src/cpu/paging.cpp:	Bitu lin_page=lin_addr >> 12;
src/cpu/paging.cpp:	Bitu d_index=lin_page >> 10;
src/cpu/paging.cpp:	Bitu t_index=lin_page & 0x3ff;
src/cpu/paging.cpp:	Bitu table_addr=(paging.base.page<<12)+d_index*4;
src/cpu/paging.cpp:	Bitu entry_addr=(table.block.base<<12)+t_index*4;
src/cpu/paging.cpp:static INLINE bool InitPage_CheckUseraccess(Bitu u1,Bitu u2) {
src/cpu/paging.cpp:	Bitu readb(PhysPt addr) {
src/cpu/paging.cpp:		Bitu needs_reset=InitPage(addr,false);
src/cpu/paging.cpp:	Bitu readw(PhysPt addr) {
src/cpu/paging.cpp:		Bitu needs_reset=InitPage(addr,false);
src/cpu/paging.cpp:	Bitu readd(PhysPt addr) {
src/cpu/paging.cpp:		Bitu needs_reset=InitPage(addr,false);
src/cpu/paging.cpp:	void writeb(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:		Bitu needs_reset=InitPage(addr,true);
src/cpu/paging.cpp:	void writew(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:		Bitu needs_reset=InitPage(addr,true);
src/cpu/paging.cpp:	void writed(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:		Bitu needs_reset=InitPage(addr,true);
src/cpu/paging.cpp:	bool writeb_checked(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:	bool writew_checked(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:	bool writed_checked(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:	Bitu InitPage(Bitu lin_addr,bool writing) {
src/cpu/paging.cpp:		Bitu lin_page=lin_addr >> 12;
src/cpu/paging.cpp:		Bitu phys_page;
src/cpu/paging.cpp:			Bitu priv_check=0;
src/cpu/paging.cpp:	bool InitPageCheckOnly(Bitu lin_addr,bool writing) {
src/cpu/paging.cpp:		Bitu lin_page=lin_addr >> 12;
src/cpu/paging.cpp:			Bitu phys_page;
src/cpu/paging.cpp:	void InitPageForced(Bitu lin_addr) {
src/cpu/paging.cpp:		Bitu lin_page=lin_addr >> 12;
src/cpu/paging.cpp:		Bitu phys_page;
src/cpu/paging.cpp:	void writeb(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:	void writew(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:	void writed(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:	bool writeb_checked(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:		Bitu writecode=InitPageCheckOnly(addr,(Bit8u)(val&0xff));
src/cpu/paging.cpp:	bool writew_checked(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:		Bitu writecode=InitPageCheckOnly(addr,(Bit16u)(val&0xffff));
src/cpu/paging.cpp:	bool writed_checked(PhysPt addr,Bitu val) {
src/cpu/paging.cpp:		Bitu writecode=InitPageCheckOnly(addr,(Bit32u)val);
src/cpu/paging.cpp:	void InitPage(Bitu lin_addr,Bitu val) {
src/cpu/paging.cpp:		Bitu lin_page=lin_addr >> 12;
src/cpu/paging.cpp:		Bitu phys_page;
src/cpu/paging.cpp:	Bitu InitPageCheckOnly(Bitu lin_addr,Bitu val) {
src/cpu/paging.cpp:		Bitu lin_page=lin_addr >> 12;
src/cpu/paging.cpp:			Bitu phys_page;
src/cpu/paging.cpp:	void InitPageForced(Bitu lin_addr) {
src/cpu/paging.cpp:		Bitu lin_page=lin_addr >> 12;
src/cpu/paging.cpp:		Bitu phys_page;
src/cpu/paging.cpp:bool PAGING_MakePhysPage(Bitu & page) {
src/cpu/paging.cpp:		Bitu d_index=page >> 10;
src/cpu/paging.cpp:		Bitu t_index=page & 0x3ff;
src/cpu/paging.cpp:Bitu PAGING_GetDirBase(void) {
src/cpu/paging.cpp:bool PAGING_ForcePageInit(Bitu lin_addr) {
src/cpu/paging.cpp:	for (Bitu i=0;i<TLB_SIZE;i++) {
src/cpu/paging.cpp:		Bitu page=*entries++;
src/cpu/paging.cpp:void PAGING_UnlinkPages(Bitu lin_page,Bitu pages) {
src/cpu/paging.cpp:void PAGING_MapPage(Bitu lin_page,Bitu phys_page) {
src/cpu/paging.cpp:void PAGING_LinkPage(Bitu lin_page,Bitu phys_page) {
src/cpu/paging.cpp:	Bitu lin_base=lin_page << 12;
src/cpu/paging.cpp:void PAGING_LinkPage_ReadOnly(Bitu lin_page,Bitu phys_page) {
src/cpu/paging.cpp:	Bitu lin_base=lin_page << 12;
src/cpu/paging.cpp: 	for (Bitu i=0;i<TLB_SIZE;i++) {
src/cpu/paging.cpp:		Bitu page=*entries++;
src/cpu/paging.cpp:void PAGING_UnlinkPages(Bitu lin_page,Bitu pages) {
src/cpu/paging.cpp:void PAGING_MapPage(Bitu lin_page,Bitu phys_page) {
src/cpu/paging.cpp:void PAGING_LinkPage(Bitu lin_page,Bitu phys_page) {
src/cpu/paging.cpp:	Bitu lin_base=lin_page << 12;
src/cpu/paging.cpp:void PAGING_LinkPage_ReadOnly(Bitu lin_page,Bitu phys_page) {
src/cpu/paging.cpp:	Bitu lin_base=lin_page << 12;
src/cpu/paging.cpp:void PAGING_SetDirBase(Bitu cr3) {
src/cpu/paging.cpp:		Bitu i;
src/cpu/callback.cpp:static Bitu call_stop,call_idle,call_default,call_default2;
src/cpu/callback.cpp:Bitu call_priv_io;
src/cpu/callback.cpp:static Bitu illegal_handler(void) {
src/cpu/callback.cpp:Bitu CALLBACK_Allocate(void) {
src/cpu/callback.cpp:	for (Bitu i=1;(i<CB_MAX);i++) {
src/cpu/callback.cpp:void CALLBACK_DeAllocate(Bitu in) {
src/cpu/callback.cpp:	Bitu oldIF=GETFLAG(IF);
src/cpu/callback.cpp:static Bitu default_handler(void) {
src/cpu/callback.cpp:static Bitu stop_handler(void) {
src/cpu/callback.cpp:void CALLBACK_SetDescription(Bitu nr, const char* descr) {
src/cpu/callback.cpp:const char* CALLBACK_GetDescription(Bitu nr) {
src/cpu/callback.cpp:Bitu CALLBACK_SetupExtra(Bitu callback, Bitu type, PhysPt physAddress, bool use_cb=true) {
src/cpu/callback.cpp:		for (Bitu i=0;i<=0x0b;i++) phys_writeb(physAddress+0x02+i,0x90);
src/cpu/callback.cpp:bool CALLBACK_Setup(Bitu callback,CallBack_Handler handler,Bitu type,const char* descr) {
src/cpu/callback.cpp:Bitu CALLBACK_Setup(Bitu callback,CallBack_Handler handler,Bitu type,PhysPt addr,const char* descr) {
src/cpu/callback.cpp:	Bitu csize=CALLBACK_SetupExtra(callback,type,addr,(handler!=NULL));
src/cpu/callback.cpp:void CALLBACK_RemoveSetup(Bitu callback) {
src/cpu/callback.cpp:	for (Bitu i = 0;i < CB_SIZE;i++) {
src/cpu/callback.cpp:void CALLBACK_HandlerObject::Install(CallBack_Handler handler,Bitu type,const char* description){
src/cpu/callback.cpp:void CALLBACK_HandlerObject::Install(CallBack_Handler handler,Bitu type,PhysPt addr,const char* description){
src/cpu/callback.cpp:	Bitu i;
Binary file src/cpu/callback.o matches
src/cpu/core_dyn_x86.cpp:	Bitu flags;
src/cpu/core_dyn_x86.cpp:	Bitu ea,tmpb,tmpd,stack,shift,newesp;
src/cpu/core_dyn_x86.cpp:	Bitu callback;
src/cpu/core_dyn_x86.cpp:	for (Bitu i=0;i<G_MAX;i++) {
src/cpu/core_dyn_x86.cpp:	for (Bitu i=0;i<G_MAX;i++) {
src/cpu/core_dyn_x86.cpp:	for (Bitu i=0;i<G_MAX;i++) {
src/cpu/core_dyn_x86.cpp:			Bitu old_cycles=CPU_Cycles;
src/cpu/core_dyn_x86.cpp:			Bitu temp_ip=SegPhys(cs)+reg_eip;
Binary file src/cpu/core_normal.o matches
src/cpu/core_normal.cpp:extern Bitu cycle_count;
src/cpu/core_normal.cpp:	Bitu opcode_index;
src/cpu/core_normal.cpp:	Bitu prefixes;
src/cpu/core_normal.cpp:				Bitu len=(GETIP-reg_eip);
src/cpu/core_dynrec/dyn_fpu.h:static void FPU_FFREE(Bitu st) {
src/cpu/core_dynrec/dyn_fpu.h:	Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dynrec/decoder_basic.h:	Bitu cycles;			// number cycles used by currently translated code
src/cpu/core_dynrec/decoder_basic.h:		Bitu index;		// index to the current byte of the instruction stream
src/cpu/core_dynrec/decoder_basic.h:		Bitu first;		// page number 
src/cpu/core_dynrec/decoder_basic.h:		Bitu val;
src/cpu/core_dynrec/decoder_basic.h:		Bitu mod;
src/cpu/core_dynrec/decoder_basic.h:		Bitu rm;
src/cpu/core_dynrec/decoder_basic.h:		Bitu reg;
src/cpu/core_dynrec/decoder_basic.h:static bool MakeCodePage(Bitu lin_addr,CodePageHandlerDynRec * &cph) {
src/cpu/core_dynrec/decoder_basic.h:	Bitu lin_page=lin_addr>>12;
src/cpu/core_dynrec/decoder_basic.h:	Bitu phys_page=lin_page;
src/cpu/core_dynrec/decoder_basic.h:	Bitu faddr=decode.page.first << 12;
src/cpu/core_dynrec/decoder_basic.h:static void INLINE decode_increase_wmapmask(Bitu size) {
src/cpu/core_dynrec/decoder_basic.h:	Bitu mapidx;
src/cpu/core_dynrec/decoder_basic.h:			Bitu newmasklen=activecb->cache.masklen*4;
src/cpu/core_dynrec/decoder_basic.h:static bool decode_fetchb_imm(Bitu & val) {
src/cpu/core_dynrec/decoder_basic.h:			val=(Bitu)(tlb_addr+decode.code);
src/cpu/core_dynrec/decoder_basic.h:static bool decode_fetchw_imm(Bitu & val) {
src/cpu/core_dynrec/decoder_basic.h:				val=(Bitu)(tlb_addr+decode.code);
src/cpu/core_dynrec/decoder_basic.h:static bool decode_fetchd_imm(Bitu & val) {
src/cpu/core_dynrec/decoder_basic.h:				val=(Bitu)(tlb_addr+decode.code);
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_R(void * func,Bitu op) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_R3(void * func,Bitu op) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_RI(void * func,Bitu op1,Bitu op2) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_RA(void * func,Bitu op1,DRC_PTR_SIZE_IM op2) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_RR(void * func,Bitu op1,Bitu op2) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_IR(void * func,Bitu op1,Bitu op2) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_I(void * func,Bitu op) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_II(void * func,Bitu op1,Bitu op2) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_III(void * func,Bitu op1,Bitu op2,Bitu op3) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_IA(void * func,Bitu op1,DRC_PTR_SIZE_IM op2) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_IIR(void * func,Bitu op1,Bitu op2,Bitu op3) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_IIIR(void * func,Bitu op1,Bitu op2,Bitu op3,Bitu op4) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_IRRR(void * func,Bitu op1,Bitu op2,Bitu op3,Bitu op4) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_m(void * func,Bitu op) {
src/cpu/core_dynrec/decoder_basic.h:static DRC_PTR_SIZE_IM INLINE gen_call_function_mm(void * func,Bitu op1,Bitu op2) {
src/cpu/core_dynrec/decoder_basic.h:	Bitu cycles;
src/cpu/core_dynrec/decoder_basic.h:Bitu used_save_info_dynrec=0;
src/cpu/core_dynrec/decoder_basic.h:	for (Bitu sct=0; sct<used_save_info_dynrec; sct++) {
src/cpu/core_dynrec/decoder_basic.h:static void dyn_lea_mem_mem(HostReg ea_reg,void* op1,void* op2,Bitu scale,Bits imm) {
src/cpu/core_dynrec/decoder_basic.h:static void dyn_lea_regval_regval(HostReg ea_reg,Bitu op1_index,Bitu op2_index,Bitu scale,Bits imm) {
src/cpu/core_dynrec/decoder_basic.h:static void dyn_lea_mem_regval(HostReg ea_reg,void* op1,Bitu op2_index,Bitu scale,Bits imm) {
src/cpu/core_dynrec/decoder_basic.h:static void dyn_lea_segphys_regval(HostReg ea_reg,Bitu op1_index,Bitu op2_index,Bitu scale,Bits imm) {
src/cpu/core_dynrec/decoder_basic.h:static void dyn_lea_segphys_mem(HostReg ea_reg,Bitu op1_index,void* op2,Bitu scale,Bits imm) {
src/cpu/core_dynrec/decoder_basic.h:		Bitu scale=0;
src/cpu/core_dynrec/decoder_basic.h:				Bitu sib=decode_fetchb();
src/cpu/core_dynrec/decoder_basic.h:						Bitu val;
src/cpu/core_dynrec/decoder_basic.h:					Bitu val;
src/cpu/core_dynrec/decoder_basic.h:			Bitu val;
src/cpu/core_dynrec/decoder_basic.h:static void dyn_add_iocheck(HostReg reg_port,Bitu access_size) {
src/cpu/core_dynrec/decoder_basic.h:static void dyn_add_iocheck_var(Bit8u accessed_port,Bitu access_size) {
src/cpu/core_dynrec/decoder_basic.h:static Bitu mf_functions_num=0;
src/cpu/core_dynrec/decoder_basic.h:	Bitu ftype;
src/cpu/core_dynrec/decoder_basic.h:	for (Bitu ct=0; ct<mf_functions_num; ct++) {
src/cpu/core_dynrec/decoder_basic.h:static void InvalidateFlags(void* current_simple_function,Bitu flags_type) {
src/cpu/core_dynrec/decoder_basic.h:	for (Bitu ct=0; ct<mf_functions_num; ct++) {
src/cpu/core_dynrec/decoder_basic.h:static void InvalidateFlagsPartially(void* current_simple_function,Bitu flags_type) {
src/cpu/core_dynrec/decoder_basic.h:static void InvalidateFlagsPartially(void* current_simple_function,DRC_PTR_SIZE_IM cpos,Bitu flags_type) {
src/cpu/core_dynrec/decoder_basic.h:static void AcquireFlags(Bitu flags_mask) {
src/cpu/core_dynrec/risc_armv4le-common.h:static void cache_block_closing(Bit8u* block_start,Bitu block_size) {
src/cpu/core_dynrec/decoder_opcodes.h:	Bitu val;
src/cpu/core_dynrec/decoder_opcodes.h:	Bitu val;
src/cpu/core_dynrec/decoder_opcodes.h:static void dyn_dop_word_imm_old(DualOps op,Bit8u reg,Bitu imm) {
src/cpu/core_dynrec/decoder_opcodes.h:	Bitu val;
src/cpu/core_dynrec/decoder_opcodes.h:static void dyn_mov_byte_al_direct(Bitu imm) {
src/cpu/core_dynrec/decoder_opcodes.h:static void dyn_mov_byte_ax_direct(Bitu imm) {
src/cpu/core_dynrec/decoder_opcodes.h:		Bitu val;
src/cpu/core_dynrec/decoder_opcodes.h:static void dyn_mov_byte_direct_ax(Bitu imm) {
src/cpu/core_dynrec/decoder_opcodes.h:static void dyn_push_word_imm(Bitu imm) {
src/cpu/core_dynrec/decoder_opcodes.h:static void dyn_imul_gvev(Bitu immsize) {
src/cpu/core_dynrec/decoder_opcodes.h:		Bitu val;
src/cpu/core_dynrec/decoder_opcodes.h:static Bitu dyn_grp4_ev(void) {
src/cpu/core_dynrec/decoder_opcodes.h:	Bitu eip_base=decode.code-decode.code_start;
src/cpu/core_dynrec/decoder_opcodes.h:	Bitu eip_base=decode.code-decode.code_start;
src/cpu/core_dynrec/decoder_opcodes.h:static void dyn_ret_near(Bitu bytes) {
src/cpu/core_dynrec/decoder_opcodes.h:static void dyn_ret_far(Bitu bytes) {
src/cpu/core_dynrec/decoder_opcodes.h:	Bitu sel,off;
src/cpu/core_dynrec/decoder_opcodes.h:	Bitu sel,off;
src/cpu/core_dynrec/decoder_opcodes.h:			if (decode.big_addr) gen_call_function_mm((void*)&dynrec_movsb_dword,(Bitu)DRCD_SEG_PHYS(di_base_addr),(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			else gen_call_function_mm((void*)&dynrec_movsb_word,(Bitu)DRCD_SEG_PHYS(di_base_addr),(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			if (decode.big_addr) gen_call_function_mm((void*)&dynrec_movsw_dword,(Bitu)DRCD_SEG_PHYS(di_base_addr),(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			else gen_call_function_mm((void*)&dynrec_movsw_word,(Bitu)DRCD_SEG_PHYS(di_base_addr),(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			if (decode.big_addr) gen_call_function_mm((void*)&dynrec_movsd_dword,(Bitu)DRCD_SEG_PHYS(di_base_addr),(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			else gen_call_function_mm((void*)&dynrec_movsd_word,(Bitu)DRCD_SEG_PHYS(di_base_addr),(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			if (decode.big_addr) gen_call_function_m((void*)&dynrec_lodsb_dword,(Bitu)DRCD_SEG_PHYS(di_base_addr));
src/cpu/core_dynrec/decoder_opcodes.h:			else gen_call_function_m((void*)&dynrec_lodsb_word,(Bitu)DRCD_SEG_PHYS(di_base_addr));
src/cpu/core_dynrec/decoder_opcodes.h:			if (decode.big_addr) gen_call_function_m((void*)&dynrec_lodsw_dword,(Bitu)DRCD_SEG_PHYS(di_base_addr));
src/cpu/core_dynrec/decoder_opcodes.h:			else gen_call_function_m((void*)&dynrec_lodsw_word,(Bitu)DRCD_SEG_PHYS(di_base_addr));
src/cpu/core_dynrec/decoder_opcodes.h:			if (decode.big_addr) gen_call_function_m((void*)&dynrec_lodsd_dword,(Bitu)DRCD_SEG_PHYS(di_base_addr));
src/cpu/core_dynrec/decoder_opcodes.h:			else gen_call_function_m((void*)&dynrec_lodsd_word,(Bitu)DRCD_SEG_PHYS(di_base_addr));
src/cpu/core_dynrec/decoder_opcodes.h:			if (decode.big_addr) gen_call_function_m((void*)&dynrec_stosb_dword,(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			else gen_call_function_m((void*)&dynrec_stosb_word,(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			if (decode.big_addr) gen_call_function_m((void*)&dynrec_stosw_dword,(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			else gen_call_function_m((void*)&dynrec_stosw_word,(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			if (decode.big_addr) gen_call_function_m((void*)&dynrec_stosd_dword,(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:			else gen_call_function_m((void*)&dynrec_stosd_word,(Bitu)DRCD_SEG_PHYS(DRC_SEG_ES));
src/cpu/core_dynrec/decoder_opcodes.h:	Bitu bytes=decode_fetchw();
src/cpu/core_dynrec/decoder_opcodes.h:	Bitu level=decode_fetchb();
src/cpu/core_dynrec/decoder_opcodes.h:	Bitu tmpesp = reg_esp;
src/cpu/core_dynrec/cache.h:	void LinkTo(Bitu index,CacheBlockDynRec * toblock) {
src/cpu/core_dynrec/cache.h:		Bitu size;
src/cpu/core_dynrec/cache.h:		Bitu index;
src/cpu/core_dynrec/cache.h:	void SetupAt(Bitu _phys_page,PageHandler * _old_pagehandler) {
src/cpu/core_dynrec/cache.h:	bool InvalidateRange(Bitu start,Bitu end) {
src/cpu/core_dynrec/cache.h:			Bitu map=0;
src/cpu/core_dynrec/cache.h:			for (Bitu count=start;count<=end;count++) map+=write_map[count];
src/cpu/core_dynrec/cache.h:	void writeb(PhysPt addr,Bitu val){
src/cpu/core_dynrec/cache.h:	void writew(PhysPt addr,Bitu val){
src/cpu/core_dynrec/cache.h:	void writed(PhysPt addr,Bitu val){
src/cpu/core_dynrec/cache.h:	bool writeb_checked(PhysPt addr,Bitu val) {
src/cpu/core_dynrec/cache.h:	bool writew_checked(PhysPt addr,Bitu val) {
src/cpu/core_dynrec/cache.h:	bool writed_checked(PhysPt addr,Bitu val) {
src/cpu/core_dynrec/cache.h:		Bitu index=1+(block->page.start>>DYN_HASH_SHIFT);
src/cpu/core_dynrec/cache.h:			for (Bitu i=block->page.start;i<block->cache.maskstart;i++) {
src/cpu/core_dynrec/cache.h:			Bitu maskct=0;
src/cpu/core_dynrec/cache.h:			for (Bitu i=block->cache.maskstart;i<=block->page.end;i++,maskct++) {
src/cpu/core_dynrec/cache.h:			for (Bitu i=block->page.start;i<=block->page.end;i++) {
src/cpu/core_dynrec/cache.h:		for (Bitu index=0;index<(1+DYN_PAGE_HASH);index++) {
src/cpu/core_dynrec/cache.h:	CacheBlockDynRec * FindCacheBlock(Bitu start) {
src/cpu/core_dynrec/cache.h:	HostPt GetHostReadPt(Bitu phys_page) { 
src/cpu/core_dynrec/cache.h:	HostPt GetHostWritePt(Bitu phys_page) { 
src/cpu/core_dynrec/cache.h:	Bitu active_blocks;		// the number of cache blocks in this page
src/cpu/core_dynrec/cache.h:	Bitu active_count;		// delaying parameter to not immediately release a page
src/cpu/core_dynrec/cache.h:	Bitu phys_page;
src/cpu/core_dynrec/cache.h:	Bitu ind;
src/cpu/core_dynrec/cache.h:	Bitu size=block->cache.size;
src/cpu/core_dynrec/cache.h:	Bitu written=(Bitu)(cache.pos-block->cache.start);
src/cpu/core_dynrec/cache.h:		Bitu new_size;
src/cpu/core_dynrec/cache.h:		Bitu left=block->cache.size-written;
src/cpu/core_dynrec/cache.h:			cache_code=(Bit8u*)(((Bitu)cache_code_start_ptr + PAGESIZE_TEMP-1) & ~(PAGESIZE_TEMP-1));//Bitu is same size as a pointer.
src/cpu/core_dynrec/operators.h:	return (Bit8u)(op1+op2+(Bitu)(get_CF()!=0));
src/cpu/core_dynrec/operators.h:	return (Bit8u)(op1-(op2+(Bitu)(get_CF()!=0)));
src/cpu/core_dynrec/operators.h:	return (Bit16u)(op1+op2+(Bitu)(get_CF()!=0));
src/cpu/core_dynrec/operators.h:	return (Bit16u)(op1-(op2+(Bitu)(get_CF()!=0)));
src/cpu/core_dynrec/operators.h:	return op1+op2+(Bitu)(get_CF()!=0);
src/cpu/core_dynrec/operators.h:	return op1-(op2+(Bitu)(get_CF()!=0));
src/cpu/core_dynrec/operators.h:	Bitu tempu=(Bitu)reg_ax*(Bitu)op;
src/cpu/core_dynrec/operators.h:	Bitu val=op;
src/cpu/core_dynrec/operators.h:	Bitu quo=reg_ax / val;
src/cpu/core_dynrec/operators.h:	Bitu val=op;
src/cpu/core_dynrec/operators.h:	Bitu num=((Bit32u)reg_dx<<16)|reg_ax;
src/cpu/core_dynrec/operators.h:	Bitu quo=num/val;
src/cpu/core_dynrec/operators.h:	Bitu val=op;
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/operators.h:	if (count<(Bitu)CPU_Cycles) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:		cache_datapos = (Bit8u *) (((Bitu)cache.block.active->cache.start + cache.block.active->cache.size - CACHE_DATA_ALIGN) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:			cache_datapos = (Bit8u *) (((Bitu)cache.pos + CACHE_DATA_MAX) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:			cache_datapos = (Bit8u *) (((Bitu)cache.pos + (CACHE_MAXSIZE - CACHE_DATA_ALIGN) - cachemodsize) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:			cache_datapos = (Bit8u *) (((Bitu)cache.block.active->cache.start + CACHE_DATA_MAX) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:				cache_datapos = (Bit8u *) (((Bitu)cache.block.active->cache.start + cache.block.active->cache.size - CACHE_DATA_ALIGN) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:					cache_datapos = (Bit8u *) (((Bitu)cache.pos + CACHE_DATA_MAX) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:					cache_datapos = (Bit8u *) (((Bitu)cache.pos + (CACHE_MAXSIZE - CACHE_DATA_ALIGN) - cachemodsize) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static bool gen_mov_memval_to_reg_helper(HostReg dest_reg, Bit32u data, Bitu size, HostReg addr_reg, Bit32u addr_data) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static bool gen_mov_memval_to_reg(HostReg dest_reg, void *data, Bitu size) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static bool gen_mov_memval_from_reg_helper(HostReg src_reg, Bit32u data, Bitu size, HostReg addr_reg, Bit32u addr_data) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static bool gen_mov_memval_from_reg(HostReg src_reg, void *dest, Bitu size) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static INLINE void gen_lea(HostReg dest_reg,HostReg scale_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static INLINE void gen_lea(HostReg dest_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static Bit32u INLINE gen_call_function_setup(void * func,Bitu paramcount,bool fastcall=false) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void INLINE gen_load_param_imm(Bitu imm,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void INLINE gen_load_param_addr(Bitu addr,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void INLINE gen_load_param_reg(Bitu reg,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void INLINE gen_load_param_mem(Bitu mem,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:	if ((((Bitu)cache.pos) & 0x1f) != 0) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:		cache.pos = cache.pos + (32 - (((Bitu)cache.pos) & 0x1f));
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:	if ((((Bitu)cache.pos) & 0x1f) != 0) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:		cache.pos = cache.pos + (32 - (((Bitu)cache.pos) & 0x1f));
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_fill_function_ptr(Bit8u * pos,void* fct_ptr,Bitu flags_type) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_mov_seg16_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_mov_seg32_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_add_seg32_to_reg(HostReg reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_mov_regval16_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_mov_regval32_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_mov_regword_to_reg(HostReg dest_reg,Bitu index,bool dword) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_mov_regbyte_to_reg_low(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void INLINE gen_mov_regbyte_to_reg_low_canuseword(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_add_regval32_to_reg(HostReg reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_mov_regval16_from_reg(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_mov_regval32_from_reg(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_mov_regword_from_reg(HostReg src_reg,Bitu index,bool dword) {
src/cpu/core_dynrec/risc_armv4le-thumb-niw.h:static void gen_mov_regbyte_from_reg_low(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static INLINE void gen_lea(HostReg dest_reg,HostReg scale_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_mipsel32.h:static INLINE void gen_lea(HostReg dest_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_mipsel32.h:static Bit32u INLINE gen_call_function_setup(void * func,Bitu paramcount,bool fastcall=false) {
src/cpu/core_dynrec/risc_mipsel32.h:static void INLINE gen_load_param_imm(Bitu imm,Bitu param) {
src/cpu/core_dynrec/risc_mipsel32.h:static void INLINE gen_load_param_addr(Bitu addr,Bitu param) {
src/cpu/core_dynrec/risc_mipsel32.h:static void INLINE gen_load_param_reg(Bitu reg,Bitu param) {
src/cpu/core_dynrec/risc_mipsel32.h:static void INLINE gen_load_param_mem(Bitu mem,Bitu param) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_fill_function_ptr(Bit8u * pos,void* fct_ptr,Bitu flags_type) {
src/cpu/core_dynrec/risc_mipsel32.h:static void cache_block_closing(Bit8u* block_start,Bitu block_size) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_mov_seg16_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_mov_seg32_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_add_seg32_to_reg(HostReg reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_mov_regval16_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_mov_regval32_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_mov_regword_to_reg(HostReg dest_reg,Bitu index,bool dword) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_mov_regbyte_to_reg_low(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static void INLINE gen_mov_regbyte_to_reg_low_canuseword(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_add_regval32_to_reg(HostReg reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_mov_regval16_from_reg(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_mov_regval32_from_reg(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_mov_regword_from_reg(HostReg src_reg,Bitu index,bool dword) {
src/cpu/core_dynrec/risc_mipsel32.h:static void gen_mov_regbyte_from_reg_low(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static bool gen_mov_memval_to_reg_helper(HostReg dest_reg, Bit32u data, Bitu size, HostReg addr_reg, Bit32u addr_data) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static bool gen_mov_memval_to_reg(HostReg dest_reg, void *data, Bitu size) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static bool gen_mov_memval_from_reg_helper(HostReg src_reg, Bit32u data, Bitu size, HostReg addr_reg, Bit32u addr_data) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static bool gen_mov_memval_from_reg(HostReg src_reg, void *dest, Bitu size) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static INLINE void gen_lea(HostReg dest_reg,HostReg scale_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static INLINE void gen_lea(HostReg dest_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static Bit32u INLINE gen_call_function_setup(void * func,Bitu paramcount,bool fastcall=false) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void INLINE gen_load_param_imm(Bitu imm,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void INLINE gen_load_param_addr(Bitu addr,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void INLINE gen_load_param_reg(Bitu reg,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void INLINE gen_load_param_mem(Bitu mem,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:	if ((((Bitu)cache.pos) & 0x1f) != 0) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:		cache.pos = cache.pos + (32 - (((Bitu)cache.pos) & 0x1f));
src/cpu/core_dynrec/risc_armv4le-thumb.h:	if ((((Bitu)cache.pos) & 0x1f) != 0) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:		cache.pos = cache.pos + (32 - (((Bitu)cache.pos) & 0x1f));
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_fill_function_ptr(Bit8u * pos,void* fct_ptr,Bitu flags_type) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_mov_seg16_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_mov_seg32_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_add_seg32_to_reg(HostReg reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_mov_regval16_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_mov_regval32_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_mov_regword_to_reg(HostReg dest_reg,Bitu index,bool dword) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_mov_regbyte_to_reg_low(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void INLINE gen_mov_regbyte_to_reg_low_canuseword(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_add_regval32_to_reg(HostReg reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_mov_regval16_from_reg(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_mov_regval32_from_reg(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_mov_regword_from_reg(HostReg src_reg,Bitu index,bool dword) {
src/cpu/core_dynrec/risc_armv4le-thumb.h:static void gen_mov_regbyte_from_reg_low(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_x86.h:static INLINE void gen_lea(HostReg dest_reg,HostReg scale_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_x86.h:	Bitu imm_size;
src/cpu/core_dynrec/risc_x86.h:static INLINE void gen_lea(HostReg dest_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_x86.h:static Bit32u INLINE gen_call_function_setup(void * func,Bitu paramcount,bool fastcall=false) {
src/cpu/core_dynrec/risc_x86.h:static void INLINE gen_load_param_imm(Bitu imm,Bitu param) {
src/cpu/core_dynrec/risc_x86.h:static void INLINE gen_load_param_addr(Bitu addr,Bitu param) {
src/cpu/core_dynrec/risc_x86.h:static void INLINE gen_load_param_reg(Bitu reg,Bitu param) {
src/cpu/core_dynrec/risc_x86.h:static void INLINE gen_load_param_mem(Bitu mem,Bitu param) {
src/cpu/core_dynrec/risc_x86.h:static void gen_fill_function_ptr(Bit8u * pos,void* fct_ptr,Bitu flags_type) {
src/cpu/core_dynrec/risc_x86.h:static void cache_block_closing(Bit8u* block_start,Bitu block_size) { }
src/cpu/core_dynrec/risc_armv4le-o3.h:static bool gen_mov_memval_to_reg_helper(HostReg dest_reg, Bit32u data, Bitu size, HostReg addr_reg, Bit32u addr_data) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static bool gen_mov_memval_to_reg(HostReg dest_reg, void *data, Bitu size) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static bool gen_mov_memval_from_reg_helper(HostReg src_reg, Bit32u data, Bitu size, HostReg addr_reg, Bit32u addr_data) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static bool gen_mov_memval_from_reg(HostReg src_reg, void *dest, Bitu size) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static INLINE void gen_lea(HostReg dest_reg,HostReg scale_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static INLINE void gen_lea(HostReg dest_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static Bit32u INLINE gen_call_function_setup(void * func,Bitu paramcount,bool fastcall=false) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void INLINE gen_load_param_imm(Bitu imm,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void INLINE gen_load_param_addr(Bitu addr,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void INLINE gen_load_param_reg(Bitu reg,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void INLINE gen_load_param_mem(Bitu mem,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-o3.h:	cache_addd( MOVW(readdata_addr, ((Bitu)&core_dynrec.readdata) & 0xffff) );      // movw readdata_addr, #(&core_dynrec.readdata & 0xffff)
src/cpu/core_dynrec/risc_armv4le-o3.h:	cache_addd( MOVT(readdata_addr, ((Bitu)&core_dynrec.readdata) >> 16) );      // movt readdata_addr, #(&core_dynrec.readdata >> 16)
src/cpu/core_dynrec/risc_armv4le-o3.h:	if ((((Bitu)cache.pos) & 0x1f) != 0) {
src/cpu/core_dynrec/risc_armv4le-o3.h:		cache.pos = cache.pos + (32 - (((Bitu)cache.pos) & 0x1f));
src/cpu/core_dynrec/risc_armv4le-o3.h:	if ((((Bitu)cache.pos) & 0x1f) != 0) {
src/cpu/core_dynrec/risc_armv4le-o3.h:		cache.pos = cache.pos + (32 - (((Bitu)cache.pos) & 0x1f));
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_fill_function_ptr(Bit8u * pos,void* fct_ptr,Bitu flags_type) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_seg16_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_seg32_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_add_seg32_to_reg(HostReg reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_regval16_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_regval32_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_regword_to_reg(HostReg dest_reg,Bitu index,bool dword) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_regbyte_to_reg_low(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_regbyte_to_reg_low_canuseword(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_add_regval32_to_reg(HostReg reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_regval16_from_reg(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_regval32_from_reg(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_regword_from_reg(HostReg src_reg,Bitu index,bool dword) {
src/cpu/core_dynrec/risc_armv4le-o3.h:static void gen_mov_regbyte_from_reg_low(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/decoder.h:static CacheBlockDynRec * CreateCacheBlock(CodePageHandlerDynRec * codepage,PhysPt start,Bitu max_opcodes) {
src/cpu/core_dynrec/decoder.h:		Bitu opcode;
src/cpu/core_dynrec/decoder.h:			Bitu dual_code=decode_fetchb();
src/cpu/core_dynrec/risc_x64.h:static INLINE void gen_memaddr(Bitu modreg,void* data,Bitu off,Bitu imm,Bit8u op,Bit8u prefix=0) {
src/cpu/core_dynrec/risc_x64.h:static INLINE void gen_lea(HostReg dest_reg,HostReg scale_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_x64.h:	Bitu imm_size;
src/cpu/core_dynrec/risc_x64.h:static INLINE void gen_lea(HostReg dest_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_x64.h:static Bit64u INLINE gen_call_function_setup(void * func,Bitu paramcount,bool fastcall=false) {
src/cpu/core_dynrec/risc_x64.h:static void INLINE gen_load_param_imm(Bitu imm,Bitu param) {
src/cpu/core_dynrec/risc_x64.h:static void INLINE gen_load_param_addr(DRC_PTR_SIZE_IM addr,Bitu param) {
src/cpu/core_dynrec/risc_x64.h:static void INLINE gen_load_param_reg(Bitu reg,Bitu param) {
src/cpu/core_dynrec/risc_x64.h:static void INLINE gen_load_param_mem(Bitu mem,Bitu param) {
src/cpu/core_dynrec/risc_x64.h:static void gen_fill_function_ptr(Bit8u * pos,void* fct_ptr,Bitu flags_type) {
src/cpu/core_dynrec/risc_x64.h:static void cache_block_closing(Bit8u* block_start,Bitu block_size) { }
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:		cache_datapos = (Bit8u *) (((Bitu)cache.block.active->cache.start + cache.block.active->cache.size - CACHE_DATA_ALIGN) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:			cache_datapos = (Bit8u *) (((Bitu)cache.pos + CACHE_DATA_MAX) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:			cache_datapos = (Bit8u *) (((Bitu)cache.pos + (CACHE_MAXSIZE - CACHE_DATA_ALIGN) - cachemodsize) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:			cache_datapos = (Bit8u *) (((Bitu)cache.block.active->cache.start + CACHE_DATA_MAX) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:				cache_datapos = (Bit8u *) (((Bitu)cache.block.active->cache.start + cache.block.active->cache.size - CACHE_DATA_ALIGN) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:					cache_datapos = (Bit8u *) (((Bitu)cache.pos + CACHE_DATA_MAX) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:					cache_datapos = (Bit8u *) (((Bitu)cache.pos + (CACHE_MAXSIZE - CACHE_DATA_ALIGN) - cachemodsize) & ~(CACHE_DATA_ALIGN - 1));
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static bool gen_mov_memval_to_reg_helper(HostReg dest_reg, Bit32u data, Bitu size, HostReg addr_reg, Bit32u addr_data) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static bool gen_mov_memval_to_reg(HostReg dest_reg, void *data, Bitu size) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static bool gen_mov_memval_from_reg_helper(HostReg src_reg, Bit32u data, Bitu size, HostReg addr_reg, Bit32u addr_data) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static bool gen_mov_memval_from_reg(HostReg src_reg, void *dest, Bitu size) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static INLINE void gen_lea(HostReg dest_reg,HostReg scale_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static INLINE void gen_lea(HostReg dest_reg,Bitu scale,Bits imm) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static Bit32u INLINE gen_call_function_setup(void * func,Bitu paramcount,bool fastcall=false) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void INLINE gen_load_param_imm(Bitu imm,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void INLINE gen_load_param_addr(Bitu addr,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void INLINE gen_load_param_reg(Bitu reg,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void INLINE gen_load_param_mem(Bitu mem,Bitu param) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:	if ((((Bitu)cache.pos) & 0x1f) != 0) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:		cache.pos = cache.pos + (32 - (((Bitu)cache.pos) & 0x1f));
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:	if ((((Bitu)cache.pos) & 0x1f) != 0) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:		cache.pos = cache.pos + (32 - (((Bitu)cache.pos) & 0x1f));
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_fill_function_ptr(Bit8u * pos,void* fct_ptr,Bitu flags_type) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_mov_seg16_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_mov_seg32_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_add_seg32_to_reg(HostReg reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_mov_regval16_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_mov_regval32_to_reg(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_mov_regword_to_reg(HostReg dest_reg,Bitu index,bool dword) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_mov_regbyte_to_reg_low(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void INLINE gen_mov_regbyte_to_reg_low_canuseword(HostReg dest_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_add_regval32_to_reg(HostReg reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_mov_regval16_from_reg(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_mov_regval32_from_reg(HostReg src_reg,Bitu index) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_mov_regword_from_reg(HostReg src_reg,Bitu index,bool dword) {
src/cpu/core_dynrec/risc_armv4le-thumb-iw.h:static void gen_mov_regbyte_from_reg_low(HostReg src_reg,Bitu index) {
Binary file src/cpu/paging.o matches
Binary file src/cpu/core_simple.o matches
Binary file src/cpu/flags.o matches
Binary file src/cpu/modrm.o matches
src/cpu/core_dyn_x86/dyn_fpu.h:static void FPU_FFREE(Bitu st) {
src/cpu/core_dyn_x86/dyn_fpu.h:	Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:		Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu.h:	Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:	Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu.h:	Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:	Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu.h:	Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:	Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu.h:	Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu.h:	Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/helpers.h:	Bitu quo=reg_ax / val;
src/cpu/core_dyn_x86/helpers.h:	Bitu num=(reg_dx<<16)|reg_ax;
src/cpu/core_dyn_x86/helpers.h:	Bitu quo=num/val;
src/cpu/core_dyn_x86/cache.h:	void LinkTo(Bitu index,CacheBlock * toblock) {
src/cpu/core_dyn_x86/cache.h:		Bitu size;
src/cpu/core_dyn_x86/cache.h:		Bitu index;
src/cpu/core_dyn_x86/cache.h:	void SetupAt(Bitu _phys_page,PageHandler * _old_pagehandler) {
src/cpu/core_dyn_x86/cache.h:	bool InvalidateRange(Bitu start,Bitu end) {
src/cpu/core_dyn_x86/cache.h:			Bitu map=0;
src/cpu/core_dyn_x86/cache.h:			for (Bitu count=start;count<=end;count++) map+=write_map[count];
src/cpu/core_dyn_x86/cache.h:	void writeb(PhysPt addr,Bitu val){
src/cpu/core_dyn_x86/cache.h:	void writew(PhysPt addr,Bitu val){
src/cpu/core_dyn_x86/cache.h:	void writed(PhysPt addr,Bitu val){
src/cpu/core_dyn_x86/cache.h:	bool writeb_checked(PhysPt addr,Bitu val) {
src/cpu/core_dyn_x86/cache.h:	bool writew_checked(PhysPt addr,Bitu val) {
src/cpu/core_dyn_x86/cache.h:	bool writed_checked(PhysPt addr,Bitu val) {
src/cpu/core_dyn_x86/cache.h:		Bitu index=1+(block->page.start>>DYN_HASH_SHIFT);
src/cpu/core_dyn_x86/cache.h:			for (Bitu i=block->page.start;i<block->cache.maskstart;i++) {
src/cpu/core_dyn_x86/cache.h:			Bitu maskct=0;
src/cpu/core_dyn_x86/cache.h:			for (Bitu i=block->cache.maskstart;i<=block->page.end;i++,maskct++) {
src/cpu/core_dyn_x86/cache.h:			for (Bitu i=block->page.start;i<=block->page.end;i++) {
src/cpu/core_dyn_x86/cache.h:		for (Bitu index=0;index<(1+DYN_PAGE_HASH);index++) {
src/cpu/core_dyn_x86/cache.h:	CacheBlock * FindCacheBlock(Bitu start) {
src/cpu/core_dyn_x86/cache.h:	HostPt GetHostReadPt(Bitu phys_page) { 
src/cpu/core_dyn_x86/cache.h:	HostPt GetHostWritePt(Bitu phys_page) { 
src/cpu/core_dyn_x86/cache.h:	Bitu active_blocks;
src/cpu/core_dyn_x86/cache.h:	Bitu active_count;
src/cpu/core_dyn_x86/cache.h:	Bitu phys_page;
src/cpu/core_dyn_x86/cache.h:	Bitu ind;
src/cpu/core_dyn_x86/cache.h:	Bitu size=block->cache.size;
src/cpu/core_dyn_x86/cache.h:	Bitu written=cache.pos-block->cache.start;
src/cpu/core_dyn_x86/cache.h:		Bitu new_size;
src/cpu/core_dyn_x86/cache.h:		Bitu left=block->cache.size-written;
src/cpu/core_dyn_x86/cache.h:			cache_code=(Bit8u*)(((Bitu)cache_code_start_ptr + PAGESIZE_TEMP-1) & ~(PAGESIZE_TEMP-1)); //Bitu is same size as a pointer.
src/cpu/core_dyn_x86/cache.h:			cache_code=(Bit8u*)(((Bitu)cache_code_start_ptr + PAGESIZE_TEMP-1) & ~(PAGESIZE_TEMP-1)); //Bitu is same size as a pointer.
src/cpu/core_dyn_x86/cache.h:		for (Bitu i=0;i<CACHE_PAGES;i++) {
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		for(Bitu i=28;i<108;i++) mem_writeb(addr++,dyn_dh_fpu.temp_state[i]);
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		for(Bitu i=2;i<108;i++) mem_writeb(addr++,dyn_dh_fpu.temp_state[i]);
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		for(Bitu i=28;i<108;i++) dyn_dh_fpu.temp_state[i] = mem_readb(addr++);
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		for(Bitu i=0;i<108;i++) dyn_dh_fpu.temp_state[i] = mem_readb(addr++);
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu_dh.h:	Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu_dh.h:	Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu_dh.h:		Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu_dh.h:	Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu_dh.h:	Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/dyn_fpu_dh.h:	Bitu group=(decode.modrm.val >> 3) & 7;
src/cpu/core_dyn_x86/dyn_fpu_dh.h:	Bitu sub=(decode.modrm.val & 7);
src/cpu/core_dyn_x86/risc_x86.h:	Bitu last_used;
src/cpu/core_dyn_x86/risc_x86.h:	Bitu last_used;			//Keeps track of last assigned regs 
src/cpu/core_dyn_x86/risc_x86.h:		if (GCC_UNLIKELY((Bitu)dynreg)) Clear();
src/cpu/core_dyn_x86/risc_x86.h:		if (GCC_UNLIKELY(!((Bitu)dynreg))) IllegalOption("GenReg->Save");
src/cpu/core_dyn_x86/risc_x86.h:		if (GCC_UNLIKELY(!((Bitu)dynreg))) return;
src/cpu/core_dyn_x86/risc_x86.h:			if (genreg->last_used<(Bitu)first_used) {
src/cpu/core_dyn_x86/risc_x86.h:			if (genreg->last_used<(Bitu)first_used) {
src/cpu/core_dyn_x86/risc_x86.h:	for (Bitu i=0;i<X86_REGS;i++) {
src/cpu/core_dyn_x86/risc_x86.h:static void gen_load_host(void * data,DynReg * dr1,Bitu size) {
src/cpu/core_dyn_x86/risc_x86.h:static void gen_mov_host(void * data,DynReg * dr1,Bitu size,Bit8u di1=0) {
src/cpu/core_dyn_x86/risc_x86.h:static void gen_dop_byte_imm(DualOps op,DynReg * dr1,Bit8u di1,Bitu imm) {
src/cpu/core_dyn_x86/risc_x86.h:static void gen_lea(DynReg * ddr,DynReg * dsr1,DynReg * dsr2,Bitu scale,Bits imm) {
src/cpu/core_dyn_x86/risc_x86.h:	Bitu imm_size;
src/cpu/core_dyn_x86/risc_x86.h:static void gen_shift_byte_cl(Bitu op,DynReg * dr1,Bit8u di1,DynReg * drecx) {
src/cpu/core_dyn_x86/risc_x86.h:static void gen_shift_byte_imm(Bitu op,DynReg * dr1,Bit8u di1,Bit8u imm) {
src/cpu/core_dyn_x86/risc_x86.h:static void gen_shift_word_cl(Bitu op,bool dword,DynReg * dr1,DynReg * drecx) {
src/cpu/core_dyn_x86/risc_x86.h:static void gen_shift_word_imm(Bitu op,bool dword,DynReg * dr1,Bit8u imm) {
src/cpu/core_dyn_x86/risc_x86.h:static void gen_dshift_imm(bool dword,bool left,DynReg * dr1,DynReg * dr2,Bitu imm) {
src/cpu/core_dyn_x86/risc_x86.h:		Bitu value;
src/cpu/core_dyn_x86/risc_x86.h:		Bitu stack_used=0;
src/cpu/core_dyn_x86/risc_x86.h:				pinfo[pindex].value=va_arg(params,Bitu);
src/cpu/core_dyn_x86/risc_x86.h:static void gen_call_write(DynReg * dr,Bit32u val,Bitu write_size) {
src/cpu/core_dyn_x86/risc_x86.h:	Bitu stack_used=12;
src/cpu/core_dyn_x86/decoder.h:	Bitu cycles;
src/cpu/core_dyn_x86/decoder.h:		Bitu index;
src/cpu/core_dyn_x86/decoder.h:		Bitu first;
src/cpu/core_dyn_x86/decoder.h:		Bitu val;
src/cpu/core_dyn_x86/decoder.h:		Bitu mod;
src/cpu/core_dyn_x86/decoder.h:		Bitu rm;
src/cpu/core_dyn_x86/decoder.h:		Bitu reg;
src/cpu/core_dyn_x86/decoder.h:static bool MakeCodePage(Bitu lin_addr,CodePageHandler * &cph) {
src/cpu/core_dyn_x86/decoder.h:	Bitu lin_page=lin_addr >> 12;
src/cpu/core_dyn_x86/decoder.h:	Bitu phys_page=lin_page;
src/cpu/core_dyn_x86/decoder.h:		Bitu fetchaddr=decode.page.first << 12;
src/cpu/core_dyn_x86/decoder.h:static INLINE void decode_increase_wmapmask(Bitu size) {
src/cpu/core_dyn_x86/decoder.h:	Bitu mapidx;
src/cpu/core_dyn_x86/decoder.h:			Bitu newmasklen=activecb->cache.masklen*4;
src/cpu/core_dyn_x86/decoder.h:static bool decode_fetchb_imm(Bitu & val) {
src/cpu/core_dyn_x86/decoder.h:				val=(Bitu)(tlb_addr+decode.code);
src/cpu/core_dyn_x86/decoder.h:static bool decode_fetchw_imm(Bitu & val) {
src/cpu/core_dyn_x86/decoder.h:				val=(Bitu)(tlb_addr+decode.code);
src/cpu/core_dyn_x86/decoder.h:static bool decode_fetchd_imm(Bitu & val) {
src/cpu/core_dyn_x86/decoder.h:				val=(Bitu)(tlb_addr+decode.code);
src/cpu/core_dyn_x86/decoder.h:	Bitu cycles;
src/cpu/core_dyn_x86/decoder.h:Bitu used_save_info=0;
src/cpu/core_dyn_x86/decoder.h:	for (Bitu sct=0; sct<used_save_info; sct++) {
src/cpu/core_dyn_x86/decoder.h:static void dyn_read_byte(DynReg * addr,DynReg * dst,Bitu high) {
src/cpu/core_dyn_x86/decoder.h:static void dyn_write_byte(DynReg * addr,DynReg * val,Bitu high) {
src/cpu/core_dyn_x86/decoder.h:static void dyn_read_byte_release(DynReg * addr,DynReg * dst,Bitu high) {
src/cpu/core_dyn_x86/decoder.h:static void dyn_write_byte_release(DynReg * addr,DynReg * val,Bitu high) {
src/cpu/core_dyn_x86/decoder.h:static void dyn_read_byte(DynReg * addr,DynReg * dst,Bitu high) {
src/cpu/core_dyn_x86/decoder.h:static void dyn_read_byte_release(DynReg * addr,DynReg * dst,Bitu high) {
src/cpu/core_dyn_x86/decoder.h:		DynReg * base=0;DynReg * scaled=0;Bitu scale=0;
src/cpu/core_dyn_x86/decoder.h:				Bitu sib=decode_fetchb();
src/cpu/core_dyn_x86/decoder.h:						Bitu val;
src/cpu/core_dyn_x86/decoder.h:			Bitu val;
src/cpu/core_dyn_x86/decoder.h:	Bitu val;
src/cpu/core_dyn_x86/decoder.h:	Bitu val;
src/cpu/core_dyn_x86/decoder.h:	DynReg * rm_reg=&DynRegs[decode.modrm.reg&3];Bitu rm_regi=decode.modrm.reg&4;
src/cpu/core_dyn_x86/decoder.h:	DynReg * rm_reg=&DynRegs[decode.modrm.reg&3];Bitu rm_regi=decode.modrm.reg&4;
src/cpu/core_dyn_x86/decoder.h:static void dyn_imul_gvev(Bitu immsize) {
src/cpu/core_dyn_x86/decoder.h:		Bitu val;
src/cpu/core_dyn_x86/decoder.h:	Bitu bytes=decode_fetchw();
src/cpu/core_dyn_x86/decoder.h:	Bitu level=decode_fetchb();
src/cpu/core_dyn_x86/decoder.h://	if (GCC_UNLIKELY((Bitu)(decode.segprefix))) IllegalOption("dyn_segprefix");
src/cpu/core_dyn_x86/decoder.h:	Bitu eip_base=decode.code-decode.code_start;
src/cpu/core_dyn_x86/decoder.h:	Bitu eip_base=decode.code-decode.code_start;
src/cpu/core_dyn_x86/decoder.h:static void dyn_ret_near(Bitu bytes) {
src/cpu/core_dyn_x86/decoder.h:static void dyn_ret_far(Bitu bytes) {
src/cpu/core_dyn_x86/decoder.h:	Bitu sel,off;
src/cpu/core_dyn_x86/decoder.h:	Bitu sel,off;
src/cpu/core_dyn_x86/decoder.h:static void dyn_interrupt(Bitu num) {
src/cpu/core_dyn_x86/decoder.h:static void dyn_add_iocheck(Bitu access_size) {
src/cpu/core_dyn_x86/decoder.h:static void dyn_add_iocheck_var(Bit8u accessed_port,Bitu access_size) {
src/cpu/core_dyn_x86/decoder.h:static CacheBlock * CreateCacheBlock(CodePageHandler * codepage,PhysPt start,Bitu max_opcodes) {
src/cpu/core_dyn_x86/decoder.h:	Bitu cycles=0;
src/cpu/core_dyn_x86/decoder.h:		Bitu opcode;
src/cpu/core_dyn_x86/decoder.h:			Bitu dual_code=decode_fetchb();
src/cpu/core_dyn_x86/decoder.h:				Bitu val;
src/cpu/core_dyn_x86/decoder.h:			Bitu port=decode_fetchb();
src/cpu/core_dyn_x86/decoder.h:			Bitu port=decode_fetchb();
src/cpu/core_dyn_x86/decoder.h:			Bitu port=decode_fetchb();
src/cpu/core_dyn_x86/decoder.h:			Bitu port=decode_fetchb();
src/cpu/cpu.cpp:Bitu DEBUG_EnableDebugger(void);
src/cpu/cpu.cpp:Bitu CPU_AutoDetermineMode = 0;
src/cpu/cpu.cpp:Bitu CPU_ArchitectureType = CPU_ARCHTYPE_MIXED;
src/cpu/cpu.cpp:Bitu CPU_extflags_toggle=0;	// ID and AC flags may be toggled depending on emulated CPU architecture
src/cpu/cpu.cpp:Bitu CPU_PrefetchQueueSize=0;
src/cpu/cpu.cpp:void CPU_Push16(Bitu value) {
src/cpu/cpu.cpp:void CPU_Push32(Bitu value) {
src/cpu/cpu.cpp:Bitu CPU_Pop16(void) {
src/cpu/cpu.cpp:	Bitu val=mem_readw(SegPhys(ss) + (reg_esp & cpu.stack.mask));
src/cpu/cpu.cpp:Bitu CPU_Pop32(void) {
src/cpu/cpu.cpp:	Bitu val=mem_readd(SegPhys(ss) + (reg_esp & cpu.stack.mask));
src/cpu/cpu.cpp:PhysPt SelBase(Bitu sel) {
src/cpu/cpu.cpp:void CPU_SetFlags(Bitu word,Bitu mask) {
src/cpu/cpu.cpp:bool CPU_PrepareException(Bitu which,Bitu error) {
src/cpu/cpu.cpp:bool CPU_POPF(Bitu use32) {
src/cpu/cpu.cpp:	Bitu mask=FMASK_ALL;
src/cpu/cpu.cpp:bool CPU_PUSHF(Bitu use32) {
src/cpu/cpu.cpp:	Bitu Get_back(void) {
src/cpu/cpu.cpp:	void Get_SSx_ESPx(Bitu level,Bitu & _ss,Bitu & _esp) {
src/cpu/cpu.cpp:	bool SetSelector(Bitu new_sel) {
src/cpu/cpu.cpp:	Bitu selector;
src/cpu/cpu.cpp:	Bitu limit;
src/cpu/cpu.cpp:	Bitu is386;
src/cpu/cpu.cpp:bool CPU_SwitchTask(Bitu new_tss_selector,TSwitchType tstype,Bitu old_eip) {
src/cpu/cpu.cpp:	Bitu new_cr3=0;
src/cpu/cpu.cpp:	Bitu new_eax,new_ebx,new_ecx,new_edx,new_esp,new_ebp,new_esi,new_edi;
src/cpu/cpu.cpp:	Bitu new_es,new_cs,new_ss,new_ds,new_fs,new_gs;
src/cpu/cpu.cpp:	Bitu new_ldt,new_eip,new_eflags;
src/cpu/cpu.cpp:bool CPU_IO_Exception(Bitu port,Bitu size) {
src/cpu/cpu.cpp:		Bitu ofs=mem_readw(bwhere);
src/cpu/cpu.cpp:		Bitu map=mem_readw(bwhere);
src/cpu/cpu.cpp:		Bitu mask=(0xffff>>(16-size)) << (port&7);
src/cpu/cpu.cpp:void CPU_Exception(Bitu which,Bitu error ) {
src/cpu/cpu.cpp:void CPU_Interrupt(Bitu num,Bitu type,Bitu oldeip) {
src/cpu/cpu.cpp:				Bitu gate_sel=gate.GetSelector();
src/cpu/cpu.cpp:				Bitu gate_off=gate.GetOffset();
src/cpu/cpu.cpp:				Bitu cs_dpl=cs_desc.DPL();
src/cpu/cpu.cpp:						Bitu n_ss,n_esp;
src/cpu/cpu.cpp:						Bitu o_ss,o_esp;
src/cpu/cpu.cpp:void CPU_IRET(bool use32,Bitu oldeip) {
src/cpu/cpu.cpp:			Bitu back_link=cpu_tss.Get_back();
src/cpu/cpu.cpp:		Bitu n_cs_sel,n_eip,n_flags;
src/cpu/cpu.cpp:				Bitu n_ss,n_esp,n_es,n_ds,n_fs,n_gs;
src/cpu/cpu.cpp:		Bitu n_cs_rpl=n_cs_sel & 3;
src/cpu/cpu.cpp:			Bitu mask=cpu.cpl ? (FMASK_NORMAL | FLAG_NT) : FMASK_ALL;
src/cpu/cpu.cpp:			Bitu n_ss,n_esp;
src/cpu/cpu.cpp:			Bitu mask=cpu.cpl ? (FMASK_NORMAL | FLAG_NT) : FMASK_ALL;
src/cpu/cpu.cpp:void CPU_JMP(bool use32,Bitu selector,Bitu offset,Bitu oldeip) {
src/cpu/cpu.cpp:		Bitu rpl=selector & 3;
src/cpu/cpu.cpp:void CPU_CALL(bool use32,Bitu selector,Bitu offset,Bitu oldeip) {
src/cpu/cpu.cpp:		Bitu rpl=selector & 3;
src/cpu/cpu.cpp:				Bitu n_cs_sel=call.GetSelector();
src/cpu/cpu.cpp:				Bitu n_cs_dpl	= n_cs_desc.DPL();
src/cpu/cpu.cpp:				Bitu n_eip		= call.GetOffset();
src/cpu/cpu.cpp:						Bitu n_ss_sel,n_esp;
src/cpu/cpu.cpp:						Bitu o_esp		= reg_esp;
src/cpu/cpu.cpp:						Bitu o_ss		= SegValue(ss);
src/cpu/cpu.cpp:void CPU_RET(bool use32,Bitu bytes,Bitu oldeip) {
src/cpu/cpu.cpp:		Bitu new_ip,new_cs;
src/cpu/cpu.cpp:		Bitu offset,selector;
src/cpu/cpu.cpp:		Bitu rpl=selector & 3;
src/cpu/cpu.cpp:			Bitu n_esp,n_ss;
src/cpu/cpu.cpp:Bitu CPU_SLDT(void) {
src/cpu/cpu.cpp:bool CPU_LLDT(Bitu selector) {
src/cpu/cpu.cpp:Bitu CPU_STR(void) {
src/cpu/cpu.cpp:bool CPU_LTR(Bitu selector) {
src/cpu/cpu.cpp:void CPU_LGDT(Bitu limit,Bitu base) {
src/cpu/cpu.cpp:void CPU_LIDT(Bitu limit,Bitu base) {
src/cpu/cpu.cpp:Bitu CPU_SGDT_base(void) {
src/cpu/cpu.cpp:Bitu CPU_SGDT_limit(void) {
src/cpu/cpu.cpp:Bitu CPU_SIDT_base(void) {
src/cpu/cpu.cpp:Bitu CPU_SIDT_limit(void) {
src/cpu/cpu.cpp:void CPU_SET_CRX(Bitu cr,Bitu value) {
src/cpu/cpu.cpp:			Bitu changed=cpu.cr0 ^ value;
src/cpu/cpu.cpp:bool CPU_WRITE_CRX(Bitu cr,Bitu value) {
src/cpu/cpu.cpp:Bitu CPU_GET_CRX(Bitu cr) {
src/cpu/cpu.cpp:bool CPU_READ_CRX(Bitu cr,Bit32u & retvalue) {
src/cpu/cpu.cpp:bool CPU_WRITE_DRX(Bitu dr,Bitu value) {
src/cpu/cpu.cpp:bool CPU_READ_DRX(Bitu dr,Bit32u & retvalue) {
src/cpu/cpu.cpp:bool CPU_WRITE_TRX(Bitu tr,Bitu value) {
src/cpu/cpu.cpp:bool CPU_READ_TRX(Bitu tr,Bit32u & retvalue) {
src/cpu/cpu.cpp:Bitu CPU_SMSW(void) {
src/cpu/cpu.cpp:bool CPU_LMSW(Bitu word) {
src/cpu/cpu.cpp:void CPU_ARPL(Bitu & dest_sel,Bitu src_sel) {
src/cpu/cpu.cpp:void CPU_LAR(Bitu selector,Bitu & ar) {
src/cpu/cpu.cpp:	Descriptor desc;Bitu rpl=selector & 3;
src/cpu/cpu.cpp:void CPU_LSL(Bitu selector,Bitu & limit) {
src/cpu/cpu.cpp:	Descriptor desc;Bitu rpl=selector & 3;
src/cpu/cpu.cpp:void CPU_VERR(Bitu selector) {
src/cpu/cpu.cpp:	Descriptor desc;Bitu rpl=selector & 3;
src/cpu/cpu.cpp:void CPU_VERW(Bitu selector) {
src/cpu/cpu.cpp:	Descriptor desc;Bitu rpl=selector & 3;
src/cpu/cpu.cpp:bool CPU_SetSegGeneral(SegNames seg,Bitu value) {
src/cpu/cpu.cpp:	Bitu val=mem_readw(SegPhys(ss) + (reg_esp & cpu.stack.mask));
src/cpu/cpu.cpp:	Bitu addsp=use32?0x04:0x02;
src/cpu/cpu.cpp:void CPU_HLT(Bitu oldeip) {
src/cpu/cpu.cpp:void CPU_ENTER(bool use32,Bitu bytes,Bitu level) {
src/cpu/cpu.cpp:	Bitu sp_index=reg_esp&cpu.stack.mask;
src/cpu/cpu.cpp:	Bitu bp_index=reg_ebp&cpu.stack.mask;
src/cpu/cpu.cpp:			for (Bitu i=1;i<level;i++) {	
src/cpu/cpu.cpp:			for (Bitu i=1;i<level;i++) {	
src/cpu/cpu.cpp:		for (Bitu i=0; i<7; i++) {
src/cpu/cpu.cpp:			for (Bitu cmdnum=1; cmdnum<=cmd.GetCount(); cmdnum++) {
src/cpu/cpu.cpp:				for (Bitu cmdnum=0; cmdnum<=cmd.GetCount(); cmdnum++) {
src/cpu/core_normal/string.h:	Bitu	si_index,di_index;
src/cpu/core_normal/string.h:	Bitu	add_mask;
src/cpu/core_normal/string.h:	Bitu	count,count_left;
src/cpu/core_normal/string.h:		if ((count>(Bitu)CPU_Cycles) && (type<R_SCASB)) {
src/cpu/core_normal/prefix_0f.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_0f.h:					Bitu saveval;
src/cpu/core_normal/prefix_0f.h:					Bitu loadval;
src/cpu/core_normal/prefix_0f.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_0f.h:				GetEAa;Bitu limit;
src/cpu/core_normal/prefix_0f.h:			GetRMrw;Bitu ar=*rmrw;
src/cpu/core_normal/prefix_0f.h:			GetRMrw;Bitu limit=*rmrw;
src/cpu/core_normal/prefix_0f.h:			Bitu which=(rm >> 3) & 7;
src/cpu/core_normal/prefix_0f.h:			Bitu which=(rm >> 3) & 7;
src/cpu/core_normal/prefix_0f.h:			Bitu which=(rm >> 3) & 7;
src/cpu/core_normal/prefix_0f.h:			Bitu which=(rm >> 3) & 7;
src/cpu/core_normal/prefix_0f.h:			Bitu which=(rm >> 3) & 7;
src/cpu/core_normal/prefix_0f.h:			Bitu which=(rm >> 3) & 7;
src/cpu/core_normal/prefix_none.h:				GetEArw;Bitu new_sel=*earw;
src/cpu/core_normal/prefix_none.h:				GetEAa;Bitu new_sel=LoadMw(eaa);
src/cpu/core_normal/prefix_none.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_none.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_none.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_none.h:			GetRM;Bit16u val;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_none.h:			GetRM;Bit16u val;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_none.h:			Bitu bytes=Fetchw();
src/cpu/core_normal/prefix_none.h:			Bitu level=Fetchb();
src/cpu/core_normal/prefix_none.h:			Bitu words=Fetchw();
src/cpu/core_normal/prefix_none.h:			Bitu port=Fetchb();
src/cpu/core_normal/prefix_none.h:			Bitu port=Fetchb();
src/cpu/core_normal/prefix_none.h:			Bitu port=Fetchb();
src/cpu/core_normal/prefix_none.h:			Bitu port=Fetchb();
src/cpu/core_normal/prefix_none.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_none.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_none.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_none.h:					Bitu cb=Fetchw();
src/cpu/core_normal/prefix_none.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/table_ea.h:static INLINE PhysPt Sib(Bitu mode) {
src/cpu/core_normal/prefix_66_0f.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_66_0f.h:					Bitu saveval;
src/cpu/core_normal/prefix_66_0f.h:					Bitu loadval;
src/cpu/core_normal/prefix_66_0f.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_66_0f.h:				GetEAa;Bitu limit;
src/cpu/core_normal/prefix_66_0f.h:			GetRMrd;Bitu ar=*rmrd;
src/cpu/core_normal/prefix_66_0f.h:			GetRMrd;Bitu limit=*rmrd;
src/cpu/core_normal/prefix_66.h:		Bitu tmpesp = reg_esp;
src/cpu/core_normal/prefix_66.h:				GetEArd;Bitu new_sel=(Bit16u)*eard;
src/cpu/core_normal/prefix_66.h:				GetEAa;Bitu new_sel=LoadMw(eaa);
src/cpu/core_normal/prefix_66.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_66.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_66.h:				GetRM;Bit16u val;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_66.h:			Bitu bytes=Fetchw();
src/cpu/core_normal/prefix_66.h:			Bitu level=Fetchb();
src/cpu/core_normal/prefix_66.h:			Bitu words=Fetchw();
src/cpu/core_normal/prefix_66.h:			Bitu port=Fetchb();
src/cpu/core_normal/prefix_66.h:			Bitu port=Fetchb();
src/cpu/core_normal/prefix_66.h:			GetRM;Bitu which=(rm>>3)&7;
src/cpu/core_normal/prefix_66.h:			GetRM;Bitu which=(rm>>3)&7;
src/gui/render_loops.h:		Bitu scaleLines = SCALERHEIGHT;
src/gui/render_loops.h:		Bitu scaleLines = Scaler_Aspect[ render.scale.outLine ];
src/gui/render_loops.h:	Bitu b;
src/gui/render_loops.h:		const Bitu changeType = changed[b];
src/gui/render_loops.h:			for (Bitu i = 0; i<SCALER_BLOCKSIZE;i++) {
src/gui/render_loops.h:			BituMove((Bit8u*)(&line0[-SCALER_BLOCKSIZE*SCALERWIDTH])+render.scale.outPitch  ,WC[0], SCALER_BLOCKSIZE *SCALERWIDTH*PSIZE);
src/gui/render_loops.h:			BituMove((Bit8u*)(&line0[-SCALER_BLOCKSIZE*SCALERWIDTH])+render.scale.outPitch*2,WC[1], SCALER_BLOCKSIZE *SCALERWIDTH*PSIZE);
src/gui/render_loops.h:	Bitu scaleLines = SCALERHEIGHT;
src/gui/render_loops.h:	Bitu scaleLines = Scaler_Aspect[ render.scale.outLine ];
src/gui/render_loops.h:		BituMove( render.scale.outWrite + render.scale.outPitch * SCALERHEIGHT,
Binary file src/gui/sdlmain.o matches
Binary file src/gui/libgui.a matches
src/gui/render_scalers.h:extern Bitu Scaler_ChangedLineIndex;
src/gui/render_scalers.h:	Bitu gfxFlags;
src/gui/render_scalers.h:	Bitu xscale,yscale;
src/gui/render_scalers.h:	Bitu gfxFlags;
src/gui/render_scalers.h:	Bitu xscale,yscale;
src/gui/midi_win32.h:	void PlaySysex(Bit8u * sysex,Bitu len) {
Binary file src/gui/midi.o matches
Binary file src/gui/render_scalers.o matches
src/gui/render_simple.h:		Bitu skipLines = SCALERHEIGHT;
src/gui/render_simple.h:		Bitu skipLines = Scaler_Aspect[ render.scale.outLine++ ];
src/gui/render_simple.h:	Bitu hadChange = 0;
src/gui/render_simple.h:		if (*(Bitu const*)src == *(Bitu*)cache) {
src/gui/render_simple.h:			x-=(sizeof(Bitu)/sizeof(SRCTYPE));
src/gui/render_simple.h:			src+=(sizeof(Bitu)/sizeof(SRCTYPE));
src/gui/render_simple.h:			cache+=(sizeof(Bitu)/sizeof(SRCTYPE));
src/gui/render_simple.h:			line0+=(sizeof(Bitu)/sizeof(SRCTYPE))*SCALERWIDTH;
src/gui/render_simple.h:			for (Bitu i = x > 32 ? 32 : x;i>0;i--,x--) {
src/gui/render_simple.h:			Bitu copyLen = (Bitu)((Bit8u*)line1 - (Bit8u*)WC[0]);
src/gui/render_simple.h:			BituMove(((Bit8u*)line0)-copyLen+render.scale.outPitch  ,WC[0], copyLen );
src/gui/render_simple.h:			BituMove(((Bit8u*)line0)-copyLen+render.scale.outPitch*2,WC[1], copyLen );
src/gui/render_simple.h:	Bitu scaleLines = SCALERHEIGHT;
src/gui/render_simple.h:	Bitu scaleLines = Scaler_Aspect[ render.scale.outLine++ ];
src/gui/render_simple.h:		BituMove( render.scale.outWrite + render.scale.outPitch * SCALERHEIGHT,
src/gui/render_templates.h:	Bitu b;
src/gui/render_templates.h:		for (Bitu x=0;x<SCALER_BLOCKSIZE;x++) {
src/gui/render_templates.h:		for (Bitu x=0;x<SCALER_BLOCKSIZE;x+=sizeof(Bitu)/sizeof(SRCTYPE)) {
src/gui/render_templates.h:			if (*(Bitu const*)&src[x] != *(Bitu*)&sc[x]) {
src/gui/render_templates.h:	Bitu halfpixel=(((P & redblueMask) * 5) >> 3) & redblueMask;	\
src/gui/render_templates.h:	Bitu halfpixel=(((P & redblueMask) * 5) >> 3) & redblueMask;	\
src/gui/midi_alsa.h:	void PlaySysex(Bit8u * sysex,Bitu len) {
src/gui/midi.cpp:					} else midi.sysex.delay = (Bitu)(((float)(midi.sysex.used) * 1.25f) * 1000.0f / 3125.0f) + 2;
src/gui/sdl_mapper.cpp:	Bitu activity;
src/gui/sdl_mapper.cpp:	virtual Bitu GetActivityCount(void) {
src/gui/sdl_mapper.cpp:	Bitu mods,flags;
src/gui/sdl_mapper.cpp:SDLKey MapSDLCode(Bitu skey) {
src/gui/sdl_mapper.cpp:Bitu GetKeyCode(SDL_keysym keysym) {
src/gui/sdl_mapper.cpp:		Bitu key=(Bitu)keysym.scancode;
src/gui/sdl_mapper.cpp:			if (keysym.sym<MAX_SDLKEYS) key=scancode_map[(Bitu)keysym.sym];
src/gui/sdl_mapper.cpp:				if (GFX_SDLUsingWinDIB()) key=scancode_map[(Bitu)keysym.sym];
src/gui/sdl_mapper.cpp:		if ((keysym.sym==SDLK_BACKSLASH) && (keysym.scancode==0x56)) return (Bitu)SDLK_LESS;
src/gui/sdl_mapper.cpp:		return (Bitu)keysym.sym;
src/gui/sdl_mapper.cpp:		sprintf(buf,"Key %s",SDL_GetKeyName(MapSDLCode((Bitu)key)));
src/gui/sdl_mapper.cpp:		sprintf(buf,"key %d",MapSDLCode((Bitu)key));
src/gui/sdl_mapper.cpp:	CKeyBindGroup(Bitu _keys) : CBindGroup (){
src/gui/sdl_mapper.cpp:		for (Bitu i=0;i<_keys;i++) lists[i].clear();
src/gui/sdl_mapper.cpp:		Bitu code=ConvDecWord(num);
src/gui/sdl_mapper.cpp:		Bitu key=GetKeyCode(event->key.keysym);
src/gui/sdl_mapper.cpp:		assert(Bitu(event->key.keysym.sym)<keys);
src/gui/sdl_mapper.cpp:		if (!usescancodes) assert((Bitu)_key<keys);
src/gui/sdl_mapper.cpp:		return new CKeyBind(&lists[(Bitu)_key],_key);
src/gui/sdl_mapper.cpp:	Bitu keys;
src/gui/sdl_mapper.cpp:	CJAxisBind(CBindList * _list,CBindGroup * _group,Bitu _axis,bool _positive) : CBind(_list){
src/gui/sdl_mapper.cpp:	Bitu axis;
src/gui/sdl_mapper.cpp:	CJButtonBind(CBindList * _list,CBindGroup * _group,Bitu _button) : CBind(_list) {
src/gui/sdl_mapper.cpp:	Bitu button;
src/gui/sdl_mapper.cpp:	CJHatBind(CBindList * _list,CBindGroup * _group,Bitu _hat,Bit8u _dir) : CBind(_list) {
src/gui/sdl_mapper.cpp:	Bitu hat;
src/gui/sdl_mapper.cpp:	CStickBindGroup(Bitu _stick,Bitu _emustick,bool _dummy=false) : CBindGroup (){
src/gui/sdl_mapper.cpp:		Bitu i;
src/gui/sdl_mapper.cpp:			Bitu ax=ConvDecWord(StripWord(buf));
src/gui/sdl_mapper.cpp:			Bitu but=ConvDecWord(StripWord(buf));			
src/gui/sdl_mapper.cpp:			Bitu hat=ConvDecWord(StripWord(buf));			
src/gui/sdl_mapper.cpp:		Bitu but = 0;
src/gui/sdl_mapper.cpp:		Bitu i;
src/gui/sdl_mapper.cpp:		Bitu i;
src/gui/sdl_mapper.cpp:	CBind * CreateAxisBind(Bitu axis,bool positive) {
src/gui/sdl_mapper.cpp:	CBind * CreateButtonBind(Bitu button) {
src/gui/sdl_mapper.cpp:	CBind * CreateHatBind(Bitu hat,Bit8u value) {
src/gui/sdl_mapper.cpp:		Bitu hat_dir;
src/gui/sdl_mapper.cpp:	Bitu stick,emustick,axes,buttons,hats,emulated_axes,emulated_buttons,emulated_hats;
src/gui/sdl_mapper.cpp:	Bitu button_wrap,button_cap,axes_cap,hats_cap;
src/gui/sdl_mapper.cpp:	Bitu button_autofire[MAXBUTTON];
src/gui/sdl_mapper.cpp:	C4AxisBindGroup(Bitu _stick,Bitu _emustick) : CStickBindGroup (_stick,_emustick){
src/gui/sdl_mapper.cpp:		Bitu but = 0;
src/gui/sdl_mapper.cpp:		Bitu i;
src/gui/sdl_mapper.cpp:	CFCSBindGroup(Bitu _stick,Bitu _emustick) : CStickBindGroup (_stick,_emustick){
src/gui/sdl_mapper.cpp:		Bitu but = 0;
src/gui/sdl_mapper.cpp:		Bitu i;
src/gui/sdl_mapper.cpp:	CCHBindGroup(Bitu _stick,Bitu _emustick) : CStickBindGroup (_stick,_emustick){
src/gui/sdl_mapper.cpp:		Bitu but = 0;
src/gui/sdl_mapper.cpp:		Bitu bt_state=15;
src/gui/sdl_mapper.cpp:		Bitu i;
src/gui/sdl_mapper.cpp:	Bitu mods;
src/gui/sdl_mapper.cpp:		Bitu num_groups,num;
src/gui/sdl_mapper.cpp:	Bitu validmod=0;
src/gui/sdl_mapper.cpp:static void DrawText(Bitu x,Bitu y,const char * text,Bit8u color) {
src/gui/sdl_mapper.cpp:		Bitu i,j;Bit8u * draw_line=draw;
src/gui/sdl_mapper.cpp:	CButton(Bitu _x,Bitu _y,Bitu _dx,Bitu _dy) {
src/gui/sdl_mapper.cpp:		for (Bitu lines=0;lines<dy;lines++)  {
src/gui/sdl_mapper.cpp:				for (Bitu cols=0;cols<dx;cols++) *(point+cols)=color;
src/gui/sdl_mapper.cpp:	virtual bool OnTop(Bitu _x,Bitu _y) {
src/gui/sdl_mapper.cpp:	Bitu x,y,dx,dy;
src/gui/sdl_mapper.cpp:	CTextButton(Bitu _x,Bitu _y,Bitu _dx,Bitu _dy,const char * _text) : CButton(_x,_y,_dx,_dy) { text=_text;}
src/gui/sdl_mapper.cpp:	CEventButton(Bitu _x,Bitu _y,Bitu _dx,Bitu _dy,const char * _text,CEvent * _event) 
src/gui/sdl_mapper.cpp:	CCaptionButton(Bitu _x,Bitu _y,Bitu _dx,Bitu _dy) : CButton(_x,_y,_dx,_dy){
src/gui/sdl_mapper.cpp:	CBindButton(Bitu _x,Bitu _y,Bitu _dx,Bitu _dy,const char * _text,BB_Types _type) 
src/gui/sdl_mapper.cpp:	CCheckButton(Bitu _x,Bitu _y,Bitu _dx,Bitu _dy,const char * _text,BC_Types _type) 
src/gui/sdl_mapper.cpp:			for (Bitu lines=0;lines<(dy-4);lines++)  {
src/gui/sdl_mapper.cpp:	CJAxisEvent(char const * const _entry,Bitu _stick,Bitu _axis,bool _positive,CJAxisEvent * _opposite_axis) : CContinuousEvent(_entry) {
src/gui/sdl_mapper.cpp:	virtual Bitu GetActivityCount(void) {
src/gui/sdl_mapper.cpp:	Bitu stick,axis;
src/gui/sdl_mapper.cpp:	CJButtonEvent(char const * const _entry,Bitu _stick,Bitu _button) : CTriggeredEvent(_entry) {
src/gui/sdl_mapper.cpp:	Bitu stick,button;
src/gui/sdl_mapper.cpp:	CJHatEvent(char const * const _entry,Bitu _stick,Bitu _hat,Bitu _dir) : CTriggeredEvent(_entry) {
src/gui/sdl_mapper.cpp:	Bitu stick,hat,dir;
src/gui/sdl_mapper.cpp:	CModEvent(char const * const _entry,Bitu _wmod) : CTriggeredEvent(_entry) {
src/gui/sdl_mapper.cpp:	Bitu wmod;
src/gui/sdl_mapper.cpp:	CHandlerEvent(char const * const _entry,MAPPER_Handler * _handler,MapKeys _key,Bitu _mod,char const * const _buttonname) : CTriggeredEvent(_entry) {
src/gui/sdl_mapper.cpp:		Bitu key=0;
src/gui/sdl_mapper.cpp:	Bitu defmod;
src/gui/sdl_mapper.cpp:static CKeyEvent * AddKeyButtonEvent(Bitu x,Bitu y,Bitu dx,Bitu dy,char const * const title,char const * const entry,KBD_KEYS key) {
src/gui/sdl_mapper.cpp:static CJAxisEvent * AddJAxisButton(Bitu x,Bitu y,Bitu dx,Bitu dy,char const * const title,Bitu stick,Bitu axis,bool positive,CJAxisEvent * opposite_axis) {
src/gui/sdl_mapper.cpp:static CJAxisEvent * AddJAxisButton_hidden(Bitu stick,Bitu axis,bool positive,CJAxisEvent * opposite_axis) {
src/gui/sdl_mapper.cpp:static void AddJButtonButton(Bitu x,Bitu y,Bitu dx,Bitu dy,char const * const title,Bitu stick,Bitu button) {
src/gui/sdl_mapper.cpp:static void AddJButtonButton_hidden(Bitu stick,Bitu button) {
src/gui/sdl_mapper.cpp:static void AddJHatButton(Bitu x,Bitu y,Bitu dx,Bitu dy,char const * const title,Bitu _stick,Bitu _hat,Bitu _dir) {
src/gui/sdl_mapper.cpp:static void AddModButton(Bitu x,Bitu y,Bitu dx,Bitu dy,char const * const title,Bitu _mod) {
src/gui/sdl_mapper.cpp:	Bitu i;
src/gui/sdl_mapper.cpp:	Bitu xpos=3;Bitu ypos=11;
src/gui/sdl_mapper.cpp:	Bitu key;
src/gui/sdl_mapper.cpp:	Bitu i=0;
src/gui/sdl_mapper.cpp:void MAPPER_AddHandler(MAPPER_Handler * handler,MapKeys key,Bitu mods,char const * const eventname,char const * const buttonname) {
src/gui/sdl_mapper.cpp:	for (Bitu i=0; i<mapper.sticks.num_groups; i++) {
src/gui/sdl_mapper.cpp:void MAPPER_RunEvent(Bitu /*val*/) {
src/gui/sdl_mapper.cpp:		Bitu i;
src/gui/midi_coreaudio.h:	void PlaySysex(Bit8u * sysex, Bitu len) {
src/gui/render_scalers.cpp:Bitu Scaler_ChangedLineIndex;
src/gui/render_scalers.cpp:static INLINE void BituMove( void *_dst, const void * _src, Bitu size) {
src/gui/render_scalers.cpp:	Bitu * dst=(Bitu *)(_dst);
src/gui/render_scalers.cpp:	const Bitu * src=(Bitu *)(_src);
src/gui/render_scalers.cpp:	size/=sizeof(Bitu);
src/gui/render_scalers.cpp:	for (Bitu x=0; x<size;x++)
src/gui/render_scalers.cpp:static INLINE void ScalerAddLines( Bitu changed, Bitu count ) {
src/gui/render_scalers.cpp:#define BituMove2(_DST,_SRC,_SIZE)			\
src/gui/render_scalers.cpp:	Bitu bsize=(_SIZE)/sizeof(Bitu);		\
src/gui/render_scalers.cpp:	Bitu * bdst=(Bitu *)(_DST);				\
src/gui/render_scalers.cpp:	Bitu * bsrc=(Bitu *)(_SRC);				\
Binary file src/gui/sdl_mapper.o matches
Binary file src/gui/render.o matches
src/gui/sdlmain.cpp:		Bitu flags;
src/gui/sdlmain.cpp:		Bitu pitch;
src/gui/sdlmain.cpp:		Bitu sensitivity;
src/gui/sdlmain.cpp:	Bitu num_joysticks;
src/gui/sdlmain.cpp:Bitu GFX_GetBestMode(Bitu flags) {
src/gui/sdlmain.cpp:	Bitu testbpp,gotbpp;
src/gui/sdlmain.cpp:Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t callback) {
src/gui/sdlmain.cpp:	Bitu retFlags = 0;
src/gui/sdlmain.cpp:bool GFX_StartUpdate(Bit8u * & pixels,Bitu & pitch) {
src/gui/sdlmain.cpp:			Bitu y = 0, index = 0, rectCount = 0;
src/gui/sdlmain.cpp:			Bitu y = 0, index = 0;
src/gui/sdlmain.cpp:					Bitu height = changedLines[index];
src/gui/sdlmain.cpp:void GFX_SetPalette(Bitu start,Bitu count,GFX_PalEntry * entries) {
src/gui/sdlmain.cpp:Bitu GFX_GetRGB(Bit8u red,Bit8u green,Bit8u blue) {
src/gui/sdlmain.cpp:static void OutputString(Bitu x,Bitu y,const char * text,Bit32u color,Bit32u color2,SDL_Surface * output_surface) {
src/gui/sdlmain.cpp:		Bitu i,j;
src/gui/sdlmain.cpp:		for (Bitu y=0; y<400; y++) {
src/gui/sdlmain.cpp:			for (Bitu x=0; x<640; x++) {
src/gui/sdlmain.cpp:		static Bitu max_splash_loop = 600;
src/gui/sdlmain.cpp:		static Bitu splash_fade = 100;
src/gui/sdlmain.cpp:	for(Bitu i = 0; i < parameters.size(); i++) newargs[i]=(char*)parameters[i].c_str();
src/gui/midi_oss.h:		Bit8u buf[128];Bitu pos=0;
src/gui/midi_oss.h:		Bitu len=MIDI_evt_len[*msg];
src/gui/midi_oss.h:	void PlaySysex(Bit8u * sysex,Bitu len) {
src/gui/midi_oss.h:		Bit8u buf[SYSEX_SIZE*4];Bitu pos=0;
src/gui/render.cpp:	Bitu i;
src/gui/render.cpp:		const Bitu *src = (Bitu*)s;
src/gui/render.cpp:		Bitu *cache = (Bitu*)(render.scale.cacheRead);
src/gui/render.cpp:		const Bitu *src = (Bitu*)s;
src/gui/render.cpp:		Bitu *cache = (Bitu*)(render.scale.cacheRead);
src/gui/render.cpp:	Bitu x, width;
src/gui/render.cpp:extern Bitu PIC_Ticks;
src/gui/render.cpp:		Bitu pitch, flags;
src/gui/render.cpp:		Bitu total = 0, i;
src/gui/render.cpp:static Bitu MakeAspectTable(Bitu skip,Bitu height,double scaley,Bitu miny) {
src/gui/render.cpp:	Bitu i;
src/gui/render.cpp:	Bitu linesadded=0;
src/gui/render.cpp:			Bitu templines = (Bitu)lines;
src/gui/render.cpp:	Bitu width=render.src.width;
src/gui/render.cpp:	Bitu height=render.src.height;
src/gui/render.cpp:	Bitu gfx_flags, xscale, yscale;
src/gui/render.cpp:		render.src.start = ( render.src.width * 1) / sizeof(Bitu);
src/gui/render.cpp:			render.src.start = ( render.src.width * 2) / sizeof(Bitu);
src/gui/render.cpp:			render.src.start = ( render.src.width * 2) / sizeof(Bitu);
src/gui/render.cpp:			render.src.start = ( render.src.width * 4) / sizeof(Bitu);
src/gui/render.cpp:	Bitu skip = complexBlock ? 1 : 0;
src/gui/render.cpp:void RENDER_SetSize(Bitu width,Bitu height,Bitu bpp,float fps,double ratio,bool dblw,bool dblh) {
src/gui/render.cpp:	Bitu scalersize = render.scale.size;
src/gui/midi_coremidi.h:		Bitu numDests = MIDIGetNumberOfDestinations();
src/gui/midi_coremidi.h:		Bitu destId = 0;
src/gui/midi_coremidi.h:		Bitu len=MIDI_evt_len[*msg];
src/gui/midi_coremidi.h:	void PlaySysex(Bit8u * sysex, Bitu len) {
src/gui/midi_coremidi.h:		Bitu pos=0;
src/gui/midi_coremidi.h:		Bitu numDests = MIDIGetNumberOfDestinations();
src/gui/midi_coremidi.h:		for(Bitu i = 0; i < numDests; i++){
src/libs/porttalk/porttalk.cpp:			Bitu retval=0;
config.h.in~:  typedef Bit32u Bitu;
config.h.in~:  typedef Bit64u Bitu;
parpassth_printer_30_11_08.diff: 		Bitu ppindex=0; // number of lpt ports
parpassth_printer_30_11_08.diff:+	for(Bitu i = 0; i < 3; i++) {
parpassth_printer_30_11_08.diff:+Bitu PRINTER_readdata(Bitu port,Bitu iolen);
parpassth_printer_30_11_08.diff:+void PRINTER_writedata(Bitu port,Bitu val,Bitu iolen);
parpassth_printer_30_11_08.diff:+Bitu PRINTER_readstatus(Bitu port,Bitu iolen);
parpassth_printer_30_11_08.diff:+void PRINTER_writecontrol(Bitu port,Bitu val, Bitu iolen);
parpassth_printer_30_11_08.diff:+Bitu PRINTER_readcontrol(Bitu port,Bitu iolen);
parpassth_printer_30_11_08.diff:+			Bitu retval=0;
parpassth_printer_30_11_08.diff:+			Bitu nr,
parpassth_printer_30_11_08.diff:+	Bitu Read_PR();
parpassth_printer_30_11_08.diff:+	Bitu Read_COM();
parpassth_printer_30_11_08.diff:+	Bitu Read_SR();
parpassth_printer_30_11_08.diff:+	void Write_PR(Bitu);
parpassth_printer_30_11_08.diff:+	void Write_CON(Bitu);
parpassth_printer_30_11_08.diff:+	void Write_IOSEL(Bitu);
parpassth_printer_30_11_08.diff:+CDirectLPT::CDirectLPT (Bitu nr, Bit8u initIrq, CommandLine* cmd)
parpassth_printer_30_11_08.diff:+	Bitu timeout = 10000;
parpassth_printer_30_11_08.diff:+	Bitu time = timeout+SDL_GetTicks();
parpassth_printer_30_11_08.diff:+	Bitu z = 0;
parpassth_printer_30_11_08.diff:+Bitu CDirectLPT::Read_PR() {
parpassth_printer_30_11_08.diff:+	Bitu retval;
parpassth_printer_30_11_08.diff:+Bitu CDirectLPT::Read_COM() {
parpassth_printer_30_11_08.diff:+	Bitu retval;
parpassth_printer_30_11_08.diff:+Bitu CDirectLPT::Read_SR() {
parpassth_printer_30_11_08.diff:+	Bitu retval;
parpassth_printer_30_11_08.diff:+void CDirectLPT::Write_PR(Bitu val){
parpassth_printer_30_11_08.diff:+void CDirectLPT::Write_CON(Bitu val) {
parpassth_printer_30_11_08.diff:+void CDirectLPT::Write_IOSEL(Bitu val) {
parpassth_printer_30_11_08.diff:+CFileLPT::CFileLPT (Bitu nr, Bit8u initIrq, const char* path, CommandLine* cmd)
parpassth_printer_30_11_08.diff:+	Bitu timeout = 10000;
parpassth_printer_30_11_08.diff:+	Bitu time = timeout+SDL_GetTicks();
parpassth_printer_30_11_08.diff:+	Bitu z = 0;
parpassth_printer_30_11_08.diff:+Bitu CFileLPT::Read_PR()
parpassth_printer_30_11_08.diff:+Bitu CFileLPT::Read_COM()
parpassth_printer_30_11_08.diff:+Bitu CFileLPT::Read_SR()
parpassth_printer_30_11_08.diff:+void CFileLPT::Write_PR(Bitu val) {
parpassth_printer_30_11_08.diff:+void CFileLPT::Write_CON(Bitu val) {
parpassth_printer_30_11_08.diff:+void CFileLPT::Write_IOSEL(Bitu val) {
parpassth_printer_30_11_08.diff:+#define PIXX ((Bitu)floor(curX*dpi+0.5))
parpassth_printer_30_11_08.diff:+#define PIXY ((Bitu)floor(curY*dpi+0.5))
parpassth_printer_30_11_08.diff:+static Bitu printer_timout;
parpassth_printer_30_11_08.diff:+						(Bitu)(defaultPageWidth*dpi), 
parpassth_printer_30_11_08.diff:+						(Bitu)(defaultPageHeight*dpi), 
parpassth_printer_30_11_08.diff:+		for (Bitu i=0; i<32; i++)
parpassth_printer_30_11_08.diff:+		for (Bitu i=0;i<32;i++)
parpassth_printer_30_11_08.diff:+				//	(Bitu)definedUnit,PARAM16(2),PARAM16(4),topMargin,bottomMargin,
parpassth_printer_30_11_08.diff:+static void PRINTER_EventHandler(Bitu param);
parpassth_printer_30_11_08.diff:+	for (Bitu y=0; y<bitmap.rows; y++) {
parpassth_printer_30_11_08.diff:+		for (Bitu x=0; x<bitmap.width; x++) {
parpassth_printer_30_11_08.diff:+void CPrinter::drawLine(Bitu fromx, Bitu tox, Bitu y, bool broken)
parpassth_printer_30_11_08.diff:+	Bitu breakmod = dpi / 15;
parpassth_printer_30_11_08.diff:+	Bitu gapstart = (breakmod * 4)/5;
parpassth_printer_30_11_08.diff:+	for (Bitu x=fromx; x<=tox; x++)
parpassth_printer_30_11_08.diff:+	Bitu pixsizeX=1; 
parpassth_printer_30_11_08.diff:+	Bitu pixsizeY=1;
parpassth_printer_30_11_08.diff:+//	Bitu pixsizeX = dpi/bitGraph.horizDens > 0? dpi/bitGraph.horizDens : 1;
parpassth_printer_30_11_08.diff:+//	Bitu pixsizeY = dpi/bitGraph.vertDens > 0? dpi/bitGraph.vertDens : 1;
parpassth_printer_30_11_08.diff:+	for (Bitu i=0; i<bitGraph.bytesColumn; i++) // for each byte
parpassth_printer_30_11_08.diff:+		for (Bitu j=128; j!=0; j>>=1) { // for each bit
parpassth_printer_30_11_08.diff:+				for (Bitu xx=0; xx<pixsizeX; xx++)
parpassth_printer_30_11_08.diff:+					for (Bitu yy=0; yy<pixsizeY; yy++) {
parpassth_printer_30_11_08.diff:+	Bitu i = 1;
parpassth_printer_30_11_08.diff:+	Bitu slen = strlen(document_path);
parpassth_printer_30_11_08.diff:+		Bitu i;
parpassth_printer_30_11_08.diff:+Bitu PRINTER_readdata(Bitu port,Bitu iolen) {
parpassth_printer_30_11_08.diff:+void PRINTER_writedata(Bitu port,Bitu val,Bitu iolen) {
parpassth_printer_30_11_08.diff:+Bitu PRINTER_readstatus(Bitu port,Bitu iolen) {
parpassth_printer_30_11_08.diff:+static void PRINTER_EventHandler(Bitu param) {
parpassth_printer_30_11_08.diff:+void PRINTER_writecontrol(Bitu port,Bitu val, Bitu iolen)
parpassth_printer_30_11_08.diff:+Bitu PRINTER_readcontrol(Bitu port,Bitu iolen)
parpassth_printer_30_11_08.diff:+			Bitu nr,
parpassth_printer_30_11_08.diff:+	Bitu Read_PR();
parpassth_printer_30_11_08.diff:+	Bitu Read_COM();
parpassth_printer_30_11_08.diff:+	Bitu Read_SR();
parpassth_printer_30_11_08.diff:+	void Write_PR(Bitu);
parpassth_printer_30_11_08.diff:+	void Write_CON(Bitu);
parpassth_printer_30_11_08.diff:+	void Write_IOSEL(Bitu);
parpassth_printer_30_11_08.diff:+	CPrinterRedir(Bitu nr, Bit8u initIrq, CommandLine* cmd);
parpassth_printer_30_11_08.diff:+	Bitu Read_PR();
parpassth_printer_30_11_08.diff:+	Bitu Read_COM();
parpassth_printer_30_11_08.diff:+	Bitu Read_SR();
parpassth_printer_30_11_08.diff:+	void Write_PR(Bitu);
parpassth_printer_30_11_08.diff:+	void Write_CON(Bitu);
parpassth_printer_30_11_08.diff:+	void Write_IOSEL(Bitu);
parpassth_printer_30_11_08.diff:+	void drawLine(Bitu fromx, Bitu tox, Bitu y, bool broken);
parpassth_printer_30_11_08.diff:+	CParallel(CommandLine* cmd, Bitu portnr, Bit8u initirq);
parpassth_printer_30_11_08.diff:+	Bitu base;
parpassth_printer_30_11_08.diff:+	Bitu irq;
parpassth_printer_30_11_08.diff:+	virtual Bitu Read_PR()=0;
parpassth_printer_30_11_08.diff:+	virtual Bitu Read_COM()=0;
parpassth_printer_30_11_08.diff:+	virtual Bitu Read_SR()=0;
parpassth_printer_30_11_08.diff:+	virtual void Write_PR(Bitu)=0;
parpassth_printer_30_11_08.diff:+	virtual void Write_CON(Bitu)=0;
parpassth_printer_30_11_08.diff:+	virtual void Write_IOSEL(Bitu)=0;
parpassth_printer_30_11_08.diff:+	CDirectLPT(Bitu nr, Bit8u initIrq, CommandLine* cmd);
parpassth_printer_30_11_08.diff:+	Bitu Read_PR();
parpassth_printer_30_11_08.diff:+	Bitu Read_COM();
parpassth_printer_30_11_08.diff:+	Bitu Read_SR();
parpassth_printer_30_11_08.diff:+	void Write_PR(Bitu);
parpassth_printer_30_11_08.diff:+	void Write_CON(Bitu);
parpassth_printer_30_11_08.diff:+	void Write_IOSEL(Bitu);
parpassth_printer_30_11_08.diff:+CDirectLPT::CDirectLPT (Bitu nr, Bit8u initIrq, CommandLine* cmd)
parpassth_printer_30_11_08.diff:+	Bitu timeout = 10000;
parpassth_printer_30_11_08.diff:+	Bitu time = timeout+SDL_GetTicks();
parpassth_printer_30_11_08.diff:+	Bitu z = 0;
parpassth_printer_30_11_08.diff:+Bitu CDirectLPT::Read_PR()
parpassth_printer_30_11_08.diff:+Bitu CDirectLPT::Read_COM()
parpassth_printer_30_11_08.diff:+Bitu CDirectLPT::Read_SR()
parpassth_printer_30_11_08.diff:+void CDirectLPT::Write_PR(Bitu val)
parpassth_printer_30_11_08.diff:+void CDirectLPT::Write_CON(Bitu val)
parpassth_printer_30_11_08.diff:+void CDirectLPT::Write_IOSEL(Bitu val)
parpassth_printer_30_11_08.diff:+CPrinterRedir::CPrinterRedir(Bitu nr, Bit8u initIrq, CommandLine* cmd)
parpassth_printer_30_11_08.diff:+Bitu CPrinterRedir::Read_PR() {
parpassth_printer_30_11_08.diff:+Bitu CPrinterRedir::Read_COM() {
parpassth_printer_30_11_08.diff:+Bitu CPrinterRedir::Read_SR() {
parpassth_printer_30_11_08.diff:+void CPrinterRedir::Write_PR(Bitu val) {
parpassth_printer_30_11_08.diff:+void CPrinterRedir::Write_CON(Bitu val) {
parpassth_printer_30_11_08.diff:+void CPrinterRedir::Write_IOSEL(Bitu val) {
parpassth_printer_30_11_08.diff:+static Bitu PARALLEL_Read (Bitu port, Bitu iolen) {
parpassth_printer_30_11_08.diff:+	for(Bitu i = 0; i < 3; i++) {
parpassth_printer_30_11_08.diff:+			Bitu retval=0xff;
parpassth_printer_30_11_08.diff:+static void PARALLEL_Write (Bitu port, Bitu val, Bitu) {
parpassth_printer_30_11_08.diff:+	for(Bitu i = 0; i < 4; i++) {
parpassth_printer_30_11_08.diff:+		Bitu len=strlen(buf);
parpassth_printer_30_11_08.diff:+CParallel::CParallel(CommandLine* cmd, Bitu portnr, Bit8u initirq) {
parpassth_printer_30_11_08.diff:+	for (Bitu i = 0; i < 3; i++) {
parpassth_printer_30_11_08.diff:+void RunIdleTime(Bitu milliseconds)
parpassth_printer_30_11_08.diff:+	Bitu time=SDL_GetTicks()+milliseconds;
parpassth_printer_30_11_08.diff:+		for (Bitu i = 0; i < 3; i++) {
parpassth_printer_30_11_08.diff:+		for (Bitu i = 0; i < 3; i++)
